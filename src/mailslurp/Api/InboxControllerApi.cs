// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IInboxControllerApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        InboxControllerApiEvents Events { get; }

        /// <summary>
        /// Cancel a scheduled email job
        /// </summary>
        /// <remarks>
        /// Get a scheduled email job and cancel it. Will fail if status of job is already cancelled, failed, or complete.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICancelScheduledJobApiResponse"/>&gt;</returns>
        Task<ICancelScheduledJobApiResponse> CancelScheduledJobAsync(Guid jobId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Cancel a scheduled email job
        /// </summary>
        /// <remarks>
        /// Get a scheduled email job and cancel it. Will fail if status of job is already cancelled, failed, or complete.
        /// </remarks>
        /// <param name="jobId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICancelScheduledJobApiResponse"/>&gt;</returns>
        Task<ICancelScheduledJobApiResponse> CancelScheduledJobOrDefaultAsync(Guid jobId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either &#x60;SMTP&#x60; or &#x60;HTTP&#x60; inboxes.
        /// </summary>
        /// <remarks>
        /// Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Avoid &#x60;SMTP&#x60; inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID. (optional)</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI. (optional)</param>
        /// <param name="name">Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails. (optional)</param>
        /// <param name="description">Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with (optional)</param>
        /// <param name="useDomainPool">Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types. (optional)</param>
        /// <param name="favourite">Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering (optional)</param>
        /// <param name="expiresAt">Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)</param>
        /// <param name="expiresIn">Number of milliseconds that inbox should exist for (optional)</param>
        /// <param name="allowTeamAccess">DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization. (optional)</param>
        /// <param name="inboxType">HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mxslurp.click&#x60;. (optional)</param>
        /// <param name="virtualInbox">Virtual inbox prevents any outbound emails from being sent. It creates sent email records but will never send real emails to recipients. Great for testing and faking email sending. (optional)</param>
        /// <param name="useShortAddress">Use a shorter email address under 31 characters (optional)</param>
        /// <param name="domainId">ID of custom domain to use for email address. (optional)</param>
        /// <param name="domainName">FQDN domain name for the domain you have verified. Will be appended with a randomly assigned recipient name. Use the &#x60;emailAddress&#x60; option instead to specify the full custom inbox. (optional)</param>
        /// <param name="prefix">Prefix to add before the email address for easier labelling or identification. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxApiResponse"/>&gt;</returns>
        Task<ICreateInboxApiResponse> CreateInboxAsync(Option<string> emailAddress = default, Option<List<string>> tags = default, Option<string> name = default, Option<string> description = default, Option<bool> useDomainPool = default, Option<bool> favourite = default, Option<DateTime> expiresAt = default, Option<long> expiresIn = default, Option<bool> allowTeamAccess = default, Option<string> inboxType = default, Option<bool> virtualInbox = default, Option<bool> useShortAddress = default, Option<Guid> domainId = default, Option<string> domainName = default, Option<string> prefix = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either &#x60;SMTP&#x60; or &#x60;HTTP&#x60; inboxes.
        /// </summary>
        /// <remarks>
        /// Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
        /// </remarks>
        /// <param name="emailAddress">A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Avoid &#x60;SMTP&#x60; inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID. (optional)</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI. (optional)</param>
        /// <param name="name">Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails. (optional)</param>
        /// <param name="description">Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with (optional)</param>
        /// <param name="useDomainPool">Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types. (optional)</param>
        /// <param name="favourite">Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering (optional)</param>
        /// <param name="expiresAt">Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)</param>
        /// <param name="expiresIn">Number of milliseconds that inbox should exist for (optional)</param>
        /// <param name="allowTeamAccess">DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization. (optional)</param>
        /// <param name="inboxType">HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mxslurp.click&#x60;. (optional)</param>
        /// <param name="virtualInbox">Virtual inbox prevents any outbound emails from being sent. It creates sent email records but will never send real emails to recipients. Great for testing and faking email sending. (optional)</param>
        /// <param name="useShortAddress">Use a shorter email address under 31 characters (optional)</param>
        /// <param name="domainId">ID of custom domain to use for email address. (optional)</param>
        /// <param name="domainName">FQDN domain name for the domain you have verified. Will be appended with a randomly assigned recipient name. Use the &#x60;emailAddress&#x60; option instead to specify the full custom inbox. (optional)</param>
        /// <param name="prefix">Prefix to add before the email address for easier labelling or identification. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxApiResponse"/>&gt;</returns>
        Task<ICreateInboxApiResponse> CreateInboxOrDefaultAsync(Option<string> emailAddress = default, Option<List<string>> tags = default, Option<string> name = default, Option<string> description = default, Option<bool> useDomainPool = default, Option<bool> favourite = default, Option<DateTime> expiresAt = default, Option<long> expiresIn = default, Option<bool> allowTeamAccess = default, Option<string> inboxType = default, Option<bool> virtualInbox = default, Option<bool> useShortAddress = default, Option<Guid> domainId = default, Option<string> domainName = default, Option<string> prefix = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an inbox ruleset
        /// </summary>
        /// <remarks>
        /// Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">inboxId</param>
        /// <param name="createInboxRulesetOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxRulesetApiResponse"/>&gt;</returns>
        Task<ICreateInboxRulesetApiResponse> CreateInboxRulesetAsync(Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an inbox ruleset
        /// </summary>
        /// <remarks>
        /// Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving
        /// </remarks>
        /// <param name="inboxId">inboxId</param>
        /// <param name="createInboxRulesetOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxRulesetApiResponse"/>&gt;</returns>
        Task<ICreateInboxRulesetApiResponse> CreateInboxRulesetOrDefaultAsync(Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an inbox with default options. Uses MailSlurp domain pool address and is private.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxWithDefaultsApiResponse"/>&gt;</returns>
        Task<ICreateInboxWithDefaultsApiResponse> CreateInboxWithDefaultsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an inbox with default options. Uses MailSlurp domain pool address and is private.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxWithDefaultsApiResponse"/>&gt;</returns>
        Task<ICreateInboxWithDefaultsApiResponse> CreateInboxWithDefaultsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an inbox with options. Extended options for inbox creation.
        /// </summary>
        /// <remarks>
        /// Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createInboxDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxWithOptionsApiResponse"/>&gt;</returns>
        Task<ICreateInboxWithOptionsApiResponse> CreateInboxWithOptionsAsync(CreateInboxDto createInboxDto, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an inbox with options. Extended options for inbox creation.
        /// </summary>
        /// <remarks>
        /// Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
        /// </remarks>
        /// <param name="createInboxDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxWithOptionsApiResponse"/>&gt;</returns>
        Task<ICreateInboxWithOptionsApiResponse> CreateInboxWithOptionsOrDefaultAsync(CreateInboxDto createInboxDto, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete all emails in a given inboxes.
        /// </summary>
        /// <remarks>
        /// Deletes all emails in an inbox. Be careful as emails cannot be recovered
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxEmailsApiResponse"/>&gt;</returns>
        Task<IDeleteAllInboxEmailsApiResponse> DeleteAllInboxEmailsAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete all emails in a given inboxes.
        /// </summary>
        /// <remarks>
        /// Deletes all emails in an inbox. Be careful as emails cannot be recovered
        /// </remarks>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxEmailsApiResponse"/>&gt;</returns>
        Task<IDeleteAllInboxEmailsApiResponse> DeleteAllInboxEmailsOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete all inboxes
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesApiResponse"/>&gt;</returns>
        Task<IDeleteAllInboxesApiResponse> DeleteAllInboxesAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete all inboxes
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesApiResponse"/>&gt;</returns>
        Task<IDeleteAllInboxesApiResponse> DeleteAllInboxesOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete inboxes by description
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by description
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="description"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesByDescriptionApiResponse"/>&gt;</returns>
        Task<IDeleteAllInboxesByDescriptionApiResponse> DeleteAllInboxesByDescriptionAsync(string description, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete inboxes by description
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by description
        /// </remarks>
        /// <param name="description"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesByDescriptionApiResponse"/>&gt;</returns>
        Task<IDeleteAllInboxesByDescriptionApiResponse> DeleteAllInboxesByDescriptionOrDefaultAsync(string description, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete inboxes by name
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by name
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesByNameApiResponse"/>&gt;</returns>
        Task<IDeleteAllInboxesByNameApiResponse> DeleteAllInboxesByNameAsync(string name, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete inboxes by name
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by name
        /// </remarks>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesByNameApiResponse"/>&gt;</returns>
        Task<IDeleteAllInboxesByNameApiResponse> DeleteAllInboxesByNameOrDefaultAsync(string name, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete inboxes by tag
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by tag
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesByTagApiResponse"/>&gt;</returns>
        Task<IDeleteAllInboxesByTagApiResponse> DeleteAllInboxesByTagAsync(string tag, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete inboxes by tag
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by tag
        /// </remarks>
        /// <param name="tag"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesByTagApiResponse"/>&gt;</returns>
        Task<IDeleteAllInboxesByTagApiResponse> DeleteAllInboxesByTagOrDefaultAsync(string tag, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete inbox
        /// </summary>
        /// <remarks>
        /// Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteInboxApiResponse"/>&gt;</returns>
        Task<IDeleteInboxApiResponse> DeleteInboxAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete inbox
        /// </summary>
        /// <remarks>
        /// Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
        /// </remarks>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteInboxApiResponse"/>&gt;</returns>
        Task<IDeleteInboxApiResponse> DeleteInboxOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Does inbox exist
        /// </summary>
        /// <remarks>
        /// Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">Email address</param>
        /// <param name="allowCatchAll"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDoesInboxExistApiResponse"/>&gt;</returns>
        Task<IDoesInboxExistApiResponse> DoesInboxExistAsync(string emailAddress, Option<bool> allowCatchAll = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Does inbox exist
        /// </summary>
        /// <remarks>
        /// Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses
        /// </remarks>
        /// <param name="emailAddress">Email address</param>
        /// <param name="allowCatchAll"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDoesInboxExistApiResponse"/>&gt;</returns>
        Task<IDoesInboxExistApiResponse> DoesInboxExistOrDefaultAsync(string emailAddress, Option<bool> allowCatchAll = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Does inbox have automations
        /// </summary>
        /// <remarks>
        /// Check if an inbox has automations.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDoesInboxHaveAutomationsApiResponse"/>&gt;</returns>
        Task<IDoesInboxHaveAutomationsApiResponse> DoesInboxHaveAutomationsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Does inbox have automations
        /// </summary>
        /// <remarks>
        /// Check if an inbox has automations.
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDoesInboxHaveAutomationsApiResponse"/>&gt;</returns>
        Task<IDoesInboxHaveAutomationsApiResponse> DoesInboxHaveAutomationsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove expired inboxes
        /// </summary>
        /// <remarks>
        /// Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Optional expired at before flag to flush expired inboxes that have expired before the given time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFlushExpiredApiResponse"/>&gt;</returns>
        Task<IFlushExpiredApiResponse> FlushExpiredAsync(Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove expired inboxes
        /// </summary>
        /// <remarks>
        /// Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)
        /// </remarks>
        /// <param name="before">Optional expired at before flag to flush expired inboxes that have expired before the given time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFlushExpiredApiResponse"/>&gt;</returns>
        Task<IFlushExpiredApiResponse> FlushExpiredOrDefaultAsync(Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List All Inboxes Paginated
        /// </summary>
        /// <remarks>
        /// List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllInboxesApiResponse"/>&gt;</returns>
        Task<IGetAllInboxesApiResponse> GetAllInboxesAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> favourite = default, Option<string> search = default, Option<string> tag = default, Option<bool> teamAccess = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> inboxType = default, Option<string> inboxFunction = default, Option<Guid> domainId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List All Inboxes Paginated
        /// </summary>
        /// <remarks>
        /// List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllInboxesApiResponse"/>&gt;</returns>
        Task<IGetAllInboxesApiResponse> GetAllInboxesOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> favourite = default, Option<string> search = default, Option<string> tag = default, Option<bool> teamAccess = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> inboxType = default, Option<string> inboxFunction = default, Option<Guid> domainId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List All Inboxes Offset Paginated
        /// </summary>
        /// <remarks>
        /// List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllInboxesOffsetPaginatedApiResponse"/>&gt;</returns>
        Task<IGetAllInboxesOffsetPaginatedApiResponse> GetAllInboxesOffsetPaginatedAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> favourite = default, Option<string> search = default, Option<string> tag = default, Option<bool> teamAccess = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> inboxType = default, Option<string> inboxFunction = default, Option<Guid> domainId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List All Inboxes Offset Paginated
        /// </summary>
        /// <remarks>
        /// List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllInboxesOffsetPaginatedApiResponse"/>&gt;</returns>
        Task<IGetAllInboxesOffsetPaginatedApiResponse> GetAllInboxesOffsetPaginatedOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> favourite = default, Option<string> search = default, Option<string> tag = default, Option<bool> teamAccess = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> inboxType = default, Option<string> inboxFunction = default, Option<Guid> domainId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all sub address plus address aliases for an inbox
        /// </summary>
        /// <remarks>
        /// Returns paginated list of all plus alias addresses found for in account based on received emails that used the inbox address with a +xyz alias.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="inboxId">Optional inboxId filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllPlusAddressesApiResponse"/>&gt;</returns>
        Task<IGetAllPlusAddressesApiResponse> GetAllPlusAddressesAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all sub address plus address aliases for an inbox
        /// </summary>
        /// <remarks>
        /// Returns paginated list of all plus alias addresses found for in account based on received emails that used the inbox address with a +xyz alias.
        /// </remarks>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="inboxId">Optional inboxId filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllPlusAddressesApiResponse"/>&gt;</returns>
        Task<IGetAllPlusAddressesApiResponse> GetAllPlusAddressesOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all scheduled email sending jobs for account
        /// </summary>
        /// <remarks>
        /// Schedule sending of emails using scheduled jobs. These can be inbox or account level.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllScheduledJobsApiResponse"/>&gt;</returns>
        Task<IGetAllScheduledJobsApiResponse> GetAllScheduledJobsAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all scheduled email sending jobs for account
        /// </summary>
        /// <remarks>
        /// Schedule sending of emails using scheduled jobs. These can be inbox or account level.
        /// </remarks>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllScheduledJobsApiResponse"/>&gt;</returns>
        Task<IGetAllScheduledJobsApiResponse> GetAllScheduledJobsOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get all email delivery statuses for an inbox
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in delivery status list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in delivery status list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDeliveryStatusesByInboxIdApiResponse"/>&gt;</returns>
        [Obsolete]
        Task<IGetDeliveryStatusesByInboxIdApiResponse> GetDeliveryStatusesByInboxIdAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get all email delivery statuses for an inbox
        /// </remarks>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in delivery status list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in delivery status list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDeliveryStatusesByInboxIdApiResponse"/>&gt;</returns>
        [Obsolete]
        Task<IGetDeliveryStatusesByInboxIdApiResponse> GetDeliveryStatusesByInboxIdOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
        /// </summary>
        /// <remarks>
        /// List emails that an inbox has received. Only emails that are sent to the inbox&#39;s email address will appear in the inbox. It may take several seconds for any email you send to an inbox&#39;s email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the &#x60;minCount&#x60; parameter. The server will retry the inbox database until the &#x60;minCount&#x60; is satisfied or the &#x60;retryTimeout&#x60; is reached
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="size">Alias for limit. Assessed first before assessing any passed limit. (optional)</param>
        /// <param name="limit">Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller (optional)</param>
        /// <param name="sort">Sort the results by received date and direction ASC or DESC (optional)</param>
        /// <param name="retryTimeout">Maximum milliseconds to spend retrying inbox database until minCount emails are returned (optional)</param>
        /// <param name="delayTimeout"> (optional)</param>
        /// <param name="minCount">Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached. (optional)</param>
        /// <param name="unreadOnly"> (optional)</param>
        /// <param name="before">Exclude emails received after this ISO 8601 date time (optional)</param>
        /// <param name="since">Exclude emails received before this ISO 8601 date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailsApiResponse"/>&gt;</returns>
        Task<IGetEmailsApiResponse> GetEmailsAsync(Guid inboxId, Option<int> size = default, Option<int> limit = default, Option<string> sort = default, Option<long> retryTimeout = default, Option<long> delayTimeout = default, Option<long> minCount = default, Option<bool> unreadOnly = default, Option<DateTime> before = default, Option<DateTime> since = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
        /// </summary>
        /// <remarks>
        /// List emails that an inbox has received. Only emails that are sent to the inbox&#39;s email address will appear in the inbox. It may take several seconds for any email you send to an inbox&#39;s email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the &#x60;minCount&#x60; parameter. The server will retry the inbox database until the &#x60;minCount&#x60; is satisfied or the &#x60;retryTimeout&#x60; is reached
        /// </remarks>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="size">Alias for limit. Assessed first before assessing any passed limit. (optional)</param>
        /// <param name="limit">Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller (optional)</param>
        /// <param name="sort">Sort the results by received date and direction ASC or DESC (optional)</param>
        /// <param name="retryTimeout">Maximum milliseconds to spend retrying inbox database until minCount emails are returned (optional)</param>
        /// <param name="delayTimeout"> (optional)</param>
        /// <param name="minCount">Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached. (optional)</param>
        /// <param name="unreadOnly"> (optional)</param>
        /// <param name="before">Exclude emails received after this ISO 8601 date time (optional)</param>
        /// <param name="since">Exclude emails received before this ISO 8601 date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailsApiResponse"/>&gt;</returns>
        Task<IGetEmailsApiResponse> GetEmailsOrDefaultAsync(Guid inboxId, Option<int> size = default, Option<int> limit = default, Option<string> sort = default, Option<long> retryTimeout = default, Option<long> delayTimeout = default, Option<long> minCount = default, Option<bool> unreadOnly = default, Option<DateTime> before = default, Option<DateTime> since = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP access usernames and passwords
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapAccessApiResponse"/>&gt;</returns>
        Task<IGetImapAccessApiResponse> GetImapAccessAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP access usernames and passwords
        /// </remarks>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapAccessApiResponse"/>&gt;</returns>
        Task<IGetImapAccessApiResponse> GetImapAccessOrDefaultAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP access usernames and passwords
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapSmtpAccessApiResponse"/>&gt;</returns>
        Task<IGetImapSmtpAccessApiResponse> GetImapSmtpAccessAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP access usernames and passwords
        /// </remarks>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapSmtpAccessApiResponse"/>&gt;</returns>
        Task<IGetImapSmtpAccessApiResponse> GetImapSmtpAccessOrDefaultAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP access details in .env format
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapSmtpAccessEnvApiResponse"/>&gt;</returns>
        Task<IGetImapSmtpAccessEnvApiResponse> GetImapSmtpAccessEnvAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP access details in .env format
        /// </remarks>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapSmtpAccessEnvApiResponse"/>&gt;</returns>
        Task<IGetImapSmtpAccessEnvApiResponse> GetImapSmtpAccessEnvOrDefaultAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP server hosts
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapSmtpAccessServersApiResponse"/>&gt;</returns>
        Task<IGetImapSmtpAccessServersApiResponse> GetImapSmtpAccessServersAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP server hosts
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapSmtpAccessServersApiResponse"/>&gt;</returns>
        Task<IGetImapSmtpAccessServersApiResponse> GetImapSmtpAccessServersOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Inbox. Returns properties of an inbox.
        /// </summary>
        /// <remarks>
        /// Returns an inbox&#39;s properties, including its email address and ID.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxApiResponse"/>&gt;</returns>
        Task<IGetInboxApiResponse> GetInboxAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Inbox. Returns properties of an inbox.
        /// </summary>
        /// <remarks>
        /// Returns an inbox&#39;s properties, including its email address and ID.
        /// </remarks>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxApiResponse"/>&gt;</returns>
        Task<IGetInboxApiResponse> GetInboxOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search for an inbox with the provided email address
        /// </summary>
        /// <remarks>
        /// Get a inbox result by email address
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxByEmailAddressApiResponse"/>&gt;</returns>
        Task<IGetInboxByEmailAddressApiResponse> GetInboxByEmailAddressAsync(string emailAddress, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search for an inbox with the provided email address
        /// </summary>
        /// <remarks>
        /// Get a inbox result by email address
        /// </remarks>
        /// <param name="emailAddress"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxByEmailAddressApiResponse"/>&gt;</returns>
        Task<IGetInboxByEmailAddressApiResponse> GetInboxByEmailAddressOrDefaultAsync(string emailAddress, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search for an inbox with the given name
        /// </summary>
        /// <remarks>
        /// Get a inbox result by name
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxByNameApiResponse"/>&gt;</returns>
        Task<IGetInboxByNameApiResponse> GetInboxByNameAsync(string name, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search for an inbox with the given name
        /// </summary>
        /// <remarks>
        /// Get a inbox result by name
        /// </remarks>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxByNameApiResponse"/>&gt;</returns>
        Task<IGetInboxByNameApiResponse> GetInboxByNameOrDefaultAsync(string name, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get total inbox count
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxCountApiResponse"/>&gt;</returns>
        Task<IGetInboxCountApiResponse> GetInboxCountAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get total inbox count
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxCountApiResponse"/>&gt;</returns>
        Task<IGetInboxCountApiResponse> GetInboxCountOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email count in inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxEmailCountApiResponse"/>&gt;</returns>
        Task<IGetInboxEmailCountApiResponse> GetInboxEmailCountAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email count in inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxEmailCountApiResponse"/>&gt;</returns>
        Task<IGetInboxEmailCountApiResponse> GetInboxEmailCountOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get inbox emails paginated
        /// </summary>
        /// <remarks>
        /// Get a paginated list of emails in an inbox. Does not hold connections open.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="page">Optional page index in inbox emails list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox emails list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by received after given date time (optional)</param>
        /// <param name="before">Optional filter by received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors before fetching emails (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxEmailsPaginatedApiResponse"/>&gt;</returns>
        Task<IGetInboxEmailsPaginatedApiResponse> GetInboxEmailsPaginatedAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> syncConnectors = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get inbox emails paginated
        /// </summary>
        /// <remarks>
        /// Get a paginated list of emails in an inbox. Does not hold connections open.
        /// </remarks>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="page">Optional page index in inbox emails list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox emails list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by received after given date time (optional)</param>
        /// <param name="before">Optional filter by received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors before fetching emails (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxEmailsPaginatedApiResponse"/>&gt;</returns>
        Task<IGetInboxEmailsPaginatedApiResponse> GetInboxEmailsPaginatedOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> syncConnectors = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all inbox IDs
        /// </summary>
        /// <remarks>
        /// Get list of inbox IDs
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxIdsApiResponse"/>&gt;</returns>
        [Obsolete]
        Task<IGetInboxIdsApiResponse> GetInboxIdsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all inbox IDs
        /// </summary>
        /// <remarks>
        /// Get list of inbox IDs
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxIdsApiResponse"/>&gt;</returns>
        [Obsolete]
        Task<IGetInboxIdsApiResponse> GetInboxIdsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get sub address plus address for an inbox
        /// </summary>
        /// <remarks>
        /// Returns a plus address object based on emails that used the inbox address with a +xyz alias.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="plusAddressId">ID of the plus address you want to fetch</param>
        /// <param name="inboxId">ID of the inbox you want to fetch</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressApiResponse"/>&gt;</returns>
        Task<IGetInboxPlusAddressApiResponse> GetInboxPlusAddressAsync(Guid plusAddressId, Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get sub address plus address for an inbox
        /// </summary>
        /// <remarks>
        /// Returns a plus address object based on emails that used the inbox address with a +xyz alias.
        /// </remarks>
        /// <param name="plusAddressId">ID of the plus address you want to fetch</param>
        /// <param name="inboxId">ID of the inbox you want to fetch</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressApiResponse"/>&gt;</returns>
        Task<IGetInboxPlusAddressApiResponse> GetInboxPlusAddressOrDefaultAsync(Guid plusAddressId, Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get sub address plus address by ID
        /// </summary>
        /// <remarks>
        /// Returns a plus address object based on emails that used the inbox address with a +xyz alias.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="plusAddressId">ID of the plus address you want to fetch</param>
        /// <param name="inboxId">ID of the inbox you want to filter for (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressByIdApiResponse"/>&gt;</returns>
        Task<IGetInboxPlusAddressByIdApiResponse> GetInboxPlusAddressByIdAsync(Guid plusAddressId, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get sub address plus address by ID
        /// </summary>
        /// <remarks>
        /// Returns a plus address object based on emails that used the inbox address with a +xyz alias.
        /// </remarks>
        /// <param name="plusAddressId">ID of the plus address you want to fetch</param>
        /// <param name="inboxId">ID of the inbox you want to filter for (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressByIdApiResponse"/>&gt;</returns>
        Task<IGetInboxPlusAddressByIdApiResponse> GetInboxPlusAddressByIdOrDefaultAsync(Guid plusAddressId, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get emails for a given inbox plus address
        /// </summary>
        /// <remarks>
        /// Returns paginated list of all emails for a given plus alias addresses found for an inbox based on received emails that used the inbox address with a +xyz alias.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="plusAddress">The plus address to fetch emails for. If your inbox address is &#x60;123@test.com&#x60; and the email was sent to &#x60;123+abc@test.com&#x60; then the plus address is &#x60;abc&#x60;</param>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressEmailsApiResponse"/>&gt;</returns>
        Task<IGetInboxPlusAddressEmailsApiResponse> GetInboxPlusAddressEmailsAsync(string plusAddress, Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get emails for a given inbox plus address
        /// </summary>
        /// <remarks>
        /// Returns paginated list of all emails for a given plus alias addresses found for an inbox based on received emails that used the inbox address with a +xyz alias.
        /// </remarks>
        /// <param name="plusAddress">The plus address to fetch emails for. If your inbox address is &#x60;123@test.com&#x60; and the email was sent to &#x60;123+abc@test.com&#x60; then the plus address is &#x60;abc&#x60;</param>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressEmailsApiResponse"/>&gt;</returns>
        Task<IGetInboxPlusAddressEmailsApiResponse> GetInboxPlusAddressEmailsOrDefaultAsync(string plusAddress, Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get emails for a given inbox plus address
        /// </summary>
        /// <remarks>
        /// Returns paginated list of all emails for a given plus alias addresses found for an inbox based on received emails that used the inbox address with a +xyz alias.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="plusAddressId">The plus address ID to fetch emails for.</param>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse"/>&gt;</returns>
        Task<IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse> GetInboxPlusAddressEmailsForPlusAddressIdAsync(Guid plusAddressId, Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get emails for a given inbox plus address
        /// </summary>
        /// <remarks>
        /// Returns paginated list of all emails for a given plus alias addresses found for an inbox based on received emails that used the inbox address with a +xyz alias.
        /// </remarks>
        /// <param name="plusAddressId">The plus address ID to fetch emails for.</param>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse"/>&gt;</returns>
        Task<IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse> GetInboxPlusAddressEmailsForPlusAddressIdOrDefaultAsync(Guid plusAddressId, Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get sub address plus address aliases for an inbox
        /// </summary>
        /// <remarks>
        /// Returns paginated list of all plus alias addresses found for an inbox based on received emails that used the inbox address with a +xyz alias.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressesApiResponse"/>&gt;</returns>
        Task<IGetInboxPlusAddressesApiResponse> GetInboxPlusAddressesAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get sub address plus address aliases for an inbox
        /// </summary>
        /// <remarks>
        /// Returns paginated list of all plus alias addresses found for an inbox based on received emails that used the inbox address with a +xyz alias.
        /// </remarks>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressesApiResponse"/>&gt;</returns>
        Task<IGetInboxPlusAddressesApiResponse> GetInboxPlusAddressesOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get sent email count in inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails were sent from</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxSentCountApiResponse"/>&gt;</returns>
        Task<IGetInboxSentCountApiResponse> GetInboxSentCountAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get sent email count in inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="inboxId">Id of inbox that emails were sent from</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxSentCountApiResponse"/>&gt;</returns>
        Task<IGetInboxSentCountApiResponse> GetInboxSentCountOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Inbox Sent Emails
        /// </summary>
        /// <remarks>
        /// Returns an inbox&#39;s sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional sent email search (optional)</param>
        /// <param name="since">Optional filter by sent after given date time (optional)</param>
        /// <param name="before">Optional filter by sent before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxSentEmailsApiResponse"/>&gt;</returns>
        [Obsolete]
        Task<IGetInboxSentEmailsApiResponse> GetInboxSentEmailsAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Inbox Sent Emails
        /// </summary>
        /// <remarks>
        /// Returns an inbox&#39;s sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
        /// </remarks>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional sent email search (optional)</param>
        /// <param name="since">Optional filter by sent after given date time (optional)</param>
        /// <param name="before">Optional filter by sent before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxSentEmailsApiResponse"/>&gt;</returns>
        [Obsolete]
        Task<IGetInboxSentEmailsApiResponse> GetInboxSentEmailsOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get inbox tags
        /// </summary>
        /// <remarks>
        /// Get all inbox tags
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxTagsApiResponse"/>&gt;</returns>
        Task<IGetInboxTagsApiResponse> GetInboxTagsAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get inbox tags
        /// </summary>
        /// <remarks>
        /// Get all inbox tags
        /// </remarks>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxTagsApiResponse"/>&gt;</returns>
        Task<IGetInboxTagsApiResponse> GetInboxTagsOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get inbox tags paginated
        /// </summary>
        /// <remarks>
        /// Get all inbox tags paginated
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxTagsPaginatedApiResponse"/>&gt;</returns>
        Task<IGetInboxTagsPaginatedApiResponse> GetInboxTagsPaginatedAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get inbox tags paginated
        /// </summary>
        /// <remarks>
        /// Get all inbox tags paginated
        /// </remarks>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxTagsPaginatedApiResponse"/>&gt;</returns>
        Task<IGetInboxTagsPaginatedApiResponse> GetInboxTagsPaginatedOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Inboxes and email addresses
        /// </summary>
        /// <remarks>
        /// List the inboxes you have created. Note use of the more advanced &#x60;getAllInboxes&#x60; is recommended and allows paginated access using a limit and sort parameter.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries. (optional, default to 100)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="excludeCatchAllInboxes">Optional exclude catch all inboxes (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="include">Optional inboxIds to include in result (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxesApiResponse"/>&gt;</returns>
        [Obsolete]
        Task<IGetInboxesApiResponse> GetInboxesAsync(Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<bool> excludeCatchAllInboxes = default, Option<DateTime> before = default, Option<List<Guid>> include = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Inboxes and email addresses
        /// </summary>
        /// <remarks>
        /// List the inboxes you have created. Note use of the more advanced &#x60;getAllInboxes&#x60; is recommended and allows paginated access using a limit and sort parameter.
        /// </remarks>
        /// <param name="size">Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries. (optional, default to 100)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="excludeCatchAllInboxes">Optional exclude catch all inboxes (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="include">Optional inboxIds to include in result (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxesApiResponse"/>&gt;</returns>
        [Obsolete]
        Task<IGetInboxesApiResponse> GetInboxesOrDefaultAsync(Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<bool> excludeCatchAllInboxes = default, Option<DateTime> before = default, Option<List<Guid>> include = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get inboxes for a tag
        /// </summary>
        /// <remarks>
        /// Get all inboxes for a given inbox tag
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">Tag to filter by</param>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxesByTagApiResponse"/>&gt;</returns>
        Task<IGetInboxesByTagApiResponse> GetInboxesByTagAsync(string tag, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get inboxes for a tag
        /// </summary>
        /// <remarks>
        /// Get all inboxes for a given inbox tag
        /// </remarks>
        /// <param name="tag">Tag to filter by</param>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxesByTagApiResponse"/>&gt;</returns>
        Task<IGetInboxesByTagApiResponse> GetInboxesByTagOrDefaultAsync(string tag, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.
        /// </summary>
        /// <remarks>
        /// Get the newest email in an inbox or wait for one to arrive
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="timeoutMillis">Timeout milliseconds to wait for latest email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestEmailInInboxApiResponse"/>&gt;</returns>
        Task<IGetLatestEmailInInboxApiResponse> GetLatestEmailInInboxAsync(Guid inboxId, long timeoutMillis, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.
        /// </summary>
        /// <remarks>
        /// Get the newest email in an inbox or wait for one to arrive
        /// </remarks>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="timeoutMillis">Timeout milliseconds to wait for latest email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestEmailInInboxApiResponse"/>&gt;</returns>
        Task<IGetLatestEmailInInboxApiResponse> GetLatestEmailInInboxOrDefaultAsync(Guid inboxId, long timeoutMillis, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Organization Inboxes Paginated
        /// </summary>
        /// <remarks>
        /// List organization inboxes in paginated form. These are inboxes created with &#x60;allowTeamAccess&#x60; flag enabled. Organization inboxes are &#x60;readOnly&#x60; for non-admin users. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOrganizationInboxesApiResponse"/>&gt;</returns>
        [Obsolete]
        Task<IGetOrganizationInboxesApiResponse> GetOrganizationInboxesAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Organization Inboxes Paginated
        /// </summary>
        /// <remarks>
        /// List organization inboxes in paginated form. These are inboxes created with &#x60;allowTeamAccess&#x60; flag enabled. Organization inboxes are &#x60;readOnly&#x60; for non-admin users. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). 
        /// </remarks>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOrganizationInboxesApiResponse"/>&gt;</returns>
        [Obsolete]
        Task<IGetOrganizationInboxesApiResponse> GetOrganizationInboxesOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all inboxes with sent emails
        /// </summary>
        /// <remarks>
        /// List inboxes that have sent emails
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOutboxesApiResponse"/>&gt;</returns>
        Task<IGetOutboxesApiResponse> GetOutboxesAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all inboxes with sent emails
        /// </summary>
        /// <remarks>
        /// List inboxes that have sent emails
        /// </remarks>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOutboxesApiResponse"/>&gt;</returns>
        Task<IGetOutboxesApiResponse> GetOutboxesOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a scheduled email job
        /// </summary>
        /// <remarks>
        /// Get a scheduled email job details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetScheduledJobApiResponse"/>&gt;</returns>
        Task<IGetScheduledJobApiResponse> GetScheduledJobAsync(Guid jobId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a scheduled email job
        /// </summary>
        /// <remarks>
        /// Get a scheduled email job details.
        /// </remarks>
        /// <param name="jobId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetScheduledJobApiResponse"/>&gt;</returns>
        Task<IGetScheduledJobApiResponse> GetScheduledJobOrDefaultAsync(Guid jobId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all scheduled email sending jobs for the inbox
        /// </summary>
        /// <remarks>
        /// Schedule sending of emails using scheduled jobs.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetScheduledJobsByInboxIdApiResponse"/>&gt;</returns>
        Task<IGetScheduledJobsByInboxIdApiResponse> GetScheduledJobsByInboxIdAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all scheduled email sending jobs for the inbox
        /// </summary>
        /// <remarks>
        /// Schedule sending of emails using scheduled jobs.
        /// </remarks>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetScheduledJobsByInboxIdApiResponse"/>&gt;</returns>
        Task<IGetScheduledJobsByInboxIdApiResponse> GetScheduledJobsByInboxIdOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get SMTP access usernames and passwords
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpAccessApiResponse"/>&gt;</returns>
        Task<IGetSmtpAccessApiResponse> GetSmtpAccessAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get SMTP access usernames and passwords
        /// </remarks>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpAccessApiResponse"/>&gt;</returns>
        Task<IGetSmtpAccessApiResponse> GetSmtpAccessOrDefaultAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Is email address available
        /// </summary>
        /// <remarks>
        /// Returns whether an email address is available
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IIsEmailAddressAvailableApiResponse"/>&gt;</returns>
        Task<IIsEmailAddressAvailableApiResponse> IsEmailAddressAvailableAsync(string emailAddress, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Is email address available
        /// </summary>
        /// <remarks>
        /// Returns whether an email address is available
        /// </remarks>
        /// <param name="emailAddress"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IIsEmailAddressAvailableApiResponse"/>&gt;</returns>
        Task<IIsEmailAddressAvailableApiResponse> IsEmailAddressAvailableOrDefaultAsync(string emailAddress, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List inbox rulesets
        /// </summary>
        /// <remarks>
        /// List all rulesets attached to an inbox
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox ruleset list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox ruleset list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListInboxRulesetsApiResponse"/>&gt;</returns>
        Task<IListInboxRulesetsApiResponse> ListInboxRulesetsAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List inbox rulesets
        /// </summary>
        /// <remarks>
        /// List all rulesets attached to an inbox
        /// </remarks>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox ruleset list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox ruleset list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListInboxRulesetsApiResponse"/>&gt;</returns>
        Task<IListInboxRulesetsApiResponse> ListInboxRulesetsOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List inbox tracking pixels
        /// </summary>
        /// <remarks>
        /// List all tracking pixels sent from an inbox
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListInboxTrackingPixelsApiResponse"/>&gt;</returns>
        Task<IListInboxTrackingPixelsApiResponse> ListInboxTrackingPixelsAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List inbox tracking pixels
        /// </summary>
        /// <remarks>
        /// List all tracking pixels sent from an inbox
        /// </remarks>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListInboxTrackingPixelsApiResponse"/>&gt;</returns>
        Task<IListInboxTrackingPixelsApiResponse> ListInboxTrackingPixelsOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search all inboxes and return matching inboxes
        /// </summary>
        /// <remarks>
        /// Search inboxes and return in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchInboxesOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchInboxesApiResponse"/>&gt;</returns>
        Task<ISearchInboxesApiResponse> SearchInboxesAsync(SearchInboxesOptions searchInboxesOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search all inboxes and return matching inboxes
        /// </summary>
        /// <remarks>
        /// Search inboxes and return in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <param name="searchInboxesOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchInboxesApiResponse"/>&gt;</returns>
        Task<ISearchInboxesApiResponse> SearchInboxesOrDefaultAsync(SearchInboxesOptions searchInboxesOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send Email
        /// </summary>
        /// <remarks>
        /// Send an email from an inbox&#39;s email address.  The request body should contain the &#x60;SendEmailOptions&#x60; that include recipients, attachments, body etc. See &#x60;SendEmailOptions&#x60; for all available properties. Note the &#x60;inboxId&#x60; refers to the inbox&#39;s id not the inbox&#39;s email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method &#x60;sendEmailAndConfirm&#x60;.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailApiResponse"/>&gt;</returns>
        Task<ISendEmailApiResponse> SendEmailAsync(Guid inboxId, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send Email
        /// </summary>
        /// <remarks>
        /// Send an email from an inbox&#39;s email address.  The request body should contain the &#x60;SendEmailOptions&#x60; that include recipients, attachments, body etc. See &#x60;SendEmailOptions&#x60; for all available properties. Note the &#x60;inboxId&#x60; refers to the inbox&#39;s id not the inbox&#39;s email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method &#x60;sendEmailAndConfirm&#x60;.
        /// </remarks>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailApiResponse"/>&gt;</returns>
        Task<ISendEmailApiResponse> SendEmailOrDefaultAsync(Guid inboxId, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send email and return sent confirmation
        /// </summary>
        /// <remarks>
        /// Sister method for standard &#x60;sendEmail&#x60; method with the benefit of returning a &#x60;SentEmail&#x60; entity confirming the successful sending of the email with a link to the sent object created for it.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailAndConfirmApiResponse"/>&gt;</returns>
        Task<ISendEmailAndConfirmApiResponse> SendEmailAndConfirmAsync(Guid inboxId, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send email and return sent confirmation
        /// </summary>
        /// <remarks>
        /// Sister method for standard &#x60;sendEmail&#x60; method with the benefit of returning a &#x60;SentEmail&#x60; entity confirming the successful sending of the email with a link to the sent object created for it.
        /// </remarks>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailAndConfirmApiResponse"/>&gt;</returns>
        Task<ISendEmailAndConfirmApiResponse> SendEmailAndConfirmOrDefaultAsync(Guid inboxId, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send email with queue
        /// </summary>
        /// <remarks>
        /// Send an email using a queue. Will place the email onto a queue that will then be processed and sent. Use this queue method to enable any failed email sending to be recovered. This will prevent lost emails when sending if your account encounters a block or payment issue.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailWithQueueApiResponse"/>&gt;</returns>
        Task<ISendEmailWithQueueApiResponse> SendEmailWithQueueAsync(Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send email with queue
        /// </summary>
        /// <remarks>
        /// Send an email using a queue. Will place the email onto a queue that will then be processed and sent. Use this queue method to enable any failed email sending to be recovered. This will prevent lost emails when sending if your account encounters a block or payment issue.
        /// </remarks>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailWithQueueApiResponse"/>&gt;</returns>
        Task<ISendEmailWithQueueApiResponse> SendEmailWithQueueOrDefaultAsync(Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send email using an SMTP mail envelope and message body and return sent confirmation
        /// </summary>
        /// <remarks>
        /// Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendSmtpEnvelopeApiResponse"/>&gt;</returns>
        Task<ISendSmtpEnvelopeApiResponse> SendSmtpEnvelopeAsync(Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send email using an SMTP mail envelope and message body and return sent confirmation
        /// </summary>
        /// <remarks>
        /// Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.
        /// </remarks>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendSmtpEnvelopeApiResponse"/>&gt;</returns>
        Task<ISendSmtpEnvelopeApiResponse> SendSmtpEnvelopeOrDefaultAsync(Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send a test email to inbox
        /// </summary>
        /// <remarks>
        /// Send an inbox a test email to test email receiving is working
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTestEmailApiResponse"/>&gt;</returns>
        Task<ISendTestEmailApiResponse> SendTestEmailAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send a test email to inbox
        /// </summary>
        /// <remarks>
        /// Send an inbox a test email to test email receiving is working
        /// </remarks>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTestEmailApiResponse"/>&gt;</returns>
        Task<ISendTestEmailApiResponse> SendTestEmailOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send email with with delay or schedule
        /// </summary>
        /// <remarks>
        /// Send an email using a delay. Will place the email onto a scheduler that will then be processed and sent. Use delays to schedule email sending.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp">Sending timestamp (optional)</param>
        /// <param name="sendAtNowPlusSeconds">Send after n seconds (optional)</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendWithScheduleApiResponse"/>&gt;</returns>
        Task<ISendWithScheduleApiResponse> SendWithScheduleAsync(Guid inboxId, SendEmailOptions sendEmailOptions, Option<DateTime> sendAtTimestamp = default, Option<long> sendAtNowPlusSeconds = default, Option<bool> validateBeforeEnqueue = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send email with with delay or schedule
        /// </summary>
        /// <remarks>
        /// Send an email using a delay. Will place the email onto a scheduler that will then be processed and sent. Use delays to schedule email sending.
        /// </remarks>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp">Sending timestamp (optional)</param>
        /// <param name="sendAtNowPlusSeconds">Send after n seconds (optional)</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendWithScheduleApiResponse"/>&gt;</returns>
        Task<ISendWithScheduleApiResponse> SendWithScheduleOrDefaultAsync(Guid inboxId, SendEmailOptions sendEmailOptions, Option<DateTime> sendAtTimestamp = default, Option<long> sendAtNowPlusSeconds = default, Option<bool> validateBeforeEnqueue = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set inbox favourited state
        /// </summary>
        /// <remarks>
        /// Set and return new favorite state for an inbox
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to set favourite state</param>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetInboxFavouritedApiResponse"/>&gt;</returns>
        Task<ISetInboxFavouritedApiResponse> SetInboxFavouritedAsync(Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set inbox favourited state
        /// </summary>
        /// <remarks>
        /// Set and return new favorite state for an inbox
        /// </remarks>
        /// <param name="inboxId">ID of inbox to set favourite state</param>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetInboxFavouritedApiResponse"/>&gt;</returns>
        Task<ISetInboxFavouritedApiResponse> SetInboxFavouritedOrDefaultAsync(Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Update IMAP access usernames and passwords
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateImapAccessOptions"></param>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateImapAccessApiResponse"/>&gt;</returns>
        Task<IUpdateImapAccessApiResponse> UpdateImapAccessAsync(UpdateImapAccessOptions updateImapAccessOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Update IMAP access usernames and passwords
        /// </remarks>
        /// <param name="updateImapAccessOptions"></param>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateImapAccessApiResponse"/>&gt;</returns>
        Task<IUpdateImapAccessApiResponse> UpdateImapAccessOrDefaultAsync(UpdateImapAccessOptions updateImapAccessOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Inbox. Change name and description. Email address is not editable.
        /// </summary>
        /// <remarks>
        /// Update editable fields on an inbox
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateInboxApiResponse"/>&gt;</returns>
        Task<IUpdateInboxApiResponse> UpdateInboxAsync(Guid inboxId, UpdateInboxOptions updateInboxOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Inbox. Change name and description. Email address is not editable.
        /// </summary>
        /// <remarks>
        /// Update editable fields on an inbox
        /// </remarks>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateInboxApiResponse"/>&gt;</returns>
        Task<IUpdateInboxApiResponse> UpdateInboxOrDefaultAsync(Guid inboxId, UpdateInboxOptions updateInboxOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Update SMTP access usernames and passwords
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateSmtpAccessOptions"></param>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateSmtpAccessApiResponse"/>&gt;</returns>
        Task<IUpdateSmtpAccessApiResponse> UpdateSmtpAccessAsync(UpdateSmtpAccessOptions updateSmtpAccessOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Update SMTP access usernames and passwords
        /// </remarks>
        /// <param name="updateSmtpAccessOptions"></param>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateSmtpAccessApiResponse"/>&gt;</returns>
        Task<IUpdateSmtpAccessApiResponse> UpdateSmtpAccessOrDefaultAsync(UpdateSmtpAccessOptions updateSmtpAccessOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICancelScheduledJobApiResponse"/>
    /// </summary>
    public interface ICancelScheduledJobApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ScheduledJobDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateInboxApiResponse"/>
    /// </summary>
    public interface ICreateInboxApiResponse : mailslurp.Client.IApiResponse, ICreated<mailslurp.Model.InboxDto>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ICreateInboxRulesetApiResponse"/>
    /// </summary>
    public interface ICreateInboxRulesetApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.InboxRulesetDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateInboxWithDefaultsApiResponse"/>
    /// </summary>
    public interface ICreateInboxWithDefaultsApiResponse : mailslurp.Client.IApiResponse, ICreated<mailslurp.Model.InboxDto>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ICreateInboxWithOptionsApiResponse"/>
    /// </summary>
    public interface ICreateInboxWithOptionsApiResponse : mailslurp.Client.IApiResponse, ICreated<mailslurp.Model.InboxDto>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteAllInboxEmailsApiResponse"/>
    /// </summary>
    public interface IDeleteAllInboxEmailsApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteAllInboxesApiResponse"/>
    /// </summary>
    public interface IDeleteAllInboxesApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteAllInboxesByDescriptionApiResponse"/>
    /// </summary>
    public interface IDeleteAllInboxesByDescriptionApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteAllInboxesByNameApiResponse"/>
    /// </summary>
    public interface IDeleteAllInboxesByNameApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteAllInboxesByTagApiResponse"/>
    /// </summary>
    public interface IDeleteAllInboxesByTagApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteInboxApiResponse"/>
    /// </summary>
    public interface IDeleteInboxApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IDoesInboxExistApiResponse"/>
    /// </summary>
    public interface IDoesInboxExistApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.InboxExistsDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDoesInboxHaveAutomationsApiResponse"/>
    /// </summary>
    public interface IDoesInboxHaveAutomationsApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IFlushExpiredApiResponse"/>
    /// </summary>
    public interface IFlushExpiredApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.FlushExpiredInboxesResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetAllInboxesApiResponse"/>
    /// </summary>
    public interface IGetAllInboxesApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageInboxProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetAllInboxesOffsetPaginatedApiResponse"/>
    /// </summary>
    public interface IGetAllInboxesOffsetPaginatedApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageInboxProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetAllPlusAddressesApiResponse"/>
    /// </summary>
    public interface IGetAllPlusAddressesApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PagePlusAddressProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetAllScheduledJobsApiResponse"/>
    /// </summary>
    public interface IGetAllScheduledJobsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageScheduledJobs>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetDeliveryStatusesByInboxIdApiResponse"/>
    /// </summary>
    public interface IGetDeliveryStatusesByInboxIdApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageDeliveryStatus>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailsApiResponse"/>
    /// </summary>
    public interface IGetEmailsApiResponse : mailslurp.Client.IApiResponse, IOk<List<EmailPreview>>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetImapAccessApiResponse"/>
    /// </summary>
    public interface IGetImapAccessApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ImapAccessDetails>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetImapSmtpAccessApiResponse"/>
    /// </summary>
    public interface IGetImapSmtpAccessApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ImapSmtpAccessDetails>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetImapSmtpAccessEnvApiResponse"/>
    /// </summary>
    public interface IGetImapSmtpAccessEnvApiResponse : mailslurp.Client.IApiResponse, IOk<string>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetImapSmtpAccessServersApiResponse"/>
    /// </summary>
    public interface IGetImapSmtpAccessServersApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ImapSmtpAccessServers>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxApiResponse"/>
    /// </summary>
    public interface IGetInboxApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.InboxDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxByEmailAddressApiResponse"/>
    /// </summary>
    public interface IGetInboxByEmailAddressApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.InboxByEmailAddressResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxByNameApiResponse"/>
    /// </summary>
    public interface IGetInboxByNameApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.InboxByNameResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxCountApiResponse"/>
    /// </summary>
    public interface IGetInboxCountApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.CountDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxEmailCountApiResponse"/>
    /// </summary>
    public interface IGetInboxEmailCountApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.CountDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxEmailsPaginatedApiResponse"/>
    /// </summary>
    public interface IGetInboxEmailsPaginatedApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageEmailPreview>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxIdsApiResponse"/>
    /// </summary>
    public interface IGetInboxIdsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.InboxIdsResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxPlusAddressApiResponse"/>
    /// </summary>
    public interface IGetInboxPlusAddressApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PlusAddressDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxPlusAddressByIdApiResponse"/>
    /// </summary>
    public interface IGetInboxPlusAddressByIdApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PlusAddressDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxPlusAddressEmailsApiResponse"/>
    /// </summary>
    public interface IGetInboxPlusAddressEmailsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageEmailPreview>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse"/>
    /// </summary>
    public interface IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageEmailPreview>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxPlusAddressesApiResponse"/>
    /// </summary>
    public interface IGetInboxPlusAddressesApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PagePlusAddressProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxSentCountApiResponse"/>
    /// </summary>
    public interface IGetInboxSentCountApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.CountDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxSentEmailsApiResponse"/>
    /// </summary>
    public interface IGetInboxSentEmailsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageSentEmailProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxTagsApiResponse"/>
    /// </summary>
    public interface IGetInboxTagsApiResponse : mailslurp.Client.IApiResponse, IOk<List<string>>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxTagsPaginatedApiResponse"/>
    /// </summary>
    public interface IGetInboxTagsPaginatedApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageInboxTags>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxesApiResponse"/>
    /// </summary>
    public interface IGetInboxesApiResponse : mailslurp.Client.IApiResponse, IOk<List<InboxDto>>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetInboxesByTagApiResponse"/>
    /// </summary>
    public interface IGetInboxesByTagApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageInboxProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetLatestEmailInInboxApiResponse"/>
    /// </summary>
    public interface IGetLatestEmailInInboxApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.Email>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetOrganizationInboxesApiResponse"/>
    /// </summary>
    public interface IGetOrganizationInboxesApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageOrganizationInboxProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetOutboxesApiResponse"/>
    /// </summary>
    public interface IGetOutboxesApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageInboxProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetScheduledJobApiResponse"/>
    /// </summary>
    public interface IGetScheduledJobApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ScheduledJobDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetScheduledJobsByInboxIdApiResponse"/>
    /// </summary>
    public interface IGetScheduledJobsByInboxIdApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageScheduledJobs>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetSmtpAccessApiResponse"/>
    /// </summary>
    public interface IGetSmtpAccessApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.SmtpAccessDetails>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IIsEmailAddressAvailableApiResponse"/>
    /// </summary>
    public interface IIsEmailAddressAvailableApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailAvailableResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListInboxRulesetsApiResponse"/>
    /// </summary>
    public interface IListInboxRulesetsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageInboxRulesetDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListInboxTrackingPixelsApiResponse"/>
    /// </summary>
    public interface IListInboxTrackingPixelsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageTrackingPixelProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchInboxesApiResponse"/>
    /// </summary>
    public interface ISearchInboxesApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageInboxProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISendEmailApiResponse"/>
    /// </summary>
    public interface ISendEmailApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ISendEmailAndConfirmApiResponse"/>
    /// </summary>
    public interface ISendEmailAndConfirmApiResponse : mailslurp.Client.IApiResponse, ICreated<mailslurp.Model.SentEmailDto>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ISendEmailWithQueueApiResponse"/>
    /// </summary>
    public interface ISendEmailWithQueueApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ISendSmtpEnvelopeApiResponse"/>
    /// </summary>
    public interface ISendSmtpEnvelopeApiResponse : mailslurp.Client.IApiResponse, ICreated<mailslurp.Model.SentEmailDto>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ISendTestEmailApiResponse"/>
    /// </summary>
    public interface ISendTestEmailApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="ISendWithScheduleApiResponse"/>
    /// </summary>
    public interface ISendWithScheduleApiResponse : mailslurp.Client.IApiResponse, ICreated<mailslurp.Model.ScheduledJobDto>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ISetInboxFavouritedApiResponse"/>
    /// </summary>
    public interface ISetInboxFavouritedApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.InboxDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateImapAccessApiResponse"/>
    /// </summary>
    public interface IUpdateImapAccessApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateInboxApiResponse"/>
    /// </summary>
    public interface IUpdateInboxApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.InboxDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateSmtpAccessApiResponse"/>
    /// </summary>
    public interface IUpdateSmtpAccessApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class InboxControllerApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnCancelScheduledJob;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorCancelScheduledJob;

        internal void ExecuteOnCancelScheduledJob(InboxControllerApi.CancelScheduledJobApiResponse apiResponse)
        {
            OnCancelScheduledJob?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCancelScheduledJob(Exception exception)
        {
            OnErrorCancelScheduledJob?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnCreateInbox;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorCreateInbox;

        internal void ExecuteOnCreateInbox(InboxControllerApi.CreateInboxApiResponse apiResponse)
        {
            OnCreateInbox?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateInbox(Exception exception)
        {
            OnErrorCreateInbox?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnCreateInboxRuleset;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorCreateInboxRuleset;

        internal void ExecuteOnCreateInboxRuleset(InboxControllerApi.CreateInboxRulesetApiResponse apiResponse)
        {
            OnCreateInboxRuleset?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateInboxRuleset(Exception exception)
        {
            OnErrorCreateInboxRuleset?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnCreateInboxWithDefaults;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorCreateInboxWithDefaults;

        internal void ExecuteOnCreateInboxWithDefaults(InboxControllerApi.CreateInboxWithDefaultsApiResponse apiResponse)
        {
            OnCreateInboxWithDefaults?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateInboxWithDefaults(Exception exception)
        {
            OnErrorCreateInboxWithDefaults?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnCreateInboxWithOptions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorCreateInboxWithOptions;

        internal void ExecuteOnCreateInboxWithOptions(InboxControllerApi.CreateInboxWithOptionsApiResponse apiResponse)
        {
            OnCreateInboxWithOptions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateInboxWithOptions(Exception exception)
        {
            OnErrorCreateInboxWithOptions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteAllInboxEmails;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteAllInboxEmails;

        internal void ExecuteOnDeleteAllInboxEmails(InboxControllerApi.DeleteAllInboxEmailsApiResponse apiResponse)
        {
            OnDeleteAllInboxEmails?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteAllInboxEmails(Exception exception)
        {
            OnErrorDeleteAllInboxEmails?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteAllInboxes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteAllInboxes;

        internal void ExecuteOnDeleteAllInboxes(InboxControllerApi.DeleteAllInboxesApiResponse apiResponse)
        {
            OnDeleteAllInboxes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteAllInboxes(Exception exception)
        {
            OnErrorDeleteAllInboxes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteAllInboxesByDescription;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteAllInboxesByDescription;

        internal void ExecuteOnDeleteAllInboxesByDescription(InboxControllerApi.DeleteAllInboxesByDescriptionApiResponse apiResponse)
        {
            OnDeleteAllInboxesByDescription?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteAllInboxesByDescription(Exception exception)
        {
            OnErrorDeleteAllInboxesByDescription?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteAllInboxesByName;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteAllInboxesByName;

        internal void ExecuteOnDeleteAllInboxesByName(InboxControllerApi.DeleteAllInboxesByNameApiResponse apiResponse)
        {
            OnDeleteAllInboxesByName?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteAllInboxesByName(Exception exception)
        {
            OnErrorDeleteAllInboxesByName?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteAllInboxesByTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteAllInboxesByTag;

        internal void ExecuteOnDeleteAllInboxesByTag(InboxControllerApi.DeleteAllInboxesByTagApiResponse apiResponse)
        {
            OnDeleteAllInboxesByTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteAllInboxesByTag(Exception exception)
        {
            OnErrorDeleteAllInboxesByTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteInbox;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteInbox;

        internal void ExecuteOnDeleteInbox(InboxControllerApi.DeleteInboxApiResponse apiResponse)
        {
            OnDeleteInbox?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteInbox(Exception exception)
        {
            OnErrorDeleteInbox?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDoesInboxExist;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDoesInboxExist;

        internal void ExecuteOnDoesInboxExist(InboxControllerApi.DoesInboxExistApiResponse apiResponse)
        {
            OnDoesInboxExist?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDoesInboxExist(Exception exception)
        {
            OnErrorDoesInboxExist?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDoesInboxHaveAutomations;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDoesInboxHaveAutomations;

        internal void ExecuteOnDoesInboxHaveAutomations(InboxControllerApi.DoesInboxHaveAutomationsApiResponse apiResponse)
        {
            OnDoesInboxHaveAutomations?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDoesInboxHaveAutomations(Exception exception)
        {
            OnErrorDoesInboxHaveAutomations?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnFlushExpired;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorFlushExpired;

        internal void ExecuteOnFlushExpired(InboxControllerApi.FlushExpiredApiResponse apiResponse)
        {
            OnFlushExpired?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFlushExpired(Exception exception)
        {
            OnErrorFlushExpired?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetAllInboxes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetAllInboxes;

        internal void ExecuteOnGetAllInboxes(InboxControllerApi.GetAllInboxesApiResponse apiResponse)
        {
            OnGetAllInboxes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAllInboxes(Exception exception)
        {
            OnErrorGetAllInboxes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetAllInboxesOffsetPaginated;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetAllInboxesOffsetPaginated;

        internal void ExecuteOnGetAllInboxesOffsetPaginated(InboxControllerApi.GetAllInboxesOffsetPaginatedApiResponse apiResponse)
        {
            OnGetAllInboxesOffsetPaginated?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAllInboxesOffsetPaginated(Exception exception)
        {
            OnErrorGetAllInboxesOffsetPaginated?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetAllPlusAddresses;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetAllPlusAddresses;

        internal void ExecuteOnGetAllPlusAddresses(InboxControllerApi.GetAllPlusAddressesApiResponse apiResponse)
        {
            OnGetAllPlusAddresses?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAllPlusAddresses(Exception exception)
        {
            OnErrorGetAllPlusAddresses?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetAllScheduledJobs;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetAllScheduledJobs;

        internal void ExecuteOnGetAllScheduledJobs(InboxControllerApi.GetAllScheduledJobsApiResponse apiResponse)
        {
            OnGetAllScheduledJobs?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAllScheduledJobs(Exception exception)
        {
            OnErrorGetAllScheduledJobs?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetDeliveryStatusesByInboxId;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetDeliveryStatusesByInboxId;

        internal void ExecuteOnGetDeliveryStatusesByInboxId(InboxControllerApi.GetDeliveryStatusesByInboxIdApiResponse apiResponse)
        {
            OnGetDeliveryStatusesByInboxId?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetDeliveryStatusesByInboxId(Exception exception)
        {
            OnErrorGetDeliveryStatusesByInboxId?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmails;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmails;

        internal void ExecuteOnGetEmails(InboxControllerApi.GetEmailsApiResponse apiResponse)
        {
            OnGetEmails?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmails(Exception exception)
        {
            OnErrorGetEmails?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetImapAccess;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetImapAccess;

        internal void ExecuteOnGetImapAccess(InboxControllerApi.GetImapAccessApiResponse apiResponse)
        {
            OnGetImapAccess?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetImapAccess(Exception exception)
        {
            OnErrorGetImapAccess?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetImapSmtpAccess;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetImapSmtpAccess;

        internal void ExecuteOnGetImapSmtpAccess(InboxControllerApi.GetImapSmtpAccessApiResponse apiResponse)
        {
            OnGetImapSmtpAccess?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetImapSmtpAccess(Exception exception)
        {
            OnErrorGetImapSmtpAccess?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetImapSmtpAccessEnv;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetImapSmtpAccessEnv;

        internal void ExecuteOnGetImapSmtpAccessEnv(InboxControllerApi.GetImapSmtpAccessEnvApiResponse apiResponse)
        {
            OnGetImapSmtpAccessEnv?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetImapSmtpAccessEnv(Exception exception)
        {
            OnErrorGetImapSmtpAccessEnv?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetImapSmtpAccessServers;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetImapSmtpAccessServers;

        internal void ExecuteOnGetImapSmtpAccessServers(InboxControllerApi.GetImapSmtpAccessServersApiResponse apiResponse)
        {
            OnGetImapSmtpAccessServers?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetImapSmtpAccessServers(Exception exception)
        {
            OnErrorGetImapSmtpAccessServers?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInbox;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInbox;

        internal void ExecuteOnGetInbox(InboxControllerApi.GetInboxApiResponse apiResponse)
        {
            OnGetInbox?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInbox(Exception exception)
        {
            OnErrorGetInbox?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxByEmailAddress;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxByEmailAddress;

        internal void ExecuteOnGetInboxByEmailAddress(InboxControllerApi.GetInboxByEmailAddressApiResponse apiResponse)
        {
            OnGetInboxByEmailAddress?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxByEmailAddress(Exception exception)
        {
            OnErrorGetInboxByEmailAddress?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxByName;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxByName;

        internal void ExecuteOnGetInboxByName(InboxControllerApi.GetInboxByNameApiResponse apiResponse)
        {
            OnGetInboxByName?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxByName(Exception exception)
        {
            OnErrorGetInboxByName?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxCount;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxCount;

        internal void ExecuteOnGetInboxCount(InboxControllerApi.GetInboxCountApiResponse apiResponse)
        {
            OnGetInboxCount?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxCount(Exception exception)
        {
            OnErrorGetInboxCount?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxEmailCount;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxEmailCount;

        internal void ExecuteOnGetInboxEmailCount(InboxControllerApi.GetInboxEmailCountApiResponse apiResponse)
        {
            OnGetInboxEmailCount?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxEmailCount(Exception exception)
        {
            OnErrorGetInboxEmailCount?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxEmailsPaginated;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxEmailsPaginated;

        internal void ExecuteOnGetInboxEmailsPaginated(InboxControllerApi.GetInboxEmailsPaginatedApiResponse apiResponse)
        {
            OnGetInboxEmailsPaginated?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxEmailsPaginated(Exception exception)
        {
            OnErrorGetInboxEmailsPaginated?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxIds;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxIds;

        internal void ExecuteOnGetInboxIds(InboxControllerApi.GetInboxIdsApiResponse apiResponse)
        {
            OnGetInboxIds?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxIds(Exception exception)
        {
            OnErrorGetInboxIds?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxPlusAddress;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxPlusAddress;

        internal void ExecuteOnGetInboxPlusAddress(InboxControllerApi.GetInboxPlusAddressApiResponse apiResponse)
        {
            OnGetInboxPlusAddress?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxPlusAddress(Exception exception)
        {
            OnErrorGetInboxPlusAddress?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxPlusAddressById;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxPlusAddressById;

        internal void ExecuteOnGetInboxPlusAddressById(InboxControllerApi.GetInboxPlusAddressByIdApiResponse apiResponse)
        {
            OnGetInboxPlusAddressById?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxPlusAddressById(Exception exception)
        {
            OnErrorGetInboxPlusAddressById?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxPlusAddressEmails;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxPlusAddressEmails;

        internal void ExecuteOnGetInboxPlusAddressEmails(InboxControllerApi.GetInboxPlusAddressEmailsApiResponse apiResponse)
        {
            OnGetInboxPlusAddressEmails?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxPlusAddressEmails(Exception exception)
        {
            OnErrorGetInboxPlusAddressEmails?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxPlusAddressEmailsForPlusAddressId;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxPlusAddressEmailsForPlusAddressId;

        internal void ExecuteOnGetInboxPlusAddressEmailsForPlusAddressId(InboxControllerApi.GetInboxPlusAddressEmailsForPlusAddressIdApiResponse apiResponse)
        {
            OnGetInboxPlusAddressEmailsForPlusAddressId?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxPlusAddressEmailsForPlusAddressId(Exception exception)
        {
            OnErrorGetInboxPlusAddressEmailsForPlusAddressId?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxPlusAddresses;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxPlusAddresses;

        internal void ExecuteOnGetInboxPlusAddresses(InboxControllerApi.GetInboxPlusAddressesApiResponse apiResponse)
        {
            OnGetInboxPlusAddresses?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxPlusAddresses(Exception exception)
        {
            OnErrorGetInboxPlusAddresses?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxSentCount;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxSentCount;

        internal void ExecuteOnGetInboxSentCount(InboxControllerApi.GetInboxSentCountApiResponse apiResponse)
        {
            OnGetInboxSentCount?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxSentCount(Exception exception)
        {
            OnErrorGetInboxSentCount?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxSentEmails;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxSentEmails;

        internal void ExecuteOnGetInboxSentEmails(InboxControllerApi.GetInboxSentEmailsApiResponse apiResponse)
        {
            OnGetInboxSentEmails?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxSentEmails(Exception exception)
        {
            OnErrorGetInboxSentEmails?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxTags;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxTags;

        internal void ExecuteOnGetInboxTags(InboxControllerApi.GetInboxTagsApiResponse apiResponse)
        {
            OnGetInboxTags?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxTags(Exception exception)
        {
            OnErrorGetInboxTags?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxTagsPaginated;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxTagsPaginated;

        internal void ExecuteOnGetInboxTagsPaginated(InboxControllerApi.GetInboxTagsPaginatedApiResponse apiResponse)
        {
            OnGetInboxTagsPaginated?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxTagsPaginated(Exception exception)
        {
            OnErrorGetInboxTagsPaginated?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxes;

        internal void ExecuteOnGetInboxes(InboxControllerApi.GetInboxesApiResponse apiResponse)
        {
            OnGetInboxes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxes(Exception exception)
        {
            OnErrorGetInboxes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetInboxesByTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetInboxesByTag;

        internal void ExecuteOnGetInboxesByTag(InboxControllerApi.GetInboxesByTagApiResponse apiResponse)
        {
            OnGetInboxesByTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetInboxesByTag(Exception exception)
        {
            OnErrorGetInboxesByTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetLatestEmailInInbox;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetLatestEmailInInbox;

        internal void ExecuteOnGetLatestEmailInInbox(InboxControllerApi.GetLatestEmailInInboxApiResponse apiResponse)
        {
            OnGetLatestEmailInInbox?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetLatestEmailInInbox(Exception exception)
        {
            OnErrorGetLatestEmailInInbox?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetOrganizationInboxes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetOrganizationInboxes;

        internal void ExecuteOnGetOrganizationInboxes(InboxControllerApi.GetOrganizationInboxesApiResponse apiResponse)
        {
            OnGetOrganizationInboxes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetOrganizationInboxes(Exception exception)
        {
            OnErrorGetOrganizationInboxes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetOutboxes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetOutboxes;

        internal void ExecuteOnGetOutboxes(InboxControllerApi.GetOutboxesApiResponse apiResponse)
        {
            OnGetOutboxes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetOutboxes(Exception exception)
        {
            OnErrorGetOutboxes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetScheduledJob;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetScheduledJob;

        internal void ExecuteOnGetScheduledJob(InboxControllerApi.GetScheduledJobApiResponse apiResponse)
        {
            OnGetScheduledJob?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetScheduledJob(Exception exception)
        {
            OnErrorGetScheduledJob?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetScheduledJobsByInboxId;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetScheduledJobsByInboxId;

        internal void ExecuteOnGetScheduledJobsByInboxId(InboxControllerApi.GetScheduledJobsByInboxIdApiResponse apiResponse)
        {
            OnGetScheduledJobsByInboxId?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetScheduledJobsByInboxId(Exception exception)
        {
            OnErrorGetScheduledJobsByInboxId?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetSmtpAccess;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetSmtpAccess;

        internal void ExecuteOnGetSmtpAccess(InboxControllerApi.GetSmtpAccessApiResponse apiResponse)
        {
            OnGetSmtpAccess?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSmtpAccess(Exception exception)
        {
            OnErrorGetSmtpAccess?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnIsEmailAddressAvailable;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorIsEmailAddressAvailable;

        internal void ExecuteOnIsEmailAddressAvailable(InboxControllerApi.IsEmailAddressAvailableApiResponse apiResponse)
        {
            OnIsEmailAddressAvailable?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorIsEmailAddressAvailable(Exception exception)
        {
            OnErrorIsEmailAddressAvailable?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnListInboxRulesets;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorListInboxRulesets;

        internal void ExecuteOnListInboxRulesets(InboxControllerApi.ListInboxRulesetsApiResponse apiResponse)
        {
            OnListInboxRulesets?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListInboxRulesets(Exception exception)
        {
            OnErrorListInboxRulesets?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnListInboxTrackingPixels;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorListInboxTrackingPixels;

        internal void ExecuteOnListInboxTrackingPixels(InboxControllerApi.ListInboxTrackingPixelsApiResponse apiResponse)
        {
            OnListInboxTrackingPixels?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListInboxTrackingPixels(Exception exception)
        {
            OnErrorListInboxTrackingPixels?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSearchInboxes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSearchInboxes;

        internal void ExecuteOnSearchInboxes(InboxControllerApi.SearchInboxesApiResponse apiResponse)
        {
            OnSearchInboxes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchInboxes(Exception exception)
        {
            OnErrorSearchInboxes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSendEmail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSendEmail;

        internal void ExecuteOnSendEmail(InboxControllerApi.SendEmailApiResponse apiResponse)
        {
            OnSendEmail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendEmail(Exception exception)
        {
            OnErrorSendEmail?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSendEmailAndConfirm;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSendEmailAndConfirm;

        internal void ExecuteOnSendEmailAndConfirm(InboxControllerApi.SendEmailAndConfirmApiResponse apiResponse)
        {
            OnSendEmailAndConfirm?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendEmailAndConfirm(Exception exception)
        {
            OnErrorSendEmailAndConfirm?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSendEmailWithQueue;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSendEmailWithQueue;

        internal void ExecuteOnSendEmailWithQueue(InboxControllerApi.SendEmailWithQueueApiResponse apiResponse)
        {
            OnSendEmailWithQueue?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendEmailWithQueue(Exception exception)
        {
            OnErrorSendEmailWithQueue?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSendSmtpEnvelope;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSendSmtpEnvelope;

        internal void ExecuteOnSendSmtpEnvelope(InboxControllerApi.SendSmtpEnvelopeApiResponse apiResponse)
        {
            OnSendSmtpEnvelope?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendSmtpEnvelope(Exception exception)
        {
            OnErrorSendSmtpEnvelope?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSendTestEmail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSendTestEmail;

        internal void ExecuteOnSendTestEmail(InboxControllerApi.SendTestEmailApiResponse apiResponse)
        {
            OnSendTestEmail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendTestEmail(Exception exception)
        {
            OnErrorSendTestEmail?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSendWithSchedule;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSendWithSchedule;

        internal void ExecuteOnSendWithSchedule(InboxControllerApi.SendWithScheduleApiResponse apiResponse)
        {
            OnSendWithSchedule?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendWithSchedule(Exception exception)
        {
            OnErrorSendWithSchedule?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSetInboxFavourited;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSetInboxFavourited;

        internal void ExecuteOnSetInboxFavourited(InboxControllerApi.SetInboxFavouritedApiResponse apiResponse)
        {
            OnSetInboxFavourited?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSetInboxFavourited(Exception exception)
        {
            OnErrorSetInboxFavourited?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUpdateImapAccess;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUpdateImapAccess;

        internal void ExecuteOnUpdateImapAccess(InboxControllerApi.UpdateImapAccessApiResponse apiResponse)
        {
            OnUpdateImapAccess?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateImapAccess(Exception exception)
        {
            OnErrorUpdateImapAccess?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUpdateInbox;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUpdateInbox;

        internal void ExecuteOnUpdateInbox(InboxControllerApi.UpdateInboxApiResponse apiResponse)
        {
            OnUpdateInbox?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateInbox(Exception exception)
        {
            OnErrorUpdateInbox?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUpdateSmtpAccess;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUpdateSmtpAccess;

        internal void ExecuteOnUpdateSmtpAccess(InboxControllerApi.UpdateSmtpAccessApiResponse apiResponse)
        {
            OnUpdateSmtpAccess?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateSmtpAccess(Exception exception)
        {
            OnErrorUpdateSmtpAccess?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class InboxControllerApi : IInboxControllerApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<InboxControllerApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public InboxControllerApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="InboxControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public InboxControllerApi(ILogger<InboxControllerApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, InboxControllerApiEvents inboxControllerApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<InboxControllerApi>();
            HttpClient = httpClient;
            Events = inboxControllerApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatCancelScheduledJob(ref Guid jobId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="jobId"></param>
        private void AfterCancelScheduledJobDefaultImplementation(ICancelScheduledJobApiResponse apiResponseLocalVar, Guid jobId)
        {
            bool suppressDefaultLog = false;
            AfterCancelScheduledJob(ref suppressDefaultLog, apiResponseLocalVar, jobId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="jobId"></param>
        partial void AfterCancelScheduledJob(ref bool suppressDefaultLog, ICancelScheduledJobApiResponse apiResponseLocalVar, Guid jobId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="jobId"></param>
        private void OnErrorCancelScheduledJobDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid jobId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCancelScheduledJob(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, jobId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="jobId"></param>
        partial void OnErrorCancelScheduledJob(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid jobId);

        /// <summary>
        /// Cancel a scheduled email job Get a scheduled email job and cancel it. Will fail if status of job is already cancelled, failed, or complete.
        /// </summary>
        /// <param name="jobId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICancelScheduledJobApiResponse"/>&gt;</returns>
        public async Task<ICancelScheduledJobApiResponse> CancelScheduledJobOrDefaultAsync(Guid jobId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CancelScheduledJobAsync(jobId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Cancel a scheduled email job Get a scheduled email job and cancel it. Will fail if status of job is already cancelled, failed, or complete.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICancelScheduledJobApiResponse"/>&gt;</returns>
        public async Task<ICancelScheduledJobApiResponse> CancelScheduledJobAsync(Guid jobId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatCancelScheduledJob(ref jobId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/scheduled-jobs/{jobId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/scheduled-jobs/{jobId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BjobId%7D", Uri.EscapeDataString(jobId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<CancelScheduledJobApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CancelScheduledJobApiResponse>();

                        CancelScheduledJobApiResponse apiResponseLocalVar = new CancelScheduledJobApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/scheduled-jobs/{jobId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCancelScheduledJobDefaultImplementation(apiResponseLocalVar, jobId);

                        Events.ExecuteOnCancelScheduledJob(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCancelScheduledJobDefaultImplementation(e, "/inboxes/scheduled-jobs/{jobId}", uriBuilderLocalVar.Path, jobId);
                Events.ExecuteOnErrorCancelScheduledJob(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CancelScheduledJobApiResponse"/>
        /// </summary>
        public partial class CancelScheduledJobApiResponse : mailslurp.Client.ApiResponse, ICancelScheduledJobApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CancelScheduledJobApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CancelScheduledJobApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CancelScheduledJobApiResponse(ILogger<CancelScheduledJobApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ScheduledJobDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ScheduledJobDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ScheduledJobDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateInbox(ref Option<string> emailAddress, Option<List<string>> tags, ref Option<string> name, ref Option<string> description, ref Option<bool> useDomainPool, ref Option<bool> favourite, ref Option<DateTime> expiresAt, ref Option<long> expiresIn, ref Option<bool> allowTeamAccess, ref Option<string> inboxType, ref Option<bool> virtualInbox, ref Option<bool> useShortAddress, ref Option<Guid> domainId, ref Option<string> domainName, ref Option<string> prefix);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="emailAddress"></param>
        /// <param name="tags"></param>
        /// <param name="name"></param>
        /// <param name="description"></param>
        /// <param name="inboxType"></param>
        /// <param name="domainName"></param>
        /// <param name="prefix"></param>
        /// <returns></returns>
        private void ValidateCreateInbox(Option<string> emailAddress, Option<List<string>> tags, Option<string> name, Option<string> description, Option<string> inboxType, Option<string> domainName, Option<string> prefix)
        {
            if (emailAddress.IsSet && emailAddress.Value == null)
                throw new ArgumentNullException(nameof(emailAddress));

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));

            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name));

            if (description.IsSet && description.Value == null)
                throw new ArgumentNullException(nameof(description));

            if (inboxType.IsSet && inboxType.Value == null)
                throw new ArgumentNullException(nameof(inboxType));

            if (domainName.IsSet && domainName.Value == null)
                throw new ArgumentNullException(nameof(domainName));

            if (prefix.IsSet && prefix.Value == null)
                throw new ArgumentNullException(nameof(prefix));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailAddress"></param>
        /// <param name="tags"></param>
        /// <param name="name"></param>
        /// <param name="description"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="favourite"></param>
        /// <param name="expiresAt"></param>
        /// <param name="expiresIn"></param>
        /// <param name="allowTeamAccess"></param>
        /// <param name="inboxType"></param>
        /// <param name="virtualInbox"></param>
        /// <param name="useShortAddress"></param>
        /// <param name="domainId"></param>
        /// <param name="domainName"></param>
        /// <param name="prefix"></param>
        private void AfterCreateInboxDefaultImplementation(ICreateInboxApiResponse apiResponseLocalVar, Option<string> emailAddress, Option<List<string>> tags, Option<string> name, Option<string> description, Option<bool> useDomainPool, Option<bool> favourite, Option<DateTime> expiresAt, Option<long> expiresIn, Option<bool> allowTeamAccess, Option<string> inboxType, Option<bool> virtualInbox, Option<bool> useShortAddress, Option<Guid> domainId, Option<string> domainName, Option<string> prefix)
        {
            bool suppressDefaultLog = false;
            AfterCreateInbox(ref suppressDefaultLog, apiResponseLocalVar, emailAddress, tags, name, description, useDomainPool, favourite, expiresAt, expiresIn, allowTeamAccess, inboxType, virtualInbox, useShortAddress, domainId, domainName, prefix);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailAddress"></param>
        /// <param name="tags"></param>
        /// <param name="name"></param>
        /// <param name="description"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="favourite"></param>
        /// <param name="expiresAt"></param>
        /// <param name="expiresIn"></param>
        /// <param name="allowTeamAccess"></param>
        /// <param name="inboxType"></param>
        /// <param name="virtualInbox"></param>
        /// <param name="useShortAddress"></param>
        /// <param name="domainId"></param>
        /// <param name="domainName"></param>
        /// <param name="prefix"></param>
        partial void AfterCreateInbox(ref bool suppressDefaultLog, ICreateInboxApiResponse apiResponseLocalVar, Option<string> emailAddress, Option<List<string>> tags, Option<string> name, Option<string> description, Option<bool> useDomainPool, Option<bool> favourite, Option<DateTime> expiresAt, Option<long> expiresIn, Option<bool> allowTeamAccess, Option<string> inboxType, Option<bool> virtualInbox, Option<bool> useShortAddress, Option<Guid> domainId, Option<string> domainName, Option<string> prefix);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailAddress"></param>
        /// <param name="tags"></param>
        /// <param name="name"></param>
        /// <param name="description"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="favourite"></param>
        /// <param name="expiresAt"></param>
        /// <param name="expiresIn"></param>
        /// <param name="allowTeamAccess"></param>
        /// <param name="inboxType"></param>
        /// <param name="virtualInbox"></param>
        /// <param name="useShortAddress"></param>
        /// <param name="domainId"></param>
        /// <param name="domainName"></param>
        /// <param name="prefix"></param>
        private void OnErrorCreateInboxDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> emailAddress, Option<List<string>> tags, Option<string> name, Option<string> description, Option<bool> useDomainPool, Option<bool> favourite, Option<DateTime> expiresAt, Option<long> expiresIn, Option<bool> allowTeamAccess, Option<string> inboxType, Option<bool> virtualInbox, Option<bool> useShortAddress, Option<Guid> domainId, Option<string> domainName, Option<string> prefix)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateInbox(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailAddress, tags, name, description, useDomainPool, favourite, expiresAt, expiresIn, allowTeamAccess, inboxType, virtualInbox, useShortAddress, domainId, domainName, prefix);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailAddress"></param>
        /// <param name="tags"></param>
        /// <param name="name"></param>
        /// <param name="description"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="favourite"></param>
        /// <param name="expiresAt"></param>
        /// <param name="expiresIn"></param>
        /// <param name="allowTeamAccess"></param>
        /// <param name="inboxType"></param>
        /// <param name="virtualInbox"></param>
        /// <param name="useShortAddress"></param>
        /// <param name="domainId"></param>
        /// <param name="domainName"></param>
        /// <param name="prefix"></param>
        partial void OnErrorCreateInbox(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> emailAddress, Option<List<string>> tags, Option<string> name, Option<string> description, Option<bool> useDomainPool, Option<bool> favourite, Option<DateTime> expiresAt, Option<long> expiresIn, Option<bool> allowTeamAccess, Option<string> inboxType, Option<bool> virtualInbox, Option<bool> useShortAddress, Option<Guid> domainId, Option<string> domainName, Option<string> prefix);

        /// <summary>
        /// Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either &#x60;SMTP&#x60; or &#x60;HTTP&#x60; inboxes. Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
        /// </summary>
        /// <param name="emailAddress">A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Avoid &#x60;SMTP&#x60; inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID. (optional)</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI. (optional)</param>
        /// <param name="name">Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails. (optional)</param>
        /// <param name="description">Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with (optional)</param>
        /// <param name="useDomainPool">Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types. (optional)</param>
        /// <param name="favourite">Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering (optional)</param>
        /// <param name="expiresAt">Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)</param>
        /// <param name="expiresIn">Number of milliseconds that inbox should exist for (optional)</param>
        /// <param name="allowTeamAccess">DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization. (optional)</param>
        /// <param name="inboxType">HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mxslurp.click&#x60;. (optional)</param>
        /// <param name="virtualInbox">Virtual inbox prevents any outbound emails from being sent. It creates sent email records but will never send real emails to recipients. Great for testing and faking email sending. (optional)</param>
        /// <param name="useShortAddress">Use a shorter email address under 31 characters (optional)</param>
        /// <param name="domainId">ID of custom domain to use for email address. (optional)</param>
        /// <param name="domainName">FQDN domain name for the domain you have verified. Will be appended with a randomly assigned recipient name. Use the &#x60;emailAddress&#x60; option instead to specify the full custom inbox. (optional)</param>
        /// <param name="prefix">Prefix to add before the email address for easier labelling or identification. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxApiResponse"/>&gt;</returns>
        public async Task<ICreateInboxApiResponse> CreateInboxOrDefaultAsync(Option<string> emailAddress = default, Option<List<string>> tags = default, Option<string> name = default, Option<string> description = default, Option<bool> useDomainPool = default, Option<bool> favourite = default, Option<DateTime> expiresAt = default, Option<long> expiresIn = default, Option<bool> allowTeamAccess = default, Option<string> inboxType = default, Option<bool> virtualInbox = default, Option<bool> useShortAddress = default, Option<Guid> domainId = default, Option<string> domainName = default, Option<string> prefix = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateInboxAsync(emailAddress, tags, name, description, useDomainPool, favourite, expiresAt, expiresIn, allowTeamAccess, inboxType, virtualInbox, useShortAddress, domainId, domainName, prefix, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either &#x60;SMTP&#x60; or &#x60;HTTP&#x60; inboxes. Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Avoid &#x60;SMTP&#x60; inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID. (optional)</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI. (optional)</param>
        /// <param name="name">Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails. (optional)</param>
        /// <param name="description">Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with (optional)</param>
        /// <param name="useDomainPool">Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types. (optional)</param>
        /// <param name="favourite">Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering (optional)</param>
        /// <param name="expiresAt">Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)</param>
        /// <param name="expiresIn">Number of milliseconds that inbox should exist for (optional)</param>
        /// <param name="allowTeamAccess">DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization. (optional)</param>
        /// <param name="inboxType">HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mxslurp.click&#x60;. (optional)</param>
        /// <param name="virtualInbox">Virtual inbox prevents any outbound emails from being sent. It creates sent email records but will never send real emails to recipients. Great for testing and faking email sending. (optional)</param>
        /// <param name="useShortAddress">Use a shorter email address under 31 characters (optional)</param>
        /// <param name="domainId">ID of custom domain to use for email address. (optional)</param>
        /// <param name="domainName">FQDN domain name for the domain you have verified. Will be appended with a randomly assigned recipient name. Use the &#x60;emailAddress&#x60; option instead to specify the full custom inbox. (optional)</param>
        /// <param name="prefix">Prefix to add before the email address for easier labelling or identification. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxApiResponse"/>&gt;</returns>
        public async Task<ICreateInboxApiResponse> CreateInboxAsync(Option<string> emailAddress = default, Option<List<string>> tags = default, Option<string> name = default, Option<string> description = default, Option<bool> useDomainPool = default, Option<bool> favourite = default, Option<DateTime> expiresAt = default, Option<long> expiresIn = default, Option<bool> allowTeamAccess = default, Option<string> inboxType = default, Option<bool> virtualInbox = default, Option<bool> useShortAddress = default, Option<Guid> domainId = default, Option<string> domainName = default, Option<string> prefix = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateInbox(emailAddress, tags, name, description, inboxType, domainName, prefix);

                FormatCreateInbox(ref emailAddress, tags, ref name, ref description, ref useDomainPool, ref favourite, ref expiresAt, ref expiresIn, ref allowTeamAccess, ref inboxType, ref virtualInbox, ref useShortAddress, ref domainId, ref domainName, ref prefix);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (emailAddress.IsSet)
                        parseQueryStringLocalVar["emailAddress"] = ClientUtils.ParameterToString(emailAddress.Value);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags.Value);

                    if (name.IsSet)
                        parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name.Value);

                    if (description.IsSet)
                        parseQueryStringLocalVar["description"] = ClientUtils.ParameterToString(description.Value);

                    if (useDomainPool.IsSet)
                        parseQueryStringLocalVar["useDomainPool"] = ClientUtils.ParameterToString(useDomainPool.Value);

                    if (favourite.IsSet)
                        parseQueryStringLocalVar["favourite"] = ClientUtils.ParameterToString(favourite.Value);

                    if (expiresAt.IsSet)
                        parseQueryStringLocalVar["expiresAt"] = ClientUtils.ParameterToString(expiresAt.Value);

                    if (expiresIn.IsSet)
                        parseQueryStringLocalVar["expiresIn"] = ClientUtils.ParameterToString(expiresIn.Value);

                    if (allowTeamAccess.IsSet)
                        parseQueryStringLocalVar["allowTeamAccess"] = ClientUtils.ParameterToString(allowTeamAccess.Value);

                    if (inboxType.IsSet)
                        parseQueryStringLocalVar["inboxType"] = ClientUtils.ParameterToString(inboxType.Value);

                    if (virtualInbox.IsSet)
                        parseQueryStringLocalVar["virtualInbox"] = ClientUtils.ParameterToString(virtualInbox.Value);

                    if (useShortAddress.IsSet)
                        parseQueryStringLocalVar["useShortAddress"] = ClientUtils.ParameterToString(useShortAddress.Value);

                    if (domainId.IsSet)
                        parseQueryStringLocalVar["domainId"] = ClientUtils.ParameterToString(domainId.Value);

                    if (domainName.IsSet)
                        parseQueryStringLocalVar["domainName"] = ClientUtils.ParameterToString(domainName.Value);

                    if (prefix.IsSet)
                        parseQueryStringLocalVar["prefix"] = ClientUtils.ParameterToString(prefix.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<CreateInboxApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateInboxApiResponse>();

                        CreateInboxApiResponse apiResponseLocalVar = new CreateInboxApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateInboxDefaultImplementation(apiResponseLocalVar, emailAddress, tags, name, description, useDomainPool, favourite, expiresAt, expiresIn, allowTeamAccess, inboxType, virtualInbox, useShortAddress, domainId, domainName, prefix);

                        Events.ExecuteOnCreateInbox(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateInboxDefaultImplementation(e, "/inboxes", uriBuilderLocalVar.Path, emailAddress, tags, name, description, useDomainPool, favourite, expiresAt, expiresIn, allowTeamAccess, inboxType, virtualInbox, useShortAddress, domainId, domainName, prefix);
                Events.ExecuteOnErrorCreateInbox(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateInboxApiResponse"/>
        /// </summary>
        public partial class CreateInboxApiResponse : mailslurp.Client.ApiResponse, ICreateInboxApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateInboxApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateInboxApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateInboxApiResponse(ILogger<CreateInboxApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxDto Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out mailslurp.Model.InboxDto result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateInboxRuleset(ref Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createInboxRulesetOptions"></param>
        /// <returns></returns>
        private void ValidateCreateInboxRuleset(CreateInboxRulesetOptions createInboxRulesetOptions)
        {
            if (createInboxRulesetOptions == null)
                throw new ArgumentNullException(nameof(createInboxRulesetOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="createInboxRulesetOptions"></param>
        private void AfterCreateInboxRulesetDefaultImplementation(ICreateInboxRulesetApiResponse apiResponseLocalVar, Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions)
        {
            bool suppressDefaultLog = false;
            AfterCreateInboxRuleset(ref suppressDefaultLog, apiResponseLocalVar, inboxId, createInboxRulesetOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="createInboxRulesetOptions"></param>
        partial void AfterCreateInboxRuleset(ref bool suppressDefaultLog, ICreateInboxRulesetApiResponse apiResponseLocalVar, Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="createInboxRulesetOptions"></param>
        private void OnErrorCreateInboxRulesetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateInboxRuleset(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, createInboxRulesetOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="createInboxRulesetOptions"></param>
        partial void OnErrorCreateInboxRuleset(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions);

        /// <summary>
        /// Create an inbox ruleset Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving
        /// </summary>
        /// <param name="inboxId">inboxId</param>
        /// <param name="createInboxRulesetOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxRulesetApiResponse"/>&gt;</returns>
        public async Task<ICreateInboxRulesetApiResponse> CreateInboxRulesetOrDefaultAsync(Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateInboxRulesetAsync(inboxId, createInboxRulesetOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create an inbox ruleset Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">inboxId</param>
        /// <param name="createInboxRulesetOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxRulesetApiResponse"/>&gt;</returns>
        public async Task<ICreateInboxRulesetApiResponse> CreateInboxRulesetAsync(Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateInboxRuleset(createInboxRulesetOptions);

                FormatCreateInboxRuleset(ref inboxId, createInboxRulesetOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/rulesets"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/rulesets");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    httpRequestMessageLocalVar.Content = (createInboxRulesetOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createInboxRulesetOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<CreateInboxRulesetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateInboxRulesetApiResponse>();

                        CreateInboxRulesetApiResponse apiResponseLocalVar = new CreateInboxRulesetApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/rulesets", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateInboxRulesetDefaultImplementation(apiResponseLocalVar, inboxId, createInboxRulesetOptions);

                        Events.ExecuteOnCreateInboxRuleset(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateInboxRulesetDefaultImplementation(e, "/inboxes/{inboxId}/rulesets", uriBuilderLocalVar.Path, inboxId, createInboxRulesetOptions);
                Events.ExecuteOnErrorCreateInboxRuleset(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateInboxRulesetApiResponse"/>
        /// </summary>
        public partial class CreateInboxRulesetApiResponse : mailslurp.Client.ApiResponse, ICreateInboxRulesetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateInboxRulesetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateInboxRulesetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateInboxRulesetApiResponse(ILogger<CreateInboxRulesetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxRulesetDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxRulesetDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.InboxRulesetDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterCreateInboxWithDefaultsDefaultImplementation(ICreateInboxWithDefaultsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterCreateInboxWithDefaults(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterCreateInboxWithDefaults(ref bool suppressDefaultLog, ICreateInboxWithDefaultsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorCreateInboxWithDefaultsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateInboxWithDefaults(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorCreateInboxWithDefaults(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Create an inbox with default options. Uses MailSlurp domain pool address and is private. 
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxWithDefaultsApiResponse"/>&gt;</returns>
        public async Task<ICreateInboxWithDefaultsApiResponse> CreateInboxWithDefaultsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateInboxWithDefaultsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create an inbox with default options. Uses MailSlurp domain pool address and is private. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxWithDefaultsApiResponse"/>&gt;</returns>
        public async Task<ICreateInboxWithDefaultsApiResponse> CreateInboxWithDefaultsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/withDefaults"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/withDefaults");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<CreateInboxWithDefaultsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateInboxWithDefaultsApiResponse>();

                        CreateInboxWithDefaultsApiResponse apiResponseLocalVar = new CreateInboxWithDefaultsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/withDefaults", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateInboxWithDefaultsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnCreateInboxWithDefaults(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateInboxWithDefaultsDefaultImplementation(e, "/inboxes/withDefaults", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorCreateInboxWithDefaults(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateInboxWithDefaultsApiResponse"/>
        /// </summary>
        public partial class CreateInboxWithDefaultsApiResponse : mailslurp.Client.ApiResponse, ICreateInboxWithDefaultsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateInboxWithDefaultsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateInboxWithDefaultsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateInboxWithDefaultsApiResponse(ILogger<CreateInboxWithDefaultsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxDto Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out mailslurp.Model.InboxDto result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateInboxWithOptions(CreateInboxDto createInboxDto);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createInboxDto"></param>
        /// <returns></returns>
        private void ValidateCreateInboxWithOptions(CreateInboxDto createInboxDto)
        {
            if (createInboxDto == null)
                throw new ArgumentNullException(nameof(createInboxDto));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createInboxDto"></param>
        private void AfterCreateInboxWithOptionsDefaultImplementation(ICreateInboxWithOptionsApiResponse apiResponseLocalVar, CreateInboxDto createInboxDto)
        {
            bool suppressDefaultLog = false;
            AfterCreateInboxWithOptions(ref suppressDefaultLog, apiResponseLocalVar, createInboxDto);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createInboxDto"></param>
        partial void AfterCreateInboxWithOptions(ref bool suppressDefaultLog, ICreateInboxWithOptionsApiResponse apiResponseLocalVar, CreateInboxDto createInboxDto);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createInboxDto"></param>
        private void OnErrorCreateInboxWithOptionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CreateInboxDto createInboxDto)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateInboxWithOptions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, createInboxDto);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createInboxDto"></param>
        partial void OnErrorCreateInboxWithOptions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CreateInboxDto createInboxDto);

        /// <summary>
        /// Create an inbox with options. Extended options for inbox creation. Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
        /// </summary>
        /// <param name="createInboxDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxWithOptionsApiResponse"/>&gt;</returns>
        public async Task<ICreateInboxWithOptionsApiResponse> CreateInboxWithOptionsOrDefaultAsync(CreateInboxDto createInboxDto, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateInboxWithOptionsAsync(createInboxDto, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create an inbox with options. Extended options for inbox creation. Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createInboxDto"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInboxWithOptionsApiResponse"/>&gt;</returns>
        public async Task<ICreateInboxWithOptionsApiResponse> CreateInboxWithOptionsAsync(CreateInboxDto createInboxDto, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateInboxWithOptions(createInboxDto);

                FormatCreateInboxWithOptions(createInboxDto);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/withOptions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/withOptions");

                    httpRequestMessageLocalVar.Content = (createInboxDto as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createInboxDto, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<CreateInboxWithOptionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateInboxWithOptionsApiResponse>();

                        CreateInboxWithOptionsApiResponse apiResponseLocalVar = new CreateInboxWithOptionsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/withOptions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateInboxWithOptionsDefaultImplementation(apiResponseLocalVar, createInboxDto);

                        Events.ExecuteOnCreateInboxWithOptions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateInboxWithOptionsDefaultImplementation(e, "/inboxes/withOptions", uriBuilderLocalVar.Path, createInboxDto);
                Events.ExecuteOnErrorCreateInboxWithOptions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateInboxWithOptionsApiResponse"/>
        /// </summary>
        public partial class CreateInboxWithOptionsApiResponse : mailslurp.Client.ApiResponse, ICreateInboxWithOptionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateInboxWithOptionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateInboxWithOptionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateInboxWithOptionsApiResponse(ILogger<CreateInboxWithOptionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxDto Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out mailslurp.Model.InboxDto result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteAllInboxEmails(ref Guid inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterDeleteAllInboxEmailsDefaultImplementation(IDeleteAllInboxEmailsApiResponse apiResponseLocalVar, Guid inboxId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteAllInboxEmails(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterDeleteAllInboxEmails(ref bool suppressDefaultLog, IDeleteAllInboxEmailsApiResponse apiResponseLocalVar, Guid inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorDeleteAllInboxEmailsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteAllInboxEmails(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorDeleteAllInboxEmails(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId);

        /// <summary>
        /// Delete all emails in a given inboxes. Deletes all emails in an inbox. Be careful as emails cannot be recovered
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxEmailsApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllInboxEmailsApiResponse> DeleteAllInboxEmailsOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteAllInboxEmailsAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete all emails in a given inboxes. Deletes all emails in an inbox. Be careful as emails cannot be recovered
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxEmailsApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllInboxEmailsApiResponse> DeleteAllInboxEmailsAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteAllInboxEmails(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/deleteAllInboxEmails"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/deleteAllInboxEmails");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DeleteAllInboxEmailsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteAllInboxEmailsApiResponse>();

                        DeleteAllInboxEmailsApiResponse apiResponseLocalVar = new DeleteAllInboxEmailsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/deleteAllInboxEmails", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteAllInboxEmailsDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnDeleteAllInboxEmails(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteAllInboxEmailsDefaultImplementation(e, "/inboxes/{inboxId}/deleteAllInboxEmails", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorDeleteAllInboxEmails(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteAllInboxEmailsApiResponse"/>
        /// </summary>
        public partial class DeleteAllInboxEmailsApiResponse : mailslurp.Client.ApiResponse, IDeleteAllInboxEmailsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteAllInboxEmailsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteAllInboxEmailsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteAllInboxEmailsApiResponse(ILogger<DeleteAllInboxEmailsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterDeleteAllInboxesDefaultImplementation(IDeleteAllInboxesApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterDeleteAllInboxes(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterDeleteAllInboxes(ref bool suppressDefaultLog, IDeleteAllInboxesApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorDeleteAllInboxesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteAllInboxes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorDeleteAllInboxes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Delete all inboxes Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllInboxesApiResponse> DeleteAllInboxesOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteAllInboxesAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete all inboxes Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllInboxesApiResponse> DeleteAllInboxesAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DeleteAllInboxesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteAllInboxesApiResponse>();

                        DeleteAllInboxesApiResponse apiResponseLocalVar = new DeleteAllInboxesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteAllInboxesDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnDeleteAllInboxes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteAllInboxesDefaultImplementation(e, "/inboxes", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorDeleteAllInboxes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteAllInboxesApiResponse"/>
        /// </summary>
        public partial class DeleteAllInboxesApiResponse : mailslurp.Client.ApiResponse, IDeleteAllInboxesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteAllInboxesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteAllInboxesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteAllInboxesApiResponse(ILogger<DeleteAllInboxesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteAllInboxesByDescription(ref string description);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="description"></param>
        /// <returns></returns>
        private void ValidateDeleteAllInboxesByDescription(string description)
        {
            if (description == null)
                throw new ArgumentNullException(nameof(description));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="description"></param>
        private void AfterDeleteAllInboxesByDescriptionDefaultImplementation(IDeleteAllInboxesByDescriptionApiResponse apiResponseLocalVar, string description)
        {
            bool suppressDefaultLog = false;
            AfterDeleteAllInboxesByDescription(ref suppressDefaultLog, apiResponseLocalVar, description);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="description"></param>
        partial void AfterDeleteAllInboxesByDescription(ref bool suppressDefaultLog, IDeleteAllInboxesByDescriptionApiResponse apiResponseLocalVar, string description);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="description"></param>
        private void OnErrorDeleteAllInboxesByDescriptionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string description)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteAllInboxesByDescription(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, description);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="description"></param>
        partial void OnErrorDeleteAllInboxesByDescription(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string description);

        /// <summary>
        /// Delete inboxes by description Permanently delete all inboxes by description
        /// </summary>
        /// <param name="description"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesByDescriptionApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllInboxesByDescriptionApiResponse> DeleteAllInboxesByDescriptionOrDefaultAsync(string description, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteAllInboxesByDescriptionAsync(description, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete inboxes by description Permanently delete all inboxes by description
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="description"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesByDescriptionApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllInboxesByDescriptionApiResponse> DeleteAllInboxesByDescriptionAsync(string description, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteAllInboxesByDescription(description);

                FormatDeleteAllInboxesByDescription(ref description);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/by-description"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/by-description");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["description"] = ClientUtils.ParameterToString(description);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DeleteAllInboxesByDescriptionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteAllInboxesByDescriptionApiResponse>();

                        DeleteAllInboxesByDescriptionApiResponse apiResponseLocalVar = new DeleteAllInboxesByDescriptionApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/by-description", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteAllInboxesByDescriptionDefaultImplementation(apiResponseLocalVar, description);

                        Events.ExecuteOnDeleteAllInboxesByDescription(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteAllInboxesByDescriptionDefaultImplementation(e, "/inboxes/by-description", uriBuilderLocalVar.Path, description);
                Events.ExecuteOnErrorDeleteAllInboxesByDescription(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteAllInboxesByDescriptionApiResponse"/>
        /// </summary>
        public partial class DeleteAllInboxesByDescriptionApiResponse : mailslurp.Client.ApiResponse, IDeleteAllInboxesByDescriptionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteAllInboxesByDescriptionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteAllInboxesByDescriptionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteAllInboxesByDescriptionApiResponse(ILogger<DeleteAllInboxesByDescriptionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteAllInboxesByName(ref string name);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        private void ValidateDeleteAllInboxesByName(string name)
        {
            if (name == null)
                throw new ArgumentNullException(nameof(name));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        private void AfterDeleteAllInboxesByNameDefaultImplementation(IDeleteAllInboxesByNameApiResponse apiResponseLocalVar, string name)
        {
            bool suppressDefaultLog = false;
            AfterDeleteAllInboxesByName(ref suppressDefaultLog, apiResponseLocalVar, name);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        partial void AfterDeleteAllInboxesByName(ref bool suppressDefaultLog, IDeleteAllInboxesByNameApiResponse apiResponseLocalVar, string name);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        private void OnErrorDeleteAllInboxesByNameDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string name)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteAllInboxesByName(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, name);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        partial void OnErrorDeleteAllInboxesByName(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string name);

        /// <summary>
        /// Delete inboxes by name Permanently delete all inboxes by name
        /// </summary>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesByNameApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllInboxesByNameApiResponse> DeleteAllInboxesByNameOrDefaultAsync(string name, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteAllInboxesByNameAsync(name, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete inboxes by name Permanently delete all inboxes by name
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesByNameApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllInboxesByNameApiResponse> DeleteAllInboxesByNameAsync(string name, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteAllInboxesByName(name);

                FormatDeleteAllInboxesByName(ref name);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/by-name"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/by-name");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DeleteAllInboxesByNameApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteAllInboxesByNameApiResponse>();

                        DeleteAllInboxesByNameApiResponse apiResponseLocalVar = new DeleteAllInboxesByNameApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/by-name", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteAllInboxesByNameDefaultImplementation(apiResponseLocalVar, name);

                        Events.ExecuteOnDeleteAllInboxesByName(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteAllInboxesByNameDefaultImplementation(e, "/inboxes/by-name", uriBuilderLocalVar.Path, name);
                Events.ExecuteOnErrorDeleteAllInboxesByName(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteAllInboxesByNameApiResponse"/>
        /// </summary>
        public partial class DeleteAllInboxesByNameApiResponse : mailslurp.Client.ApiResponse, IDeleteAllInboxesByNameApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteAllInboxesByNameApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteAllInboxesByNameApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteAllInboxesByNameApiResponse(ILogger<DeleteAllInboxesByNameApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteAllInboxesByTag(ref string tag);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        private void ValidateDeleteAllInboxesByTag(string tag)
        {
            if (tag == null)
                throw new ArgumentNullException(nameof(tag));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tag"></param>
        private void AfterDeleteAllInboxesByTagDefaultImplementation(IDeleteAllInboxesByTagApiResponse apiResponseLocalVar, string tag)
        {
            bool suppressDefaultLog = false;
            AfterDeleteAllInboxesByTag(ref suppressDefaultLog, apiResponseLocalVar, tag);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tag"></param>
        partial void AfterDeleteAllInboxesByTag(ref bool suppressDefaultLog, IDeleteAllInboxesByTagApiResponse apiResponseLocalVar, string tag);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tag"></param>
        private void OnErrorDeleteAllInboxesByTagDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string tag)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteAllInboxesByTag(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, tag);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tag"></param>
        partial void OnErrorDeleteAllInboxesByTag(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string tag);

        /// <summary>
        /// Delete inboxes by tag Permanently delete all inboxes by tag
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesByTagApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllInboxesByTagApiResponse> DeleteAllInboxesByTagOrDefaultAsync(string tag, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteAllInboxesByTagAsync(tag, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete inboxes by tag Permanently delete all inboxes by tag
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllInboxesByTagApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllInboxesByTagApiResponse> DeleteAllInboxesByTagAsync(string tag, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteAllInboxesByTag(tag);

                FormatDeleteAllInboxesByTag(ref tag);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/by-tag"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/by-tag");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["tag"] = ClientUtils.ParameterToString(tag);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DeleteAllInboxesByTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteAllInboxesByTagApiResponse>();

                        DeleteAllInboxesByTagApiResponse apiResponseLocalVar = new DeleteAllInboxesByTagApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/by-tag", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteAllInboxesByTagDefaultImplementation(apiResponseLocalVar, tag);

                        Events.ExecuteOnDeleteAllInboxesByTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteAllInboxesByTagDefaultImplementation(e, "/inboxes/by-tag", uriBuilderLocalVar.Path, tag);
                Events.ExecuteOnErrorDeleteAllInboxesByTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteAllInboxesByTagApiResponse"/>
        /// </summary>
        public partial class DeleteAllInboxesByTagApiResponse : mailslurp.Client.ApiResponse, IDeleteAllInboxesByTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteAllInboxesByTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteAllInboxesByTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteAllInboxesByTagApiResponse(ILogger<DeleteAllInboxesByTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteInbox(ref Guid inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterDeleteInboxDefaultImplementation(IDeleteInboxApiResponse apiResponseLocalVar, Guid inboxId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteInbox(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterDeleteInbox(ref bool suppressDefaultLog, IDeleteInboxApiResponse apiResponseLocalVar, Guid inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorDeleteInboxDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteInbox(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorDeleteInbox(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId);

        /// <summary>
        /// Delete inbox Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteInboxApiResponse"/>&gt;</returns>
        public async Task<IDeleteInboxApiResponse> DeleteInboxOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteInboxAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete inbox Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteInboxApiResponse"/>&gt;</returns>
        public async Task<IDeleteInboxApiResponse> DeleteInboxAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteInbox(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DeleteInboxApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteInboxApiResponse>();

                        DeleteInboxApiResponse apiResponseLocalVar = new DeleteInboxApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteInboxDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnDeleteInbox(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteInboxDefaultImplementation(e, "/inboxes/{inboxId}", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorDeleteInbox(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteInboxApiResponse"/>
        /// </summary>
        public partial class DeleteInboxApiResponse : mailslurp.Client.ApiResponse, IDeleteInboxApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteInboxApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteInboxApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteInboxApiResponse(ILogger<DeleteInboxApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDoesInboxExist(ref string emailAddress, ref Option<bool> allowCatchAll);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="emailAddress"></param>
        /// <returns></returns>
        private void ValidateDoesInboxExist(string emailAddress)
        {
            if (emailAddress == null)
                throw new ArgumentNullException(nameof(emailAddress));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailAddress"></param>
        /// <param name="allowCatchAll"></param>
        private void AfterDoesInboxExistDefaultImplementation(IDoesInboxExistApiResponse apiResponseLocalVar, string emailAddress, Option<bool> allowCatchAll)
        {
            bool suppressDefaultLog = false;
            AfterDoesInboxExist(ref suppressDefaultLog, apiResponseLocalVar, emailAddress, allowCatchAll);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailAddress"></param>
        /// <param name="allowCatchAll"></param>
        partial void AfterDoesInboxExist(ref bool suppressDefaultLog, IDoesInboxExistApiResponse apiResponseLocalVar, string emailAddress, Option<bool> allowCatchAll);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailAddress"></param>
        /// <param name="allowCatchAll"></param>
        private void OnErrorDoesInboxExistDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string emailAddress, Option<bool> allowCatchAll)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDoesInboxExist(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailAddress, allowCatchAll);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailAddress"></param>
        /// <param name="allowCatchAll"></param>
        partial void OnErrorDoesInboxExist(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string emailAddress, Option<bool> allowCatchAll);

        /// <summary>
        /// Does inbox exist Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses
        /// </summary>
        /// <param name="emailAddress">Email address</param>
        /// <param name="allowCatchAll"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDoesInboxExistApiResponse"/>&gt;</returns>
        public async Task<IDoesInboxExistApiResponse> DoesInboxExistOrDefaultAsync(string emailAddress, Option<bool> allowCatchAll = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DoesInboxExistAsync(emailAddress, allowCatchAll, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Does inbox exist Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">Email address</param>
        /// <param name="allowCatchAll"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDoesInboxExistApiResponse"/>&gt;</returns>
        public async Task<IDoesInboxExistApiResponse> DoesInboxExistAsync(string emailAddress, Option<bool> allowCatchAll = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDoesInboxExist(emailAddress);

                FormatDoesInboxExist(ref emailAddress, ref allowCatchAll);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/exists"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/exists");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["emailAddress"] = ClientUtils.ParameterToString(emailAddress);

                    if (allowCatchAll.IsSet)
                        parseQueryStringLocalVar["allowCatchAll"] = ClientUtils.ParameterToString(allowCatchAll.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DoesInboxExistApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DoesInboxExistApiResponse>();

                        DoesInboxExistApiResponse apiResponseLocalVar = new DoesInboxExistApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/exists", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDoesInboxExistDefaultImplementation(apiResponseLocalVar, emailAddress, allowCatchAll);

                        Events.ExecuteOnDoesInboxExist(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDoesInboxExistDefaultImplementation(e, "/inboxes/exists", uriBuilderLocalVar.Path, emailAddress, allowCatchAll);
                Events.ExecuteOnErrorDoesInboxExist(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DoesInboxExistApiResponse"/>
        /// </summary>
        public partial class DoesInboxExistApiResponse : mailslurp.Client.ApiResponse, IDoesInboxExistApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DoesInboxExistApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DoesInboxExistApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DoesInboxExistApiResponse(ILogger<DoesInboxExistApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxExistsDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxExistsDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.InboxExistsDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterDoesInboxHaveAutomationsDefaultImplementation(IDoesInboxHaveAutomationsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterDoesInboxHaveAutomations(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterDoesInboxHaveAutomations(ref bool suppressDefaultLog, IDoesInboxHaveAutomationsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorDoesInboxHaveAutomationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDoesInboxHaveAutomations(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorDoesInboxHaveAutomations(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Does inbox have automations Check if an inbox has automations.
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDoesInboxHaveAutomationsApiResponse"/>&gt;</returns>
        public async Task<IDoesInboxHaveAutomationsApiResponse> DoesInboxHaveAutomationsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DoesInboxHaveAutomationsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Does inbox have automations Check if an inbox has automations.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDoesInboxHaveAutomationsApiResponse"/>&gt;</returns>
        public async Task<IDoesInboxHaveAutomationsApiResponse> DoesInboxHaveAutomationsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/automations"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/automations");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DoesInboxHaveAutomationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DoesInboxHaveAutomationsApiResponse>();

                        DoesInboxHaveAutomationsApiResponse apiResponseLocalVar = new DoesInboxHaveAutomationsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/automations", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDoesInboxHaveAutomationsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnDoesInboxHaveAutomations(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDoesInboxHaveAutomationsDefaultImplementation(e, "/inboxes/automations", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorDoesInboxHaveAutomations(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DoesInboxHaveAutomationsApiResponse"/>
        /// </summary>
        public partial class DoesInboxHaveAutomationsApiResponse : mailslurp.Client.ApiResponse, IDoesInboxHaveAutomationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DoesInboxHaveAutomationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DoesInboxHaveAutomationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DoesInboxHaveAutomationsApiResponse(ILogger<DoesInboxHaveAutomationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFlushExpired(ref Option<DateTime> before);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="before"></param>
        private void AfterFlushExpiredDefaultImplementation(IFlushExpiredApiResponse apiResponseLocalVar, Option<DateTime> before)
        {
            bool suppressDefaultLog = false;
            AfterFlushExpired(ref suppressDefaultLog, apiResponseLocalVar, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="before"></param>
        partial void AfterFlushExpired(ref bool suppressDefaultLog, IFlushExpiredApiResponse apiResponseLocalVar, Option<DateTime> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="before"></param>
        private void OnErrorFlushExpiredDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<DateTime> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorFlushExpired(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="before"></param>
        partial void OnErrorFlushExpired(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<DateTime> before);

        /// <summary>
        /// Remove expired inboxes Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)
        /// </summary>
        /// <param name="before">Optional expired at before flag to flush expired inboxes that have expired before the given time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFlushExpiredApiResponse"/>&gt;</returns>
        public async Task<IFlushExpiredApiResponse> FlushExpiredOrDefaultAsync(Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FlushExpiredAsync(before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Remove expired inboxes Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Optional expired at before flag to flush expired inboxes that have expired before the given time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFlushExpiredApiResponse"/>&gt;</returns>
        public async Task<IFlushExpiredApiResponse> FlushExpiredAsync(Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatFlushExpired(ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/expired"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/expired");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<FlushExpiredApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FlushExpiredApiResponse>();

                        FlushExpiredApiResponse apiResponseLocalVar = new FlushExpiredApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/expired", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterFlushExpiredDefaultImplementation(apiResponseLocalVar, before);

                        Events.ExecuteOnFlushExpired(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFlushExpiredDefaultImplementation(e, "/inboxes/expired", uriBuilderLocalVar.Path, before);
                Events.ExecuteOnErrorFlushExpired(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FlushExpiredApiResponse"/>
        /// </summary>
        public partial class FlushExpiredApiResponse : mailslurp.Client.ApiResponse, IFlushExpiredApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FlushExpiredApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FlushExpiredApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FlushExpiredApiResponse(ILogger<FlushExpiredApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.FlushExpiredInboxesResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.FlushExpiredInboxesResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.FlushExpiredInboxesResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAllInboxes(ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<bool> favourite, ref Option<string> search, ref Option<string> tag, ref Option<bool> teamAccess, ref Option<DateTime> since, ref Option<DateTime> before, ref Option<string> inboxType, ref Option<string> inboxFunction, ref Option<Guid> domainId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="search"></param>
        /// <param name="tag"></param>
        /// <param name="inboxType"></param>
        /// <param name="inboxFunction"></param>
        /// <returns></returns>
        private void ValidateGetAllInboxes(Option<string> sort, Option<string> search, Option<string> tag, Option<string> inboxType, Option<string> inboxFunction)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (search.IsSet && search.Value == null)
                throw new ArgumentNullException(nameof(search));

            if (tag.IsSet && tag.Value == null)
                throw new ArgumentNullException(nameof(tag));

            if (inboxType.IsSet && inboxType.Value == null)
                throw new ArgumentNullException(nameof(inboxType));

            if (inboxFunction.IsSet && inboxFunction.Value == null)
                throw new ArgumentNullException(nameof(inboxFunction));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="favourite"></param>
        /// <param name="search"></param>
        /// <param name="tag"></param>
        /// <param name="teamAccess"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxType"></param>
        /// <param name="inboxFunction"></param>
        /// <param name="domainId"></param>
        private void AfterGetAllInboxesDefaultImplementation(IGetAllInboxesApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<bool> favourite, Option<string> search, Option<string> tag, Option<bool> teamAccess, Option<DateTime> since, Option<DateTime> before, Option<string> inboxType, Option<string> inboxFunction, Option<Guid> domainId)
        {
            bool suppressDefaultLog = false;
            AfterGetAllInboxes(ref suppressDefaultLog, apiResponseLocalVar, page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="favourite"></param>
        /// <param name="search"></param>
        /// <param name="tag"></param>
        /// <param name="teamAccess"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxType"></param>
        /// <param name="inboxFunction"></param>
        /// <param name="domainId"></param>
        partial void AfterGetAllInboxes(ref bool suppressDefaultLog, IGetAllInboxesApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<bool> favourite, Option<string> search, Option<string> tag, Option<bool> teamAccess, Option<DateTime> since, Option<DateTime> before, Option<string> inboxType, Option<string> inboxFunction, Option<Guid> domainId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="favourite"></param>
        /// <param name="search"></param>
        /// <param name="tag"></param>
        /// <param name="teamAccess"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxType"></param>
        /// <param name="inboxFunction"></param>
        /// <param name="domainId"></param>
        private void OnErrorGetAllInboxesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<bool> favourite, Option<string> search, Option<string> tag, Option<bool> teamAccess, Option<DateTime> since, Option<DateTime> before, Option<string> inboxType, Option<string> inboxFunction, Option<Guid> domainId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAllInboxes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="favourite"></param>
        /// <param name="search"></param>
        /// <param name="tag"></param>
        /// <param name="teamAccess"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxType"></param>
        /// <param name="inboxFunction"></param>
        /// <param name="domainId"></param>
        partial void OnErrorGetAllInboxes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<bool> favourite, Option<string> search, Option<string> tag, Option<bool> teamAccess, Option<DateTime> since, Option<DateTime> before, Option<string> inboxType, Option<string> inboxFunction, Option<Guid> domainId);

        /// <summary>
        /// List All Inboxes Paginated List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllInboxesApiResponse"/>&gt;</returns>
        public async Task<IGetAllInboxesApiResponse> GetAllInboxesOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> favourite = default, Option<string> search = default, Option<string> tag = default, Option<bool> teamAccess = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> inboxType = default, Option<string> inboxFunction = default, Option<Guid> domainId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAllInboxesAsync(page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List All Inboxes Paginated List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllInboxesApiResponse"/>&gt;</returns>
        public async Task<IGetAllInboxesApiResponse> GetAllInboxesAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> favourite = default, Option<string> search = default, Option<string> tag = default, Option<bool> teamAccess = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> inboxType = default, Option<string> inboxFunction = default, Option<Guid> domainId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAllInboxes(sort, search, tag, inboxType, inboxFunction);

                FormatGetAllInboxes(ref page, ref size, ref sort, ref favourite, ref search, ref tag, ref teamAccess, ref since, ref before, ref inboxType, ref inboxFunction, ref domainId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/paginated"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/paginated");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (favourite.IsSet)
                        parseQueryStringLocalVar["favourite"] = ClientUtils.ParameterToString(favourite.Value);

                    if (search.IsSet)
                        parseQueryStringLocalVar["search"] = ClientUtils.ParameterToString(search.Value);

                    if (tag.IsSet)
                        parseQueryStringLocalVar["tag"] = ClientUtils.ParameterToString(tag.Value);

                    if (teamAccess.IsSet)
                        parseQueryStringLocalVar["teamAccess"] = ClientUtils.ParameterToString(teamAccess.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (inboxType.IsSet)
                        parseQueryStringLocalVar["inboxType"] = ClientUtils.ParameterToString(inboxType.Value);

                    if (inboxFunction.IsSet)
                        parseQueryStringLocalVar["inboxFunction"] = ClientUtils.ParameterToString(inboxFunction.Value);

                    if (domainId.IsSet)
                        parseQueryStringLocalVar["domainId"] = ClientUtils.ParameterToString(domainId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetAllInboxesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAllInboxesApiResponse>();

                        GetAllInboxesApiResponse apiResponseLocalVar = new GetAllInboxesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/paginated", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAllInboxesDefaultImplementation(apiResponseLocalVar, page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId);

                        Events.ExecuteOnGetAllInboxes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAllInboxesDefaultImplementation(e, "/inboxes/paginated", uriBuilderLocalVar.Path, page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId);
                Events.ExecuteOnErrorGetAllInboxes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAllInboxesApiResponse"/>
        /// </summary>
        public partial class GetAllInboxesApiResponse : mailslurp.Client.ApiResponse, IGetAllInboxesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAllInboxesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAllInboxesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAllInboxesApiResponse(ILogger<GetAllInboxesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageInboxProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageInboxProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageInboxProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAllInboxesOffsetPaginated(ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<bool> favourite, ref Option<string> search, ref Option<string> tag, ref Option<bool> teamAccess, ref Option<DateTime> since, ref Option<DateTime> before, ref Option<string> inboxType, ref Option<string> inboxFunction, ref Option<Guid> domainId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="search"></param>
        /// <param name="tag"></param>
        /// <param name="inboxType"></param>
        /// <param name="inboxFunction"></param>
        /// <returns></returns>
        private void ValidateGetAllInboxesOffsetPaginated(Option<string> sort, Option<string> search, Option<string> tag, Option<string> inboxType, Option<string> inboxFunction)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (search.IsSet && search.Value == null)
                throw new ArgumentNullException(nameof(search));

            if (tag.IsSet && tag.Value == null)
                throw new ArgumentNullException(nameof(tag));

            if (inboxType.IsSet && inboxType.Value == null)
                throw new ArgumentNullException(nameof(inboxType));

            if (inboxFunction.IsSet && inboxFunction.Value == null)
                throw new ArgumentNullException(nameof(inboxFunction));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="favourite"></param>
        /// <param name="search"></param>
        /// <param name="tag"></param>
        /// <param name="teamAccess"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxType"></param>
        /// <param name="inboxFunction"></param>
        /// <param name="domainId"></param>
        private void AfterGetAllInboxesOffsetPaginatedDefaultImplementation(IGetAllInboxesOffsetPaginatedApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<bool> favourite, Option<string> search, Option<string> tag, Option<bool> teamAccess, Option<DateTime> since, Option<DateTime> before, Option<string> inboxType, Option<string> inboxFunction, Option<Guid> domainId)
        {
            bool suppressDefaultLog = false;
            AfterGetAllInboxesOffsetPaginated(ref suppressDefaultLog, apiResponseLocalVar, page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="favourite"></param>
        /// <param name="search"></param>
        /// <param name="tag"></param>
        /// <param name="teamAccess"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxType"></param>
        /// <param name="inboxFunction"></param>
        /// <param name="domainId"></param>
        partial void AfterGetAllInboxesOffsetPaginated(ref bool suppressDefaultLog, IGetAllInboxesOffsetPaginatedApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<bool> favourite, Option<string> search, Option<string> tag, Option<bool> teamAccess, Option<DateTime> since, Option<DateTime> before, Option<string> inboxType, Option<string> inboxFunction, Option<Guid> domainId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="favourite"></param>
        /// <param name="search"></param>
        /// <param name="tag"></param>
        /// <param name="teamAccess"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxType"></param>
        /// <param name="inboxFunction"></param>
        /// <param name="domainId"></param>
        private void OnErrorGetAllInboxesOffsetPaginatedDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<bool> favourite, Option<string> search, Option<string> tag, Option<bool> teamAccess, Option<DateTime> since, Option<DateTime> before, Option<string> inboxType, Option<string> inboxFunction, Option<Guid> domainId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAllInboxesOffsetPaginated(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="favourite"></param>
        /// <param name="search"></param>
        /// <param name="tag"></param>
        /// <param name="teamAccess"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxType"></param>
        /// <param name="inboxFunction"></param>
        /// <param name="domainId"></param>
        partial void OnErrorGetAllInboxesOffsetPaginated(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<bool> favourite, Option<string> search, Option<string> tag, Option<bool> teamAccess, Option<DateTime> since, Option<DateTime> before, Option<string> inboxType, Option<string> inboxFunction, Option<Guid> domainId);

        /// <summary>
        /// List All Inboxes Offset Paginated List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllInboxesOffsetPaginatedApiResponse"/>&gt;</returns>
        public async Task<IGetAllInboxesOffsetPaginatedApiResponse> GetAllInboxesOffsetPaginatedOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> favourite = default, Option<string> search = default, Option<string> tag = default, Option<bool> teamAccess = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> inboxType = default, Option<string> inboxFunction = default, Option<Guid> domainId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAllInboxesOffsetPaginatedAsync(page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List All Inboxes Offset Paginated List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllInboxesOffsetPaginatedApiResponse"/>&gt;</returns>
        public async Task<IGetAllInboxesOffsetPaginatedApiResponse> GetAllInboxesOffsetPaginatedAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> favourite = default, Option<string> search = default, Option<string> tag = default, Option<bool> teamAccess = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> inboxType = default, Option<string> inboxFunction = default, Option<Guid> domainId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAllInboxesOffsetPaginated(sort, search, tag, inboxType, inboxFunction);

                FormatGetAllInboxesOffsetPaginated(ref page, ref size, ref sort, ref favourite, ref search, ref tag, ref teamAccess, ref since, ref before, ref inboxType, ref inboxFunction, ref domainId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/offset-paginated"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/offset-paginated");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (favourite.IsSet)
                        parseQueryStringLocalVar["favourite"] = ClientUtils.ParameterToString(favourite.Value);

                    if (search.IsSet)
                        parseQueryStringLocalVar["search"] = ClientUtils.ParameterToString(search.Value);

                    if (tag.IsSet)
                        parseQueryStringLocalVar["tag"] = ClientUtils.ParameterToString(tag.Value);

                    if (teamAccess.IsSet)
                        parseQueryStringLocalVar["teamAccess"] = ClientUtils.ParameterToString(teamAccess.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (inboxType.IsSet)
                        parseQueryStringLocalVar["inboxType"] = ClientUtils.ParameterToString(inboxType.Value);

                    if (inboxFunction.IsSet)
                        parseQueryStringLocalVar["inboxFunction"] = ClientUtils.ParameterToString(inboxFunction.Value);

                    if (domainId.IsSet)
                        parseQueryStringLocalVar["domainId"] = ClientUtils.ParameterToString(domainId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetAllInboxesOffsetPaginatedApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAllInboxesOffsetPaginatedApiResponse>();

                        GetAllInboxesOffsetPaginatedApiResponse apiResponseLocalVar = new GetAllInboxesOffsetPaginatedApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/offset-paginated", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAllInboxesOffsetPaginatedDefaultImplementation(apiResponseLocalVar, page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId);

                        Events.ExecuteOnGetAllInboxesOffsetPaginated(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAllInboxesOffsetPaginatedDefaultImplementation(e, "/inboxes/offset-paginated", uriBuilderLocalVar.Path, page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId);
                Events.ExecuteOnErrorGetAllInboxesOffsetPaginated(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAllInboxesOffsetPaginatedApiResponse"/>
        /// </summary>
        public partial class GetAllInboxesOffsetPaginatedApiResponse : mailslurp.Client.ApiResponse, IGetAllInboxesOffsetPaginatedApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAllInboxesOffsetPaginatedApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAllInboxesOffsetPaginatedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAllInboxesOffsetPaginatedApiResponse(ILogger<GetAllInboxesOffsetPaginatedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageInboxProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageInboxProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageInboxProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAllPlusAddresses(ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<Guid> inboxId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateGetAllPlusAddresses(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="inboxId"></param>
        private void AfterGetAllPlusAddressesDefaultImplementation(IGetAllPlusAddressesApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetAllPlusAddresses(ref suppressDefaultLog, apiResponseLocalVar, page, size, sort, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetAllPlusAddresses(ref bool suppressDefaultLog, IGetAllPlusAddressesApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetAllPlusAddressesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAllPlusAddresses(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, page, size, sort, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetAllPlusAddresses(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<Guid> inboxId);

        /// <summary>
        /// Get all sub address plus address aliases for an inbox Returns paginated list of all plus alias addresses found for in account based on received emails that used the inbox address with a +xyz alias.
        /// </summary>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="inboxId">Optional inboxId filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllPlusAddressesApiResponse"/>&gt;</returns>
        public async Task<IGetAllPlusAddressesApiResponse> GetAllPlusAddressesOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAllPlusAddressesAsync(page, size, sort, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all sub address plus address aliases for an inbox Returns paginated list of all plus alias addresses found for in account based on received emails that used the inbox address with a +xyz alias.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="inboxId">Optional inboxId filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllPlusAddressesApiResponse"/>&gt;</returns>
        public async Task<IGetAllPlusAddressesApiResponse> GetAllPlusAddressesAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAllPlusAddresses(sort);

                FormatGetAllPlusAddresses(ref page, ref size, ref sort, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/plus-addresses"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/plus-addresses");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetAllPlusAddressesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAllPlusAddressesApiResponse>();

                        GetAllPlusAddressesApiResponse apiResponseLocalVar = new GetAllPlusAddressesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/plus-addresses", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAllPlusAddressesDefaultImplementation(apiResponseLocalVar, page, size, sort, inboxId);

                        Events.ExecuteOnGetAllPlusAddresses(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAllPlusAddressesDefaultImplementation(e, "/inboxes/plus-addresses", uriBuilderLocalVar.Path, page, size, sort, inboxId);
                Events.ExecuteOnErrorGetAllPlusAddresses(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAllPlusAddressesApiResponse"/>
        /// </summary>
        public partial class GetAllPlusAddressesApiResponse : mailslurp.Client.ApiResponse, IGetAllPlusAddressesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAllPlusAddressesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAllPlusAddressesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAllPlusAddressesApiResponse(ILogger<GetAllPlusAddressesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PagePlusAddressProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PagePlusAddressProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PagePlusAddressProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAllScheduledJobs(ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<DateTime> since, ref Option<DateTime> before, ref Option<Guid> inboxId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateGetAllScheduledJobs(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxId"></param>
        private void AfterGetAllScheduledJobsDefaultImplementation(IGetAllScheduledJobsApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetAllScheduledJobs(ref suppressDefaultLog, apiResponseLocalVar, page, size, sort, since, before, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetAllScheduledJobs(ref bool suppressDefaultLog, IGetAllScheduledJobsApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetAllScheduledJobsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAllScheduledJobs(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, page, size, sort, since, before, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetAllScheduledJobs(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before, Option<Guid> inboxId);

        /// <summary>
        /// Get all scheduled email sending jobs for account Schedule sending of emails using scheduled jobs. These can be inbox or account level.
        /// </summary>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllScheduledJobsApiResponse"/>&gt;</returns>
        public async Task<IGetAllScheduledJobsApiResponse> GetAllScheduledJobsOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAllScheduledJobsAsync(page, size, sort, since, before, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all scheduled email sending jobs for account Schedule sending of emails using scheduled jobs. These can be inbox or account level.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAllScheduledJobsApiResponse"/>&gt;</returns>
        public async Task<IGetAllScheduledJobsApiResponse> GetAllScheduledJobsAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAllScheduledJobs(sort);

                FormatGetAllScheduledJobs(ref page, ref size, ref sort, ref since, ref before, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/scheduled-jobs"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/scheduled-jobs");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetAllScheduledJobsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAllScheduledJobsApiResponse>();

                        GetAllScheduledJobsApiResponse apiResponseLocalVar = new GetAllScheduledJobsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/scheduled-jobs", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAllScheduledJobsDefaultImplementation(apiResponseLocalVar, page, size, sort, since, before, inboxId);

                        Events.ExecuteOnGetAllScheduledJobs(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAllScheduledJobsDefaultImplementation(e, "/inboxes/scheduled-jobs", uriBuilderLocalVar.Path, page, size, sort, since, before, inboxId);
                Events.ExecuteOnErrorGetAllScheduledJobs(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAllScheduledJobsApiResponse"/>
        /// </summary>
        public partial class GetAllScheduledJobsApiResponse : mailslurp.Client.ApiResponse, IGetAllScheduledJobsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAllScheduledJobsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAllScheduledJobsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAllScheduledJobsApiResponse(ILogger<GetAllScheduledJobsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageScheduledJobs Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageScheduledJobs>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageScheduledJobs result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetDeliveryStatusesByInboxId(ref Guid inboxId, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<DateTime> since, ref Option<DateTime> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateGetDeliveryStatusesByInboxId(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void AfterGetDeliveryStatusesByInboxIdDefaultImplementation(IGetDeliveryStatusesByInboxIdApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLog = false;
            AfterGetDeliveryStatusesByInboxId(ref suppressDefaultLog, apiResponseLocalVar, inboxId, page, size, sort, since, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void AfterGetDeliveryStatusesByInboxId(ref bool suppressDefaultLog, IGetDeliveryStatusesByInboxIdApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void OnErrorGetDeliveryStatusesByInboxIdDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetDeliveryStatusesByInboxId(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, page, size, sort, since, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void OnErrorGetDeliveryStatusesByInboxId(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        ///  Get all email delivery statuses for an inbox
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in delivery status list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in delivery status list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDeliveryStatusesByInboxIdApiResponse"/>&gt;</returns>
        public async Task<IGetDeliveryStatusesByInboxIdApiResponse> GetDeliveryStatusesByInboxIdOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetDeliveryStatusesByInboxIdAsync(inboxId, page, size, sort, since, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Get all email delivery statuses for an inbox
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in delivery status list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in delivery status list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDeliveryStatusesByInboxIdApiResponse"/>&gt;</returns>
        public async Task<IGetDeliveryStatusesByInboxIdApiResponse> GetDeliveryStatusesByInboxIdAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetDeliveryStatusesByInboxId(sort);

                FormatGetDeliveryStatusesByInboxId(ref inboxId, ref page, ref size, ref sort, ref since, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/delivery-status"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/delivery-status");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetDeliveryStatusesByInboxIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetDeliveryStatusesByInboxIdApiResponse>();

                        GetDeliveryStatusesByInboxIdApiResponse apiResponseLocalVar = new GetDeliveryStatusesByInboxIdApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/delivery-status", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetDeliveryStatusesByInboxIdDefaultImplementation(apiResponseLocalVar, inboxId, page, size, sort, since, before);

                        Events.ExecuteOnGetDeliveryStatusesByInboxId(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetDeliveryStatusesByInboxIdDefaultImplementation(e, "/inboxes/{inboxId}/delivery-status", uriBuilderLocalVar.Path, inboxId, page, size, sort, since, before);
                Events.ExecuteOnErrorGetDeliveryStatusesByInboxId(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetDeliveryStatusesByInboxIdApiResponse"/>
        /// </summary>
        public partial class GetDeliveryStatusesByInboxIdApiResponse : mailslurp.Client.ApiResponse, IGetDeliveryStatusesByInboxIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetDeliveryStatusesByInboxIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetDeliveryStatusesByInboxIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetDeliveryStatusesByInboxIdApiResponse(ILogger<GetDeliveryStatusesByInboxIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageDeliveryStatus Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageDeliveryStatus>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageDeliveryStatus result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmails(ref Guid inboxId, ref Option<int> size, ref Option<int> limit, ref Option<string> sort, ref Option<long> retryTimeout, ref Option<long> delayTimeout, ref Option<long> minCount, ref Option<bool> unreadOnly, ref Option<DateTime> before, ref Option<DateTime> since);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateGetEmails(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="size"></param>
        /// <param name="limit"></param>
        /// <param name="sort"></param>
        /// <param name="retryTimeout"></param>
        /// <param name="delayTimeout"></param>
        /// <param name="minCount"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        private void AfterGetEmailsDefaultImplementation(IGetEmailsApiResponse apiResponseLocalVar, Guid inboxId, Option<int> size, Option<int> limit, Option<string> sort, Option<long> retryTimeout, Option<long> delayTimeout, Option<long> minCount, Option<bool> unreadOnly, Option<DateTime> before, Option<DateTime> since)
        {
            bool suppressDefaultLog = false;
            AfterGetEmails(ref suppressDefaultLog, apiResponseLocalVar, inboxId, size, limit, sort, retryTimeout, delayTimeout, minCount, unreadOnly, before, since);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="size"></param>
        /// <param name="limit"></param>
        /// <param name="sort"></param>
        /// <param name="retryTimeout"></param>
        /// <param name="delayTimeout"></param>
        /// <param name="minCount"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        partial void AfterGetEmails(ref bool suppressDefaultLog, IGetEmailsApiResponse apiResponseLocalVar, Guid inboxId, Option<int> size, Option<int> limit, Option<string> sort, Option<long> retryTimeout, Option<long> delayTimeout, Option<long> minCount, Option<bool> unreadOnly, Option<DateTime> before, Option<DateTime> since);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="size"></param>
        /// <param name="limit"></param>
        /// <param name="sort"></param>
        /// <param name="retryTimeout"></param>
        /// <param name="delayTimeout"></param>
        /// <param name="minCount"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        private void OnErrorGetEmailsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> size, Option<int> limit, Option<string> sort, Option<long> retryTimeout, Option<long> delayTimeout, Option<long> minCount, Option<bool> unreadOnly, Option<DateTime> before, Option<DateTime> since)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmails(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, size, limit, sort, retryTimeout, delayTimeout, minCount, unreadOnly, before, since);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="size"></param>
        /// <param name="limit"></param>
        /// <param name="sort"></param>
        /// <param name="retryTimeout"></param>
        /// <param name="delayTimeout"></param>
        /// <param name="minCount"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        partial void OnErrorGetEmails(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> size, Option<int> limit, Option<string> sort, Option<long> retryTimeout, Option<long> delayTimeout, Option<long> minCount, Option<bool> unreadOnly, Option<DateTime> before, Option<DateTime> since);

        /// <summary>
        /// Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead. List emails that an inbox has received. Only emails that are sent to the inbox&#39;s email address will appear in the inbox. It may take several seconds for any email you send to an inbox&#39;s email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the &#x60;minCount&#x60; parameter. The server will retry the inbox database until the &#x60;minCount&#x60; is satisfied or the &#x60;retryTimeout&#x60; is reached
        /// </summary>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="size">Alias for limit. Assessed first before assessing any passed limit. (optional)</param>
        /// <param name="limit">Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller (optional)</param>
        /// <param name="sort">Sort the results by received date and direction ASC or DESC (optional)</param>
        /// <param name="retryTimeout">Maximum milliseconds to spend retrying inbox database until minCount emails are returned (optional)</param>
        /// <param name="delayTimeout"> (optional)</param>
        /// <param name="minCount">Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached. (optional)</param>
        /// <param name="unreadOnly"> (optional)</param>
        /// <param name="before">Exclude emails received after this ISO 8601 date time (optional)</param>
        /// <param name="since">Exclude emails received before this ISO 8601 date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailsApiResponse"/>&gt;</returns>
        public async Task<IGetEmailsApiResponse> GetEmailsOrDefaultAsync(Guid inboxId, Option<int> size = default, Option<int> limit = default, Option<string> sort = default, Option<long> retryTimeout = default, Option<long> delayTimeout = default, Option<long> minCount = default, Option<bool> unreadOnly = default, Option<DateTime> before = default, Option<DateTime> since = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailsAsync(inboxId, size, limit, sort, retryTimeout, delayTimeout, minCount, unreadOnly, before, since, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead. List emails that an inbox has received. Only emails that are sent to the inbox&#39;s email address will appear in the inbox. It may take several seconds for any email you send to an inbox&#39;s email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the &#x60;minCount&#x60; parameter. The server will retry the inbox database until the &#x60;minCount&#x60; is satisfied or the &#x60;retryTimeout&#x60; is reached
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="size">Alias for limit. Assessed first before assessing any passed limit. (optional)</param>
        /// <param name="limit">Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller (optional)</param>
        /// <param name="sort">Sort the results by received date and direction ASC or DESC (optional)</param>
        /// <param name="retryTimeout">Maximum milliseconds to spend retrying inbox database until minCount emails are returned (optional)</param>
        /// <param name="delayTimeout"> (optional)</param>
        /// <param name="minCount">Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached. (optional)</param>
        /// <param name="unreadOnly"> (optional)</param>
        /// <param name="before">Exclude emails received after this ISO 8601 date time (optional)</param>
        /// <param name="since">Exclude emails received before this ISO 8601 date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailsApiResponse"/>&gt;</returns>
        public async Task<IGetEmailsApiResponse> GetEmailsAsync(Guid inboxId, Option<int> size = default, Option<int> limit = default, Option<string> sort = default, Option<long> retryTimeout = default, Option<long> delayTimeout = default, Option<long> minCount = default, Option<bool> unreadOnly = default, Option<DateTime> before = default, Option<DateTime> since = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmails(sort);

                FormatGetEmails(ref inboxId, ref size, ref limit, ref sort, ref retryTimeout, ref delayTimeout, ref minCount, ref unreadOnly, ref before, ref since);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/emails"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/emails");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (retryTimeout.IsSet)
                        parseQueryStringLocalVar["retryTimeout"] = ClientUtils.ParameterToString(retryTimeout.Value);

                    if (delayTimeout.IsSet)
                        parseQueryStringLocalVar["delayTimeout"] = ClientUtils.ParameterToString(delayTimeout.Value);

                    if (minCount.IsSet)
                        parseQueryStringLocalVar["minCount"] = ClientUtils.ParameterToString(minCount.Value);

                    if (unreadOnly.IsSet)
                        parseQueryStringLocalVar["unreadOnly"] = ClientUtils.ParameterToString(unreadOnly.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailsApiResponse>();

                        GetEmailsApiResponse apiResponseLocalVar = new GetEmailsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/emails", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailsDefaultImplementation(apiResponseLocalVar, inboxId, size, limit, sort, retryTimeout, delayTimeout, minCount, unreadOnly, before, since);

                        Events.ExecuteOnGetEmails(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailsDefaultImplementation(e, "/inboxes/{inboxId}/emails", uriBuilderLocalVar.Path, inboxId, size, limit, sort, retryTimeout, delayTimeout, minCount, unreadOnly, before, since);
                Events.ExecuteOnErrorGetEmails(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailsApiResponse"/>
        /// </summary>
        public partial class GetEmailsApiResponse : mailslurp.Client.ApiResponse, IGetEmailsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailsApiResponse(ILogger<GetEmailsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<EmailPreview> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<EmailPreview>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out List<EmailPreview> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetImapAccess(ref Option<Guid> inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterGetImapAccessDefaultImplementation(IGetImapAccessApiResponse apiResponseLocalVar, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetImapAccess(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetImapAccess(ref bool suppressDefaultLog, IGetImapAccessApiResponse apiResponseLocalVar, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetImapAccessDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetImapAccess(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetImapAccess(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId);

        /// <summary>
        ///  Get IMAP access usernames and passwords
        /// </summary>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapAccessApiResponse"/>&gt;</returns>
        public async Task<IGetImapAccessApiResponse> GetImapAccessOrDefaultAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetImapAccessAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Get IMAP access usernames and passwords
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapAccessApiResponse"/>&gt;</returns>
        public async Task<IGetImapAccessApiResponse> GetImapAccessAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetImapAccess(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/imap-access"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/imap-access");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetImapAccessApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetImapAccessApiResponse>();

                        GetImapAccessApiResponse apiResponseLocalVar = new GetImapAccessApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/imap-access", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetImapAccessDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnGetImapAccess(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetImapAccessDefaultImplementation(e, "/inboxes/imap-access", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorGetImapAccess(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetImapAccessApiResponse"/>
        /// </summary>
        public partial class GetImapAccessApiResponse : mailslurp.Client.ApiResponse, IGetImapAccessApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetImapAccessApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetImapAccessApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetImapAccessApiResponse(ILogger<GetImapAccessApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ImapAccessDetails Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ImapAccessDetails>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ImapAccessDetails result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetImapSmtpAccess(ref Option<Guid> inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterGetImapSmtpAccessDefaultImplementation(IGetImapSmtpAccessApiResponse apiResponseLocalVar, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetImapSmtpAccess(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetImapSmtpAccess(ref bool suppressDefaultLog, IGetImapSmtpAccessApiResponse apiResponseLocalVar, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetImapSmtpAccessDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetImapSmtpAccess(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetImapSmtpAccess(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId);

        /// <summary>
        ///  Get IMAP and SMTP access usernames and passwords
        /// </summary>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapSmtpAccessApiResponse"/>&gt;</returns>
        public async Task<IGetImapSmtpAccessApiResponse> GetImapSmtpAccessOrDefaultAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetImapSmtpAccessAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Get IMAP and SMTP access usernames and passwords
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapSmtpAccessApiResponse"/>&gt;</returns>
        public async Task<IGetImapSmtpAccessApiResponse> GetImapSmtpAccessAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetImapSmtpAccess(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/imap-smtp-access"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/imap-smtp-access");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetImapSmtpAccessApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetImapSmtpAccessApiResponse>();

                        GetImapSmtpAccessApiResponse apiResponseLocalVar = new GetImapSmtpAccessApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/imap-smtp-access", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetImapSmtpAccessDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnGetImapSmtpAccess(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetImapSmtpAccessDefaultImplementation(e, "/inboxes/imap-smtp-access", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorGetImapSmtpAccess(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetImapSmtpAccessApiResponse"/>
        /// </summary>
        public partial class GetImapSmtpAccessApiResponse : mailslurp.Client.ApiResponse, IGetImapSmtpAccessApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetImapSmtpAccessApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetImapSmtpAccessApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetImapSmtpAccessApiResponse(ILogger<GetImapSmtpAccessApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ImapSmtpAccessDetails Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ImapSmtpAccessDetails>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ImapSmtpAccessDetails result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetImapSmtpAccessEnv(ref Option<Guid> inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterGetImapSmtpAccessEnvDefaultImplementation(IGetImapSmtpAccessEnvApiResponse apiResponseLocalVar, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetImapSmtpAccessEnv(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetImapSmtpAccessEnv(ref bool suppressDefaultLog, IGetImapSmtpAccessEnvApiResponse apiResponseLocalVar, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetImapSmtpAccessEnvDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetImapSmtpAccessEnv(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetImapSmtpAccessEnv(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId);

        /// <summary>
        ///  Get IMAP and SMTP access details in .env format
        /// </summary>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapSmtpAccessEnvApiResponse"/>&gt;</returns>
        public async Task<IGetImapSmtpAccessEnvApiResponse> GetImapSmtpAccessEnvOrDefaultAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetImapSmtpAccessEnvAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Get IMAP and SMTP access details in .env format
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapSmtpAccessEnvApiResponse"/>&gt;</returns>
        public async Task<IGetImapSmtpAccessEnvApiResponse> GetImapSmtpAccessEnvAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetImapSmtpAccessEnv(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/imap-smtp-access/env"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/imap-smtp-access/env");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetImapSmtpAccessEnvApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetImapSmtpAccessEnvApiResponse>();

                        GetImapSmtpAccessEnvApiResponse apiResponseLocalVar = new GetImapSmtpAccessEnvApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/imap-smtp-access/env", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetImapSmtpAccessEnvDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnGetImapSmtpAccessEnv(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetImapSmtpAccessEnvDefaultImplementation(e, "/inboxes/imap-smtp-access/env", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorGetImapSmtpAccessEnv(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetImapSmtpAccessEnvApiResponse"/>
        /// </summary>
        public partial class GetImapSmtpAccessEnvApiResponse : mailslurp.Client.ApiResponse, IGetImapSmtpAccessEnvApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetImapSmtpAccessEnvApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetImapSmtpAccessEnvApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetImapSmtpAccessEnvApiResponse(ILogger<GetImapSmtpAccessEnvApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public string Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<string>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out string result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetImapSmtpAccessServersDefaultImplementation(IGetImapSmtpAccessServersApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetImapSmtpAccessServers(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetImapSmtpAccessServers(ref bool suppressDefaultLog, IGetImapSmtpAccessServersApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetImapSmtpAccessServersDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetImapSmtpAccessServers(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetImapSmtpAccessServers(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        ///  Get IMAP and SMTP server hosts
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapSmtpAccessServersApiResponse"/>&gt;</returns>
        public async Task<IGetImapSmtpAccessServersApiResponse> GetImapSmtpAccessServersOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetImapSmtpAccessServersAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Get IMAP and SMTP server hosts
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetImapSmtpAccessServersApiResponse"/>&gt;</returns>
        public async Task<IGetImapSmtpAccessServersApiResponse> GetImapSmtpAccessServersAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/imap-smtp-access/servers"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/imap-smtp-access/servers");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetImapSmtpAccessServersApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetImapSmtpAccessServersApiResponse>();

                        GetImapSmtpAccessServersApiResponse apiResponseLocalVar = new GetImapSmtpAccessServersApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/imap-smtp-access/servers", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetImapSmtpAccessServersDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetImapSmtpAccessServers(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetImapSmtpAccessServersDefaultImplementation(e, "/inboxes/imap-smtp-access/servers", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetImapSmtpAccessServers(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetImapSmtpAccessServersApiResponse"/>
        /// </summary>
        public partial class GetImapSmtpAccessServersApiResponse : mailslurp.Client.ApiResponse, IGetImapSmtpAccessServersApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetImapSmtpAccessServersApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetImapSmtpAccessServersApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetImapSmtpAccessServersApiResponse(ILogger<GetImapSmtpAccessServersApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ImapSmtpAccessServers Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ImapSmtpAccessServers>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ImapSmtpAccessServers result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInbox(ref Guid inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterGetInboxDefaultImplementation(IGetInboxApiResponse apiResponseLocalVar, Guid inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetInbox(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetInbox(ref bool suppressDefaultLog, IGetInboxApiResponse apiResponseLocalVar, Guid inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetInboxDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInbox(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetInbox(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId);

        /// <summary>
        /// Get Inbox. Returns properties of an inbox. Returns an inbox&#39;s properties, including its email address and ID.
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxApiResponse"/>&gt;</returns>
        public async Task<IGetInboxApiResponse> GetInboxOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Inbox. Returns properties of an inbox. Returns an inbox&#39;s properties, including its email address and ID.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxApiResponse"/>&gt;</returns>
        public async Task<IGetInboxApiResponse> GetInboxAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetInbox(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxApiResponse>();

                        GetInboxApiResponse apiResponseLocalVar = new GetInboxApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnGetInbox(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxDefaultImplementation(e, "/inboxes/{inboxId}", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorGetInbox(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxApiResponse"/>
        /// </summary>
        public partial class GetInboxApiResponse : mailslurp.Client.ApiResponse, IGetInboxApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxApiResponse(ILogger<GetInboxApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.InboxDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxByEmailAddress(ref string emailAddress);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="emailAddress"></param>
        /// <returns></returns>
        private void ValidateGetInboxByEmailAddress(string emailAddress)
        {
            if (emailAddress == null)
                throw new ArgumentNullException(nameof(emailAddress));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailAddress"></param>
        private void AfterGetInboxByEmailAddressDefaultImplementation(IGetInboxByEmailAddressApiResponse apiResponseLocalVar, string emailAddress)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxByEmailAddress(ref suppressDefaultLog, apiResponseLocalVar, emailAddress);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailAddress"></param>
        partial void AfterGetInboxByEmailAddress(ref bool suppressDefaultLog, IGetInboxByEmailAddressApiResponse apiResponseLocalVar, string emailAddress);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailAddress"></param>
        private void OnErrorGetInboxByEmailAddressDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string emailAddress)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxByEmailAddress(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailAddress);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailAddress"></param>
        partial void OnErrorGetInboxByEmailAddress(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string emailAddress);

        /// <summary>
        /// Search for an inbox with the provided email address Get a inbox result by email address
        /// </summary>
        /// <param name="emailAddress"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxByEmailAddressApiResponse"/>&gt;</returns>
        public async Task<IGetInboxByEmailAddressApiResponse> GetInboxByEmailAddressOrDefaultAsync(string emailAddress, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxByEmailAddressAsync(emailAddress, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search for an inbox with the provided email address Get a inbox result by email address
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxByEmailAddressApiResponse"/>&gt;</returns>
        public async Task<IGetInboxByEmailAddressApiResponse> GetInboxByEmailAddressAsync(string emailAddress, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetInboxByEmailAddress(emailAddress);

                FormatGetInboxByEmailAddress(ref emailAddress);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/byEmailAddress"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/byEmailAddress");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["emailAddress"] = ClientUtils.ParameterToString(emailAddress);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxByEmailAddressApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxByEmailAddressApiResponse>();

                        GetInboxByEmailAddressApiResponse apiResponseLocalVar = new GetInboxByEmailAddressApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/byEmailAddress", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxByEmailAddressDefaultImplementation(apiResponseLocalVar, emailAddress);

                        Events.ExecuteOnGetInboxByEmailAddress(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxByEmailAddressDefaultImplementation(e, "/inboxes/byEmailAddress", uriBuilderLocalVar.Path, emailAddress);
                Events.ExecuteOnErrorGetInboxByEmailAddress(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxByEmailAddressApiResponse"/>
        /// </summary>
        public partial class GetInboxByEmailAddressApiResponse : mailslurp.Client.ApiResponse, IGetInboxByEmailAddressApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxByEmailAddressApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxByEmailAddressApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxByEmailAddressApiResponse(ILogger<GetInboxByEmailAddressApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxByEmailAddressResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxByEmailAddressResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.InboxByEmailAddressResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxByName(ref string name);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        private void ValidateGetInboxByName(string name)
        {
            if (name == null)
                throw new ArgumentNullException(nameof(name));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        private void AfterGetInboxByNameDefaultImplementation(IGetInboxByNameApiResponse apiResponseLocalVar, string name)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxByName(ref suppressDefaultLog, apiResponseLocalVar, name);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        partial void AfterGetInboxByName(ref bool suppressDefaultLog, IGetInboxByNameApiResponse apiResponseLocalVar, string name);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        private void OnErrorGetInboxByNameDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string name)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxByName(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, name);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        partial void OnErrorGetInboxByName(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string name);

        /// <summary>
        /// Search for an inbox with the given name Get a inbox result by name
        /// </summary>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxByNameApiResponse"/>&gt;</returns>
        public async Task<IGetInboxByNameApiResponse> GetInboxByNameOrDefaultAsync(string name, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxByNameAsync(name, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search for an inbox with the given name Get a inbox result by name
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxByNameApiResponse"/>&gt;</returns>
        public async Task<IGetInboxByNameApiResponse> GetInboxByNameAsync(string name, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetInboxByName(name);

                FormatGetInboxByName(ref name);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/byName"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/byName");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxByNameApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxByNameApiResponse>();

                        GetInboxByNameApiResponse apiResponseLocalVar = new GetInboxByNameApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/byName", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxByNameDefaultImplementation(apiResponseLocalVar, name);

                        Events.ExecuteOnGetInboxByName(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxByNameDefaultImplementation(e, "/inboxes/byName", uriBuilderLocalVar.Path, name);
                Events.ExecuteOnErrorGetInboxByName(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxByNameApiResponse"/>
        /// </summary>
        public partial class GetInboxByNameApiResponse : mailslurp.Client.ApiResponse, IGetInboxByNameApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxByNameApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxByNameApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxByNameApiResponse(ILogger<GetInboxByNameApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxByNameResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxByNameResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.InboxByNameResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetInboxCountDefaultImplementation(IGetInboxCountApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxCount(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetInboxCount(ref bool suppressDefaultLog, IGetInboxCountApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetInboxCountDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxCount(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetInboxCount(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Get total inbox count 
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxCountApiResponse"/>&gt;</returns>
        public async Task<IGetInboxCountApiResponse> GetInboxCountOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxCountAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get total inbox count 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxCountApiResponse"/>&gt;</returns>
        public async Task<IGetInboxCountApiResponse> GetInboxCountAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/count"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/count");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxCountApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxCountApiResponse>();

                        GetInboxCountApiResponse apiResponseLocalVar = new GetInboxCountApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/count", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxCountDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetInboxCount(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxCountDefaultImplementation(e, "/inboxes/count", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetInboxCount(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxCountApiResponse"/>
        /// </summary>
        public partial class GetInboxCountApiResponse : mailslurp.Client.ApiResponse, IGetInboxCountApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxCountApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxCountApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxCountApiResponse(ILogger<GetInboxCountApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.CountDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.CountDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.CountDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxEmailCount(ref Guid inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterGetInboxEmailCountDefaultImplementation(IGetInboxEmailCountApiResponse apiResponseLocalVar, Guid inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxEmailCount(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetInboxEmailCount(ref bool suppressDefaultLog, IGetInboxEmailCountApiResponse apiResponseLocalVar, Guid inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetInboxEmailCountDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxEmailCount(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetInboxEmailCount(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId);

        /// <summary>
        /// Get email count in inbox 
        /// </summary>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxEmailCountApiResponse"/>&gt;</returns>
        public async Task<IGetInboxEmailCountApiResponse> GetInboxEmailCountOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxEmailCountAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email count in inbox 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxEmailCountApiResponse"/>&gt;</returns>
        public async Task<IGetInboxEmailCountApiResponse> GetInboxEmailCountAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetInboxEmailCount(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/emails/count"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/emails/count");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxEmailCountApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxEmailCountApiResponse>();

                        GetInboxEmailCountApiResponse apiResponseLocalVar = new GetInboxEmailCountApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/emails/count", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxEmailCountDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnGetInboxEmailCount(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxEmailCountDefaultImplementation(e, "/inboxes/{inboxId}/emails/count", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorGetInboxEmailCount(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxEmailCountApiResponse"/>
        /// </summary>
        public partial class GetInboxEmailCountApiResponse : mailslurp.Client.ApiResponse, IGetInboxEmailCountApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxEmailCountApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxEmailCountApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxEmailCountApiResponse(ILogger<GetInboxEmailCountApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.CountDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.CountDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.CountDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxEmailsPaginated(ref Guid inboxId, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<DateTime> since, ref Option<DateTime> before, ref Option<bool> syncConnectors);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateGetInboxEmailsPaginated(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="syncConnectors"></param>
        private void AfterGetInboxEmailsPaginatedDefaultImplementation(IGetInboxEmailsPaginatedApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before, Option<bool> syncConnectors)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxEmailsPaginated(ref suppressDefaultLog, apiResponseLocalVar, inboxId, page, size, sort, since, before, syncConnectors);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="syncConnectors"></param>
        partial void AfterGetInboxEmailsPaginated(ref bool suppressDefaultLog, IGetInboxEmailsPaginatedApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before, Option<bool> syncConnectors);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="syncConnectors"></param>
        private void OnErrorGetInboxEmailsPaginatedDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before, Option<bool> syncConnectors)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxEmailsPaginated(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, page, size, sort, since, before, syncConnectors);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="syncConnectors"></param>
        partial void OnErrorGetInboxEmailsPaginated(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before, Option<bool> syncConnectors);

        /// <summary>
        /// Get inbox emails paginated Get a paginated list of emails in an inbox. Does not hold connections open.
        /// </summary>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="page">Optional page index in inbox emails list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox emails list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by received after given date time (optional)</param>
        /// <param name="before">Optional filter by received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors before fetching emails (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxEmailsPaginatedApiResponse"/>&gt;</returns>
        public async Task<IGetInboxEmailsPaginatedApiResponse> GetInboxEmailsPaginatedOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> syncConnectors = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxEmailsPaginatedAsync(inboxId, page, size, sort, since, before, syncConnectors, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get inbox emails paginated Get a paginated list of emails in an inbox. Does not hold connections open.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="page">Optional page index in inbox emails list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox emails list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by received after given date time (optional)</param>
        /// <param name="before">Optional filter by received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors before fetching emails (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxEmailsPaginatedApiResponse"/>&gt;</returns>
        public async Task<IGetInboxEmailsPaginatedApiResponse> GetInboxEmailsPaginatedAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> syncConnectors = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetInboxEmailsPaginated(sort);

                FormatGetInboxEmailsPaginated(ref inboxId, ref page, ref size, ref sort, ref since, ref before, ref syncConnectors);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/emails/paginated"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/emails/paginated");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (syncConnectors.IsSet)
                        parseQueryStringLocalVar["syncConnectors"] = ClientUtils.ParameterToString(syncConnectors.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxEmailsPaginatedApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxEmailsPaginatedApiResponse>();

                        GetInboxEmailsPaginatedApiResponse apiResponseLocalVar = new GetInboxEmailsPaginatedApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/emails/paginated", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxEmailsPaginatedDefaultImplementation(apiResponseLocalVar, inboxId, page, size, sort, since, before, syncConnectors);

                        Events.ExecuteOnGetInboxEmailsPaginated(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxEmailsPaginatedDefaultImplementation(e, "/inboxes/{inboxId}/emails/paginated", uriBuilderLocalVar.Path, inboxId, page, size, sort, since, before, syncConnectors);
                Events.ExecuteOnErrorGetInboxEmailsPaginated(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxEmailsPaginatedApiResponse"/>
        /// </summary>
        public partial class GetInboxEmailsPaginatedApiResponse : mailslurp.Client.ApiResponse, IGetInboxEmailsPaginatedApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxEmailsPaginatedApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxEmailsPaginatedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxEmailsPaginatedApiResponse(ILogger<GetInboxEmailsPaginatedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageEmailPreview Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageEmailPreview>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageEmailPreview result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetInboxIdsDefaultImplementation(IGetInboxIdsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxIds(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetInboxIds(ref bool suppressDefaultLog, IGetInboxIdsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetInboxIdsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxIds(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetInboxIds(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Get all inbox IDs Get list of inbox IDs
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxIdsApiResponse"/>&gt;</returns>
        public async Task<IGetInboxIdsApiResponse> GetInboxIdsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxIdsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all inbox IDs Get list of inbox IDs
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxIdsApiResponse"/>&gt;</returns>
        public async Task<IGetInboxIdsApiResponse> GetInboxIdsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/ids"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/ids");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxIdsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxIdsApiResponse>();

                        GetInboxIdsApiResponse apiResponseLocalVar = new GetInboxIdsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/ids", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxIdsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetInboxIds(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxIdsDefaultImplementation(e, "/inboxes/ids", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetInboxIds(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxIdsApiResponse"/>
        /// </summary>
        public partial class GetInboxIdsApiResponse : mailslurp.Client.ApiResponse, IGetInboxIdsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxIdsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxIdsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxIdsApiResponse(ILogger<GetInboxIdsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxIdsResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxIdsResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.InboxIdsResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxPlusAddress(ref Guid plusAddressId, ref Guid inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="inboxId"></param>
        private void AfterGetInboxPlusAddressDefaultImplementation(IGetInboxPlusAddressApiResponse apiResponseLocalVar, Guid plusAddressId, Guid inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxPlusAddress(ref suppressDefaultLog, apiResponseLocalVar, plusAddressId, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetInboxPlusAddress(ref bool suppressDefaultLog, IGetInboxPlusAddressApiResponse apiResponseLocalVar, Guid plusAddressId, Guid inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetInboxPlusAddressDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid plusAddressId, Guid inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxPlusAddress(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, plusAddressId, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetInboxPlusAddress(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid plusAddressId, Guid inboxId);

        /// <summary>
        /// Get sub address plus address for an inbox Returns a plus address object based on emails that used the inbox address with a +xyz alias.
        /// </summary>
        /// <param name="plusAddressId">ID of the plus address you want to fetch</param>
        /// <param name="inboxId">ID of the inbox you want to fetch</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressApiResponse"/>&gt;</returns>
        public async Task<IGetInboxPlusAddressApiResponse> GetInboxPlusAddressOrDefaultAsync(Guid plusAddressId, Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxPlusAddressAsync(plusAddressId, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get sub address plus address for an inbox Returns a plus address object based on emails that used the inbox address with a +xyz alias.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="plusAddressId">ID of the plus address you want to fetch</param>
        /// <param name="inboxId">ID of the inbox you want to fetch</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressApiResponse"/>&gt;</returns>
        public async Task<IGetInboxPlusAddressApiResponse> GetInboxPlusAddressAsync(Guid plusAddressId, Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetInboxPlusAddress(ref plusAddressId, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/plus-addresses/{plusAddressId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/plus-addresses/{plusAddressId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BplusAddressId%7D", Uri.EscapeDataString(plusAddressId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxPlusAddressApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxPlusAddressApiResponse>();

                        GetInboxPlusAddressApiResponse apiResponseLocalVar = new GetInboxPlusAddressApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/plus-addresses/{plusAddressId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxPlusAddressDefaultImplementation(apiResponseLocalVar, plusAddressId, inboxId);

                        Events.ExecuteOnGetInboxPlusAddress(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxPlusAddressDefaultImplementation(e, "/inboxes/{inboxId}/plus-addresses/{plusAddressId}", uriBuilderLocalVar.Path, plusAddressId, inboxId);
                Events.ExecuteOnErrorGetInboxPlusAddress(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxPlusAddressApiResponse"/>
        /// </summary>
        public partial class GetInboxPlusAddressApiResponse : mailslurp.Client.ApiResponse, IGetInboxPlusAddressApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxPlusAddressApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxPlusAddressApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxPlusAddressApiResponse(ILogger<GetInboxPlusAddressApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PlusAddressDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PlusAddressDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PlusAddressDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxPlusAddressById(ref Guid plusAddressId, ref Option<Guid> inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="inboxId"></param>
        private void AfterGetInboxPlusAddressByIdDefaultImplementation(IGetInboxPlusAddressByIdApiResponse apiResponseLocalVar, Guid plusAddressId, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxPlusAddressById(ref suppressDefaultLog, apiResponseLocalVar, plusAddressId, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetInboxPlusAddressById(ref bool suppressDefaultLog, IGetInboxPlusAddressByIdApiResponse apiResponseLocalVar, Guid plusAddressId, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetInboxPlusAddressByIdDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid plusAddressId, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxPlusAddressById(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, plusAddressId, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetInboxPlusAddressById(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid plusAddressId, Option<Guid> inboxId);

        /// <summary>
        /// Get sub address plus address by ID Returns a plus address object based on emails that used the inbox address with a +xyz alias.
        /// </summary>
        /// <param name="plusAddressId">ID of the plus address you want to fetch</param>
        /// <param name="inboxId">ID of the inbox you want to filter for (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressByIdApiResponse"/>&gt;</returns>
        public async Task<IGetInboxPlusAddressByIdApiResponse> GetInboxPlusAddressByIdOrDefaultAsync(Guid plusAddressId, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxPlusAddressByIdAsync(plusAddressId, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get sub address plus address by ID Returns a plus address object based on emails that used the inbox address with a +xyz alias.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="plusAddressId">ID of the plus address you want to fetch</param>
        /// <param name="inboxId">ID of the inbox you want to filter for (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressByIdApiResponse"/>&gt;</returns>
        public async Task<IGetInboxPlusAddressByIdApiResponse> GetInboxPlusAddressByIdAsync(Guid plusAddressId, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetInboxPlusAddressById(ref plusAddressId, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/plus-addresses/{plusAddressId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/plus-addresses/{plusAddressId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BplusAddressId%7D", Uri.EscapeDataString(plusAddressId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxPlusAddressByIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxPlusAddressByIdApiResponse>();

                        GetInboxPlusAddressByIdApiResponse apiResponseLocalVar = new GetInboxPlusAddressByIdApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/plus-addresses/{plusAddressId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxPlusAddressByIdDefaultImplementation(apiResponseLocalVar, plusAddressId, inboxId);

                        Events.ExecuteOnGetInboxPlusAddressById(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxPlusAddressByIdDefaultImplementation(e, "/inboxes/plus-addresses/{plusAddressId}", uriBuilderLocalVar.Path, plusAddressId, inboxId);
                Events.ExecuteOnErrorGetInboxPlusAddressById(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxPlusAddressByIdApiResponse"/>
        /// </summary>
        public partial class GetInboxPlusAddressByIdApiResponse : mailslurp.Client.ApiResponse, IGetInboxPlusAddressByIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxPlusAddressByIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxPlusAddressByIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxPlusAddressByIdApiResponse(ILogger<GetInboxPlusAddressByIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PlusAddressDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PlusAddressDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PlusAddressDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxPlusAddressEmails(ref string plusAddress, ref Guid inboxId, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<DateTime> since, ref Option<DateTime> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="plusAddress"></param>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateGetInboxPlusAddressEmails(string plusAddress, Option<string> sort)
        {
            if (plusAddress == null)
                throw new ArgumentNullException(nameof(plusAddress));

            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="plusAddress"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void AfterGetInboxPlusAddressEmailsDefaultImplementation(IGetInboxPlusAddressEmailsApiResponse apiResponseLocalVar, string plusAddress, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxPlusAddressEmails(ref suppressDefaultLog, apiResponseLocalVar, plusAddress, inboxId, page, size, sort, since, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="plusAddress"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void AfterGetInboxPlusAddressEmails(ref bool suppressDefaultLog, IGetInboxPlusAddressEmailsApiResponse apiResponseLocalVar, string plusAddress, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="plusAddress"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void OnErrorGetInboxPlusAddressEmailsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string plusAddress, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxPlusAddressEmails(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, plusAddress, inboxId, page, size, sort, since, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="plusAddress"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void OnErrorGetInboxPlusAddressEmails(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string plusAddress, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Get emails for a given inbox plus address Returns paginated list of all emails for a given plus alias addresses found for an inbox based on received emails that used the inbox address with a +xyz alias.
        /// </summary>
        /// <param name="plusAddress">The plus address to fetch emails for. If your inbox address is &#x60;123@test.com&#x60; and the email was sent to &#x60;123+abc@test.com&#x60; then the plus address is &#x60;abc&#x60;</param>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressEmailsApiResponse"/>&gt;</returns>
        public async Task<IGetInboxPlusAddressEmailsApiResponse> GetInboxPlusAddressEmailsOrDefaultAsync(string plusAddress, Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxPlusAddressEmailsAsync(plusAddress, inboxId, page, size, sort, since, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get emails for a given inbox plus address Returns paginated list of all emails for a given plus alias addresses found for an inbox based on received emails that used the inbox address with a +xyz alias.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="plusAddress">The plus address to fetch emails for. If your inbox address is &#x60;123@test.com&#x60; and the email was sent to &#x60;123+abc@test.com&#x60; then the plus address is &#x60;abc&#x60;</param>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressEmailsApiResponse"/>&gt;</returns>
        public async Task<IGetInboxPlusAddressEmailsApiResponse> GetInboxPlusAddressEmailsAsync(string plusAddress, Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetInboxPlusAddressEmails(plusAddress, sort);

                FormatGetInboxPlusAddressEmails(ref plusAddress, ref inboxId, ref page, ref size, ref sort, ref since, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/plus-addresses/emails"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/plus-addresses/emails");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["plusAddress"] = ClientUtils.ParameterToString(plusAddress);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxPlusAddressEmailsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxPlusAddressEmailsApiResponse>();

                        GetInboxPlusAddressEmailsApiResponse apiResponseLocalVar = new GetInboxPlusAddressEmailsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/plus-addresses/emails", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxPlusAddressEmailsDefaultImplementation(apiResponseLocalVar, plusAddress, inboxId, page, size, sort, since, before);

                        Events.ExecuteOnGetInboxPlusAddressEmails(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxPlusAddressEmailsDefaultImplementation(e, "/inboxes/{inboxId}/plus-addresses/emails", uriBuilderLocalVar.Path, plusAddress, inboxId, page, size, sort, since, before);
                Events.ExecuteOnErrorGetInboxPlusAddressEmails(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxPlusAddressEmailsApiResponse"/>
        /// </summary>
        public partial class GetInboxPlusAddressEmailsApiResponse : mailslurp.Client.ApiResponse, IGetInboxPlusAddressEmailsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxPlusAddressEmailsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxPlusAddressEmailsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxPlusAddressEmailsApiResponse(ILogger<GetInboxPlusAddressEmailsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageEmailPreview Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageEmailPreview>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageEmailPreview result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxPlusAddressEmailsForPlusAddressId(ref Guid plusAddressId, ref Guid inboxId, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<DateTime> since, ref Option<DateTime> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateGetInboxPlusAddressEmailsForPlusAddressId(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void AfterGetInboxPlusAddressEmailsForPlusAddressIdDefaultImplementation(IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse apiResponseLocalVar, Guid plusAddressId, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxPlusAddressEmailsForPlusAddressId(ref suppressDefaultLog, apiResponseLocalVar, plusAddressId, inboxId, page, size, sort, since, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void AfterGetInboxPlusAddressEmailsForPlusAddressId(ref bool suppressDefaultLog, IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse apiResponseLocalVar, Guid plusAddressId, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void OnErrorGetInboxPlusAddressEmailsForPlusAddressIdDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid plusAddressId, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxPlusAddressEmailsForPlusAddressId(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, plusAddressId, inboxId, page, size, sort, since, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void OnErrorGetInboxPlusAddressEmailsForPlusAddressId(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid plusAddressId, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Get emails for a given inbox plus address Returns paginated list of all emails for a given plus alias addresses found for an inbox based on received emails that used the inbox address with a +xyz alias.
        /// </summary>
        /// <param name="plusAddressId">The plus address ID to fetch emails for.</param>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse"/>&gt;</returns>
        public async Task<IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse> GetInboxPlusAddressEmailsForPlusAddressIdOrDefaultAsync(Guid plusAddressId, Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxPlusAddressEmailsForPlusAddressIdAsync(plusAddressId, inboxId, page, size, sort, since, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get emails for a given inbox plus address Returns paginated list of all emails for a given plus alias addresses found for an inbox based on received emails that used the inbox address with a +xyz alias.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="plusAddressId">The plus address ID to fetch emails for.</param>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse"/>&gt;</returns>
        public async Task<IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse> GetInboxPlusAddressEmailsForPlusAddressIdAsync(Guid plusAddressId, Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetInboxPlusAddressEmailsForPlusAddressId(sort);

                FormatGetInboxPlusAddressEmailsForPlusAddressId(ref plusAddressId, ref inboxId, ref page, ref size, ref sort, ref since, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/plus-addresses/{plusAddressId}/emails"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/plus-addresses/{plusAddressId}/emails");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BplusAddressId%7D", Uri.EscapeDataString(plusAddressId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxPlusAddressEmailsForPlusAddressIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxPlusAddressEmailsForPlusAddressIdApiResponse>();

                        GetInboxPlusAddressEmailsForPlusAddressIdApiResponse apiResponseLocalVar = new GetInboxPlusAddressEmailsForPlusAddressIdApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/plus-addresses/{plusAddressId}/emails", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxPlusAddressEmailsForPlusAddressIdDefaultImplementation(apiResponseLocalVar, plusAddressId, inboxId, page, size, sort, since, before);

                        Events.ExecuteOnGetInboxPlusAddressEmailsForPlusAddressId(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxPlusAddressEmailsForPlusAddressIdDefaultImplementation(e, "/inboxes/{inboxId}/plus-addresses/{plusAddressId}/emails", uriBuilderLocalVar.Path, plusAddressId, inboxId, page, size, sort, since, before);
                Events.ExecuteOnErrorGetInboxPlusAddressEmailsForPlusAddressId(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxPlusAddressEmailsForPlusAddressIdApiResponse"/>
        /// </summary>
        public partial class GetInboxPlusAddressEmailsForPlusAddressIdApiResponse : mailslurp.Client.ApiResponse, IGetInboxPlusAddressEmailsForPlusAddressIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxPlusAddressEmailsForPlusAddressIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxPlusAddressEmailsForPlusAddressIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxPlusAddressEmailsForPlusAddressIdApiResponse(ILogger<GetInboxPlusAddressEmailsForPlusAddressIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageEmailPreview Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageEmailPreview>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageEmailPreview result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxPlusAddresses(ref Guid inboxId, ref Option<int> page, ref Option<int> size, ref Option<string> sort);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateGetInboxPlusAddresses(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        private void AfterGetInboxPlusAddressesDefaultImplementation(IGetInboxPlusAddressesApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxPlusAddresses(ref suppressDefaultLog, apiResponseLocalVar, inboxId, page, size, sort);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        partial void AfterGetInboxPlusAddresses(ref bool suppressDefaultLog, IGetInboxPlusAddressesApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        private void OnErrorGetInboxPlusAddressesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxPlusAddresses(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, page, size, sort);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        partial void OnErrorGetInboxPlusAddresses(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort);

        /// <summary>
        /// Get sub address plus address aliases for an inbox Returns paginated list of all plus alias addresses found for an inbox based on received emails that used the inbox address with a +xyz alias.
        /// </summary>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressesApiResponse"/>&gt;</returns>
        public async Task<IGetInboxPlusAddressesApiResponse> GetInboxPlusAddressesOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxPlusAddressesAsync(inboxId, page, size, sort, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get sub address plus address aliases for an inbox Returns paginated list of all plus alias addresses found for an inbox based on received emails that used the inbox address with a +xyz alias.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxPlusAddressesApiResponse"/>&gt;</returns>
        public async Task<IGetInboxPlusAddressesApiResponse> GetInboxPlusAddressesAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetInboxPlusAddresses(sort);

                FormatGetInboxPlusAddresses(ref inboxId, ref page, ref size, ref sort);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/plus-addresses"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/plus-addresses");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxPlusAddressesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxPlusAddressesApiResponse>();

                        GetInboxPlusAddressesApiResponse apiResponseLocalVar = new GetInboxPlusAddressesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/plus-addresses", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxPlusAddressesDefaultImplementation(apiResponseLocalVar, inboxId, page, size, sort);

                        Events.ExecuteOnGetInboxPlusAddresses(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxPlusAddressesDefaultImplementation(e, "/inboxes/{inboxId}/plus-addresses", uriBuilderLocalVar.Path, inboxId, page, size, sort);
                Events.ExecuteOnErrorGetInboxPlusAddresses(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxPlusAddressesApiResponse"/>
        /// </summary>
        public partial class GetInboxPlusAddressesApiResponse : mailslurp.Client.ApiResponse, IGetInboxPlusAddressesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxPlusAddressesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxPlusAddressesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxPlusAddressesApiResponse(ILogger<GetInboxPlusAddressesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PagePlusAddressProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PagePlusAddressProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PagePlusAddressProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxSentCount(ref Guid inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterGetInboxSentCountDefaultImplementation(IGetInboxSentCountApiResponse apiResponseLocalVar, Guid inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxSentCount(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetInboxSentCount(ref bool suppressDefaultLog, IGetInboxSentCountApiResponse apiResponseLocalVar, Guid inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetInboxSentCountDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxSentCount(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetInboxSentCount(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId);

        /// <summary>
        /// Get sent email count in inbox 
        /// </summary>
        /// <param name="inboxId">Id of inbox that emails were sent from</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxSentCountApiResponse"/>&gt;</returns>
        public async Task<IGetInboxSentCountApiResponse> GetInboxSentCountOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxSentCountAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get sent email count in inbox 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails were sent from</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxSentCountApiResponse"/>&gt;</returns>
        public async Task<IGetInboxSentCountApiResponse> GetInboxSentCountAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetInboxSentCount(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/sent/count"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/sent/count");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxSentCountApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxSentCountApiResponse>();

                        GetInboxSentCountApiResponse apiResponseLocalVar = new GetInboxSentCountApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/sent/count", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxSentCountDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnGetInboxSentCount(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxSentCountDefaultImplementation(e, "/inboxes/{inboxId}/sent/count", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorGetInboxSentCount(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxSentCountApiResponse"/>
        /// </summary>
        public partial class GetInboxSentCountApiResponse : mailslurp.Client.ApiResponse, IGetInboxSentCountApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxSentCountApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxSentCountApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxSentCountApiResponse(ILogger<GetInboxSentCountApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.CountDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.CountDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.CountDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxSentEmails(ref Guid inboxId, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<string> searchFilter, ref Option<DateTime> since, ref Option<DateTime> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <returns></returns>
        private void ValidateGetInboxSentEmails(Option<string> sort, Option<string> searchFilter)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (searchFilter.IsSet && searchFilter.Value == null)
                throw new ArgumentNullException(nameof(searchFilter));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void AfterGetInboxSentEmailsDefaultImplementation(IGetInboxSentEmailsApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxSentEmails(ref suppressDefaultLog, apiResponseLocalVar, inboxId, page, size, sort, searchFilter, since, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void AfterGetInboxSentEmails(ref bool suppressDefaultLog, IGetInboxSentEmailsApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void OnErrorGetInboxSentEmailsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxSentEmails(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, page, size, sort, searchFilter, since, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void OnErrorGetInboxSentEmails(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Get Inbox Sent Emails Returns an inbox&#39;s sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional sent email search (optional)</param>
        /// <param name="since">Optional filter by sent after given date time (optional)</param>
        /// <param name="before">Optional filter by sent before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxSentEmailsApiResponse"/>&gt;</returns>
        public async Task<IGetInboxSentEmailsApiResponse> GetInboxSentEmailsOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxSentEmailsAsync(inboxId, page, size, sort, searchFilter, since, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Inbox Sent Emails Returns an inbox&#39;s sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional sent email search (optional)</param>
        /// <param name="since">Optional filter by sent after given date time (optional)</param>
        /// <param name="before">Optional filter by sent before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxSentEmailsApiResponse"/>&gt;</returns>
        public async Task<IGetInboxSentEmailsApiResponse> GetInboxSentEmailsAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetInboxSentEmails(sort, searchFilter);

                FormatGetInboxSentEmails(ref inboxId, ref page, ref size, ref sort, ref searchFilter, ref since, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/sent"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/sent");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (searchFilter.IsSet)
                        parseQueryStringLocalVar["searchFilter"] = ClientUtils.ParameterToString(searchFilter.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxSentEmailsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxSentEmailsApiResponse>();

                        GetInboxSentEmailsApiResponse apiResponseLocalVar = new GetInboxSentEmailsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/sent", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxSentEmailsDefaultImplementation(apiResponseLocalVar, inboxId, page, size, sort, searchFilter, since, before);

                        Events.ExecuteOnGetInboxSentEmails(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxSentEmailsDefaultImplementation(e, "/inboxes/{inboxId}/sent", uriBuilderLocalVar.Path, inboxId, page, size, sort, searchFilter, since, before);
                Events.ExecuteOnErrorGetInboxSentEmails(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxSentEmailsApiResponse"/>
        /// </summary>
        public partial class GetInboxSentEmailsApiResponse : mailslurp.Client.ApiResponse, IGetInboxSentEmailsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxSentEmailsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxSentEmailsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxSentEmailsApiResponse(ILogger<GetInboxSentEmailsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageSentEmailProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageSentEmailProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageSentEmailProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxTags(ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<string> searchFilter);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <returns></returns>
        private void ValidateGetInboxTags(Option<string> sort, Option<string> searchFilter)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (searchFilter.IsSet && searchFilter.Value == null)
                throw new ArgumentNullException(nameof(searchFilter));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        private void AfterGetInboxTagsDefaultImplementation(IGetInboxTagsApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxTags(ref suppressDefaultLog, apiResponseLocalVar, page, size, sort, searchFilter);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        partial void AfterGetInboxTags(ref bool suppressDefaultLog, IGetInboxTagsApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        private void OnErrorGetInboxTagsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxTags(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, page, size, sort, searchFilter);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        partial void OnErrorGetInboxTags(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter);

        /// <summary>
        /// Get inbox tags Get all inbox tags
        /// </summary>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxTagsApiResponse"/>&gt;</returns>
        public async Task<IGetInboxTagsApiResponse> GetInboxTagsOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxTagsAsync(page, size, sort, searchFilter, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get inbox tags Get all inbox tags
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxTagsApiResponse"/>&gt;</returns>
        public async Task<IGetInboxTagsApiResponse> GetInboxTagsAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetInboxTags(sort, searchFilter);

                FormatGetInboxTags(ref page, ref size, ref sort, ref searchFilter);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/tags"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/tags");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (searchFilter.IsSet)
                        parseQueryStringLocalVar["searchFilter"] = ClientUtils.ParameterToString(searchFilter.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxTagsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxTagsApiResponse>();

                        GetInboxTagsApiResponse apiResponseLocalVar = new GetInboxTagsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/tags", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxTagsDefaultImplementation(apiResponseLocalVar, page, size, sort, searchFilter);

                        Events.ExecuteOnGetInboxTags(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxTagsDefaultImplementation(e, "/inboxes/tags", uriBuilderLocalVar.Path, page, size, sort, searchFilter);
                Events.ExecuteOnErrorGetInboxTags(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxTagsApiResponse"/>
        /// </summary>
        public partial class GetInboxTagsApiResponse : mailslurp.Client.ApiResponse, IGetInboxTagsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxTagsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxTagsApiResponse(ILogger<GetInboxTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<string> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<string>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out List<string> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxTagsPaginated(ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<string> searchFilter);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <returns></returns>
        private void ValidateGetInboxTagsPaginated(Option<string> sort, Option<string> searchFilter)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (searchFilter.IsSet && searchFilter.Value == null)
                throw new ArgumentNullException(nameof(searchFilter));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        private void AfterGetInboxTagsPaginatedDefaultImplementation(IGetInboxTagsPaginatedApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxTagsPaginated(ref suppressDefaultLog, apiResponseLocalVar, page, size, sort, searchFilter);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        partial void AfterGetInboxTagsPaginated(ref bool suppressDefaultLog, IGetInboxTagsPaginatedApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        private void OnErrorGetInboxTagsPaginatedDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxTagsPaginated(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, page, size, sort, searchFilter);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        partial void OnErrorGetInboxTagsPaginated(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter);

        /// <summary>
        /// Get inbox tags paginated Get all inbox tags paginated
        /// </summary>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxTagsPaginatedApiResponse"/>&gt;</returns>
        public async Task<IGetInboxTagsPaginatedApiResponse> GetInboxTagsPaginatedOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxTagsPaginatedAsync(page, size, sort, searchFilter, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get inbox tags paginated Get all inbox tags paginated
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxTagsPaginatedApiResponse"/>&gt;</returns>
        public async Task<IGetInboxTagsPaginatedApiResponse> GetInboxTagsPaginatedAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetInboxTagsPaginated(sort, searchFilter);

                FormatGetInboxTagsPaginated(ref page, ref size, ref sort, ref searchFilter);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/tags/paginated"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/tags/paginated");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (searchFilter.IsSet)
                        parseQueryStringLocalVar["searchFilter"] = ClientUtils.ParameterToString(searchFilter.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxTagsPaginatedApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxTagsPaginatedApiResponse>();

                        GetInboxTagsPaginatedApiResponse apiResponseLocalVar = new GetInboxTagsPaginatedApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/tags/paginated", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxTagsPaginatedDefaultImplementation(apiResponseLocalVar, page, size, sort, searchFilter);

                        Events.ExecuteOnGetInboxTagsPaginated(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxTagsPaginatedDefaultImplementation(e, "/inboxes/tags/paginated", uriBuilderLocalVar.Path, page, size, sort, searchFilter);
                Events.ExecuteOnErrorGetInboxTagsPaginated(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxTagsPaginatedApiResponse"/>
        /// </summary>
        public partial class GetInboxTagsPaginatedApiResponse : mailslurp.Client.ApiResponse, IGetInboxTagsPaginatedApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxTagsPaginatedApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxTagsPaginatedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxTagsPaginatedApiResponse(ILogger<GetInboxTagsPaginatedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageInboxTags Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageInboxTags>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageInboxTags result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxes(ref Option<int> size, ref Option<string> sort, ref Option<DateTime> since, ref Option<bool> excludeCatchAllInboxes, ref Option<DateTime> before, Option<List<Guid>> include);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="include"></param>
        /// <returns></returns>
        private void ValidateGetInboxes(Option<string> sort, Option<List<Guid>> include)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (include.IsSet && include.Value == null)
                throw new ArgumentNullException(nameof(include));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="excludeCatchAllInboxes"></param>
        /// <param name="before"></param>
        /// <param name="include"></param>
        private void AfterGetInboxesDefaultImplementation(IGetInboxesApiResponse apiResponseLocalVar, Option<int> size, Option<string> sort, Option<DateTime> since, Option<bool> excludeCatchAllInboxes, Option<DateTime> before, Option<List<Guid>> include)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxes(ref suppressDefaultLog, apiResponseLocalVar, size, sort, since, excludeCatchAllInboxes, before, include);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="excludeCatchAllInboxes"></param>
        /// <param name="before"></param>
        /// <param name="include"></param>
        partial void AfterGetInboxes(ref bool suppressDefaultLog, IGetInboxesApiResponse apiResponseLocalVar, Option<int> size, Option<string> sort, Option<DateTime> since, Option<bool> excludeCatchAllInboxes, Option<DateTime> before, Option<List<Guid>> include);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="excludeCatchAllInboxes"></param>
        /// <param name="before"></param>
        /// <param name="include"></param>
        private void OnErrorGetInboxesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> size, Option<string> sort, Option<DateTime> since, Option<bool> excludeCatchAllInboxes, Option<DateTime> before, Option<List<Guid>> include)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, size, sort, since, excludeCatchAllInboxes, before, include);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="excludeCatchAllInboxes"></param>
        /// <param name="before"></param>
        /// <param name="include"></param>
        partial void OnErrorGetInboxes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> size, Option<string> sort, Option<DateTime> since, Option<bool> excludeCatchAllInboxes, Option<DateTime> before, Option<List<Guid>> include);

        /// <summary>
        /// List Inboxes and email addresses List the inboxes you have created. Note use of the more advanced &#x60;getAllInboxes&#x60; is recommended and allows paginated access using a limit and sort parameter.
        /// </summary>
        /// <param name="size">Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries. (optional, default to 100)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="excludeCatchAllInboxes">Optional exclude catch all inboxes (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="include">Optional inboxIds to include in result (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxesApiResponse"/>&gt;</returns>
        public async Task<IGetInboxesApiResponse> GetInboxesOrDefaultAsync(Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<bool> excludeCatchAllInboxes = default, Option<DateTime> before = default, Option<List<Guid>> include = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxesAsync(size, sort, since, excludeCatchAllInboxes, before, include, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List Inboxes and email addresses List the inboxes you have created. Note use of the more advanced &#x60;getAllInboxes&#x60; is recommended and allows paginated access using a limit and sort parameter.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries. (optional, default to 100)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="excludeCatchAllInboxes">Optional exclude catch all inboxes (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="include">Optional inboxIds to include in result (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxesApiResponse"/>&gt;</returns>
        public async Task<IGetInboxesApiResponse> GetInboxesAsync(Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<bool> excludeCatchAllInboxes = default, Option<DateTime> before = default, Option<List<Guid>> include = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetInboxes(sort, include);

                FormatGetInboxes(ref size, ref sort, ref since, ref excludeCatchAllInboxes, ref before, include);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (excludeCatchAllInboxes.IsSet)
                        parseQueryStringLocalVar["excludeCatchAllInboxes"] = ClientUtils.ParameterToString(excludeCatchAllInboxes.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (include.IsSet)
                        parseQueryStringLocalVar["include"] = ClientUtils.ParameterToString(include.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxesApiResponse>();

                        GetInboxesApiResponse apiResponseLocalVar = new GetInboxesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxesDefaultImplementation(apiResponseLocalVar, size, sort, since, excludeCatchAllInboxes, before, include);

                        Events.ExecuteOnGetInboxes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxesDefaultImplementation(e, "/inboxes", uriBuilderLocalVar.Path, size, sort, since, excludeCatchAllInboxes, before, include);
                Events.ExecuteOnErrorGetInboxes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxesApiResponse"/>
        /// </summary>
        public partial class GetInboxesApiResponse : mailslurp.Client.ApiResponse, IGetInboxesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxesApiResponse(ILogger<GetInboxesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InboxDto> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InboxDto>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out List<InboxDto> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetInboxesByTag(ref string tag, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<string> searchFilter);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <returns></returns>
        private void ValidateGetInboxesByTag(string tag, Option<string> sort, Option<string> searchFilter)
        {
            if (tag == null)
                throw new ArgumentNullException(nameof(tag));

            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (searchFilter.IsSet && searchFilter.Value == null)
                throw new ArgumentNullException(nameof(searchFilter));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tag"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        private void AfterGetInboxesByTagDefaultImplementation(IGetInboxesByTagApiResponse apiResponseLocalVar, string tag, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter)
        {
            bool suppressDefaultLog = false;
            AfterGetInboxesByTag(ref suppressDefaultLog, apiResponseLocalVar, tag, page, size, sort, searchFilter);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tag"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        partial void AfterGetInboxesByTag(ref bool suppressDefaultLog, IGetInboxesByTagApiResponse apiResponseLocalVar, string tag, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tag"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        private void OnErrorGetInboxesByTagDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string tag, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetInboxesByTag(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, tag, page, size, sort, searchFilter);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tag"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        partial void OnErrorGetInboxesByTag(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string tag, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter);

        /// <summary>
        /// Get inboxes for a tag Get all inboxes for a given inbox tag
        /// </summary>
        /// <param name="tag">Tag to filter by</param>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxesByTagApiResponse"/>&gt;</returns>
        public async Task<IGetInboxesByTagApiResponse> GetInboxesByTagOrDefaultAsync(string tag, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetInboxesByTagAsync(tag, page, size, sort, searchFilter, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get inboxes for a tag Get all inboxes for a given inbox tag
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">Tag to filter by</param>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetInboxesByTagApiResponse"/>&gt;</returns>
        public async Task<IGetInboxesByTagApiResponse> GetInboxesByTagAsync(string tag, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetInboxesByTag(tag, sort, searchFilter);

                FormatGetInboxesByTag(ref tag, ref page, ref size, ref sort, ref searchFilter);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/tags/inboxes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/tags/inboxes");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["tag"] = ClientUtils.ParameterToString(tag);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (searchFilter.IsSet)
                        parseQueryStringLocalVar["searchFilter"] = ClientUtils.ParameterToString(searchFilter.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetInboxesByTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetInboxesByTagApiResponse>();

                        GetInboxesByTagApiResponse apiResponseLocalVar = new GetInboxesByTagApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/tags/inboxes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetInboxesByTagDefaultImplementation(apiResponseLocalVar, tag, page, size, sort, searchFilter);

                        Events.ExecuteOnGetInboxesByTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetInboxesByTagDefaultImplementation(e, "/inboxes/tags/inboxes", uriBuilderLocalVar.Path, tag, page, size, sort, searchFilter);
                Events.ExecuteOnErrorGetInboxesByTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetInboxesByTagApiResponse"/>
        /// </summary>
        public partial class GetInboxesByTagApiResponse : mailslurp.Client.ApiResponse, IGetInboxesByTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetInboxesByTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetInboxesByTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetInboxesByTagApiResponse(ILogger<GetInboxesByTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageInboxProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageInboxProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageInboxProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetLatestEmailInInbox(ref Guid inboxId, ref long timeoutMillis);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="timeoutMillis"></param>
        private void AfterGetLatestEmailInInboxDefaultImplementation(IGetLatestEmailInInboxApiResponse apiResponseLocalVar, Guid inboxId, long timeoutMillis)
        {
            bool suppressDefaultLog = false;
            AfterGetLatestEmailInInbox(ref suppressDefaultLog, apiResponseLocalVar, inboxId, timeoutMillis);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="timeoutMillis"></param>
        partial void AfterGetLatestEmailInInbox(ref bool suppressDefaultLog, IGetLatestEmailInInboxApiResponse apiResponseLocalVar, Guid inboxId, long timeoutMillis);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="timeoutMillis"></param>
        private void OnErrorGetLatestEmailInInboxDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, long timeoutMillis)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetLatestEmailInInbox(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, timeoutMillis);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="timeoutMillis"></param>
        partial void OnErrorGetLatestEmailInInbox(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, long timeoutMillis);

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet. Get the newest email in an inbox or wait for one to arrive
        /// </summary>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="timeoutMillis">Timeout milliseconds to wait for latest email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestEmailInInboxApiResponse"/>&gt;</returns>
        public async Task<IGetLatestEmailInInboxApiResponse> GetLatestEmailInInboxOrDefaultAsync(Guid inboxId, long timeoutMillis, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetLatestEmailInInboxAsync(inboxId, timeoutMillis, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet. Get the newest email in an inbox or wait for one to arrive
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="timeoutMillis">Timeout milliseconds to wait for latest email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestEmailInInboxApiResponse"/>&gt;</returns>
        public async Task<IGetLatestEmailInInboxApiResponse> GetLatestEmailInInboxAsync(Guid inboxId, long timeoutMillis, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetLatestEmailInInbox(ref inboxId, ref timeoutMillis);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/getLatestEmail"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/getLatestEmail");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId);
                    parseQueryStringLocalVar["timeoutMillis"] = ClientUtils.ParameterToString(timeoutMillis);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetLatestEmailInInboxApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetLatestEmailInInboxApiResponse>();

                        GetLatestEmailInInboxApiResponse apiResponseLocalVar = new GetLatestEmailInInboxApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/getLatestEmail", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetLatestEmailInInboxDefaultImplementation(apiResponseLocalVar, inboxId, timeoutMillis);

                        Events.ExecuteOnGetLatestEmailInInbox(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetLatestEmailInInboxDefaultImplementation(e, "/inboxes/getLatestEmail", uriBuilderLocalVar.Path, inboxId, timeoutMillis);
                Events.ExecuteOnErrorGetLatestEmailInInbox(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetLatestEmailInInboxApiResponse"/>
        /// </summary>
        public partial class GetLatestEmailInInboxApiResponse : mailslurp.Client.ApiResponse, IGetLatestEmailInInboxApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetLatestEmailInInboxApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetLatestEmailInInboxApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLatestEmailInInboxApiResponse(ILogger<GetLatestEmailInInboxApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.Email Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.Email>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.Email result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetOrganizationInboxes(ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<string> searchFilter, ref Option<DateTime> since, ref Option<DateTime> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <returns></returns>
        private void ValidateGetOrganizationInboxes(Option<string> sort, Option<string> searchFilter)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (searchFilter.IsSet && searchFilter.Value == null)
                throw new ArgumentNullException(nameof(searchFilter));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void AfterGetOrganizationInboxesDefaultImplementation(IGetOrganizationInboxesApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLog = false;
            AfterGetOrganizationInboxes(ref suppressDefaultLog, apiResponseLocalVar, page, size, sort, searchFilter, since, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void AfterGetOrganizationInboxes(ref bool suppressDefaultLog, IGetOrganizationInboxesApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void OnErrorGetOrganizationInboxesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetOrganizationInboxes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, page, size, sort, searchFilter, since, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void OnErrorGetOrganizationInboxes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// List Organization Inboxes Paginated List organization inboxes in paginated form. These are inboxes created with &#x60;allowTeamAccess&#x60; flag enabled. Organization inboxes are &#x60;readOnly&#x60; for non-admin users. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). 
        /// </summary>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOrganizationInboxesApiResponse"/>&gt;</returns>
        public async Task<IGetOrganizationInboxesApiResponse> GetOrganizationInboxesOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetOrganizationInboxesAsync(page, size, sort, searchFilter, since, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List Organization Inboxes Paginated List organization inboxes in paginated form. These are inboxes created with &#x60;allowTeamAccess&#x60; flag enabled. Organization inboxes are &#x60;readOnly&#x60; for non-admin users. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOrganizationInboxesApiResponse"/>&gt;</returns>
        public async Task<IGetOrganizationInboxesApiResponse> GetOrganizationInboxesAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetOrganizationInboxes(sort, searchFilter);

                FormatGetOrganizationInboxes(ref page, ref size, ref sort, ref searchFilter, ref since, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/organization"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/organization");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (searchFilter.IsSet)
                        parseQueryStringLocalVar["searchFilter"] = ClientUtils.ParameterToString(searchFilter.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetOrganizationInboxesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetOrganizationInboxesApiResponse>();

                        GetOrganizationInboxesApiResponse apiResponseLocalVar = new GetOrganizationInboxesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/organization", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetOrganizationInboxesDefaultImplementation(apiResponseLocalVar, page, size, sort, searchFilter, since, before);

                        Events.ExecuteOnGetOrganizationInboxes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetOrganizationInboxesDefaultImplementation(e, "/inboxes/organization", uriBuilderLocalVar.Path, page, size, sort, searchFilter, since, before);
                Events.ExecuteOnErrorGetOrganizationInboxes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetOrganizationInboxesApiResponse"/>
        /// </summary>
        public partial class GetOrganizationInboxesApiResponse : mailslurp.Client.ApiResponse, IGetOrganizationInboxesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetOrganizationInboxesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetOrganizationInboxesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetOrganizationInboxesApiResponse(ILogger<GetOrganizationInboxesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageOrganizationInboxProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageOrganizationInboxProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageOrganizationInboxProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetOutboxes(ref Option<int> page, ref Option<int> size, ref Option<string> sort);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateGetOutboxes(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        private void AfterGetOutboxesDefaultImplementation(IGetOutboxesApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort)
        {
            bool suppressDefaultLog = false;
            AfterGetOutboxes(ref suppressDefaultLog, apiResponseLocalVar, page, size, sort);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        partial void AfterGetOutboxes(ref bool suppressDefaultLog, IGetOutboxesApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        private void OnErrorGetOutboxesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetOutboxes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, page, size, sort);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        partial void OnErrorGetOutboxes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort);

        /// <summary>
        /// List all inboxes with sent emails List inboxes that have sent emails
        /// </summary>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOutboxesApiResponse"/>&gt;</returns>
        public async Task<IGetOutboxesApiResponse> GetOutboxesOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetOutboxesAsync(page, size, sort, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all inboxes with sent emails List inboxes that have sent emails
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOutboxesApiResponse"/>&gt;</returns>
        public async Task<IGetOutboxesApiResponse> GetOutboxesAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetOutboxes(sort);

                FormatGetOutboxes(ref page, ref size, ref sort);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/outboxes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/outboxes");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetOutboxesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetOutboxesApiResponse>();

                        GetOutboxesApiResponse apiResponseLocalVar = new GetOutboxesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/outboxes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetOutboxesDefaultImplementation(apiResponseLocalVar, page, size, sort);

                        Events.ExecuteOnGetOutboxes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetOutboxesDefaultImplementation(e, "/inboxes/outboxes", uriBuilderLocalVar.Path, page, size, sort);
                Events.ExecuteOnErrorGetOutboxes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetOutboxesApiResponse"/>
        /// </summary>
        public partial class GetOutboxesApiResponse : mailslurp.Client.ApiResponse, IGetOutboxesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetOutboxesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetOutboxesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetOutboxesApiResponse(ILogger<GetOutboxesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageInboxProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageInboxProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageInboxProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetScheduledJob(ref Guid jobId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="jobId"></param>
        private void AfterGetScheduledJobDefaultImplementation(IGetScheduledJobApiResponse apiResponseLocalVar, Guid jobId)
        {
            bool suppressDefaultLog = false;
            AfterGetScheduledJob(ref suppressDefaultLog, apiResponseLocalVar, jobId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="jobId"></param>
        partial void AfterGetScheduledJob(ref bool suppressDefaultLog, IGetScheduledJobApiResponse apiResponseLocalVar, Guid jobId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="jobId"></param>
        private void OnErrorGetScheduledJobDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid jobId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetScheduledJob(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, jobId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="jobId"></param>
        partial void OnErrorGetScheduledJob(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid jobId);

        /// <summary>
        /// Get a scheduled email job Get a scheduled email job details.
        /// </summary>
        /// <param name="jobId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetScheduledJobApiResponse"/>&gt;</returns>
        public async Task<IGetScheduledJobApiResponse> GetScheduledJobOrDefaultAsync(Guid jobId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetScheduledJobAsync(jobId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get a scheduled email job Get a scheduled email job details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetScheduledJobApiResponse"/>&gt;</returns>
        public async Task<IGetScheduledJobApiResponse> GetScheduledJobAsync(Guid jobId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetScheduledJob(ref jobId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/scheduled-jobs/{jobId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/scheduled-jobs/{jobId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BjobId%7D", Uri.EscapeDataString(jobId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetScheduledJobApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetScheduledJobApiResponse>();

                        GetScheduledJobApiResponse apiResponseLocalVar = new GetScheduledJobApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/scheduled-jobs/{jobId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetScheduledJobDefaultImplementation(apiResponseLocalVar, jobId);

                        Events.ExecuteOnGetScheduledJob(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetScheduledJobDefaultImplementation(e, "/inboxes/scheduled-jobs/{jobId}", uriBuilderLocalVar.Path, jobId);
                Events.ExecuteOnErrorGetScheduledJob(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetScheduledJobApiResponse"/>
        /// </summary>
        public partial class GetScheduledJobApiResponse : mailslurp.Client.ApiResponse, IGetScheduledJobApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetScheduledJobApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetScheduledJobApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetScheduledJobApiResponse(ILogger<GetScheduledJobApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ScheduledJobDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ScheduledJobDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ScheduledJobDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetScheduledJobsByInboxId(ref Guid inboxId, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<DateTime> since, ref Option<DateTime> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateGetScheduledJobsByInboxId(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void AfterGetScheduledJobsByInboxIdDefaultImplementation(IGetScheduledJobsByInboxIdApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLog = false;
            AfterGetScheduledJobsByInboxId(ref suppressDefaultLog, apiResponseLocalVar, inboxId, page, size, sort, since, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void AfterGetScheduledJobsByInboxId(ref bool suppressDefaultLog, IGetScheduledJobsByInboxIdApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void OnErrorGetScheduledJobsByInboxIdDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetScheduledJobsByInboxId(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, page, size, sort, since, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void OnErrorGetScheduledJobsByInboxId(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Get all scheduled email sending jobs for the inbox Schedule sending of emails using scheduled jobs.
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetScheduledJobsByInboxIdApiResponse"/>&gt;</returns>
        public async Task<IGetScheduledJobsByInboxIdApiResponse> GetScheduledJobsByInboxIdOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetScheduledJobsByInboxIdAsync(inboxId, page, size, sort, since, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all scheduled email sending jobs for the inbox Schedule sending of emails using scheduled jobs.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetScheduledJobsByInboxIdApiResponse"/>&gt;</returns>
        public async Task<IGetScheduledJobsByInboxIdApiResponse> GetScheduledJobsByInboxIdAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetScheduledJobsByInboxId(sort);

                FormatGetScheduledJobsByInboxId(ref inboxId, ref page, ref size, ref sort, ref since, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/scheduled-jobs"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/scheduled-jobs");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetScheduledJobsByInboxIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetScheduledJobsByInboxIdApiResponse>();

                        GetScheduledJobsByInboxIdApiResponse apiResponseLocalVar = new GetScheduledJobsByInboxIdApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/scheduled-jobs", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetScheduledJobsByInboxIdDefaultImplementation(apiResponseLocalVar, inboxId, page, size, sort, since, before);

                        Events.ExecuteOnGetScheduledJobsByInboxId(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetScheduledJobsByInboxIdDefaultImplementation(e, "/inboxes/{inboxId}/scheduled-jobs", uriBuilderLocalVar.Path, inboxId, page, size, sort, since, before);
                Events.ExecuteOnErrorGetScheduledJobsByInboxId(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetScheduledJobsByInboxIdApiResponse"/>
        /// </summary>
        public partial class GetScheduledJobsByInboxIdApiResponse : mailslurp.Client.ApiResponse, IGetScheduledJobsByInboxIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetScheduledJobsByInboxIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetScheduledJobsByInboxIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetScheduledJobsByInboxIdApiResponse(ILogger<GetScheduledJobsByInboxIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageScheduledJobs Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageScheduledJobs>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageScheduledJobs result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSmtpAccess(ref Option<Guid> inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterGetSmtpAccessDefaultImplementation(IGetSmtpAccessApiResponse apiResponseLocalVar, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetSmtpAccess(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetSmtpAccess(ref bool suppressDefaultLog, IGetSmtpAccessApiResponse apiResponseLocalVar, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetSmtpAccessDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSmtpAccess(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetSmtpAccess(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId);

        /// <summary>
        ///  Get SMTP access usernames and passwords
        /// </summary>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpAccessApiResponse"/>&gt;</returns>
        public async Task<IGetSmtpAccessApiResponse> GetSmtpAccessOrDefaultAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSmtpAccessAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Get SMTP access usernames and passwords
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSmtpAccessApiResponse"/>&gt;</returns>
        public async Task<IGetSmtpAccessApiResponse> GetSmtpAccessAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetSmtpAccess(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/smtp-access"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/smtp-access");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetSmtpAccessApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSmtpAccessApiResponse>();

                        GetSmtpAccessApiResponse apiResponseLocalVar = new GetSmtpAccessApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/smtp-access", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetSmtpAccessDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnGetSmtpAccess(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSmtpAccessDefaultImplementation(e, "/inboxes/smtp-access", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorGetSmtpAccess(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSmtpAccessApiResponse"/>
        /// </summary>
        public partial class GetSmtpAccessApiResponse : mailslurp.Client.ApiResponse, IGetSmtpAccessApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSmtpAccessApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSmtpAccessApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSmtpAccessApiResponse(ILogger<GetSmtpAccessApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.SmtpAccessDetails Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.SmtpAccessDetails>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.SmtpAccessDetails result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatIsEmailAddressAvailable(ref string emailAddress);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="emailAddress"></param>
        /// <returns></returns>
        private void ValidateIsEmailAddressAvailable(string emailAddress)
        {
            if (emailAddress == null)
                throw new ArgumentNullException(nameof(emailAddress));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailAddress"></param>
        private void AfterIsEmailAddressAvailableDefaultImplementation(IIsEmailAddressAvailableApiResponse apiResponseLocalVar, string emailAddress)
        {
            bool suppressDefaultLog = false;
            AfterIsEmailAddressAvailable(ref suppressDefaultLog, apiResponseLocalVar, emailAddress);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailAddress"></param>
        partial void AfterIsEmailAddressAvailable(ref bool suppressDefaultLog, IIsEmailAddressAvailableApiResponse apiResponseLocalVar, string emailAddress);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailAddress"></param>
        private void OnErrorIsEmailAddressAvailableDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string emailAddress)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorIsEmailAddressAvailable(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailAddress);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailAddress"></param>
        partial void OnErrorIsEmailAddressAvailable(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string emailAddress);

        /// <summary>
        /// Is email address available Returns whether an email address is available
        /// </summary>
        /// <param name="emailAddress"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IIsEmailAddressAvailableApiResponse"/>&gt;</returns>
        public async Task<IIsEmailAddressAvailableApiResponse> IsEmailAddressAvailableOrDefaultAsync(string emailAddress, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await IsEmailAddressAvailableAsync(emailAddress, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Is email address available Returns whether an email address is available
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IIsEmailAddressAvailableApiResponse"/>&gt;</returns>
        public async Task<IIsEmailAddressAvailableApiResponse> IsEmailAddressAvailableAsync(string emailAddress, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateIsEmailAddressAvailable(emailAddress);

                FormatIsEmailAddressAvailable(ref emailAddress);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/available"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/available");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["emailAddress"] = ClientUtils.ParameterToString(emailAddress);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<IsEmailAddressAvailableApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<IsEmailAddressAvailableApiResponse>();

                        IsEmailAddressAvailableApiResponse apiResponseLocalVar = new IsEmailAddressAvailableApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/available", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterIsEmailAddressAvailableDefaultImplementation(apiResponseLocalVar, emailAddress);

                        Events.ExecuteOnIsEmailAddressAvailable(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorIsEmailAddressAvailableDefaultImplementation(e, "/inboxes/available", uriBuilderLocalVar.Path, emailAddress);
                Events.ExecuteOnErrorIsEmailAddressAvailable(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="IsEmailAddressAvailableApiResponse"/>
        /// </summary>
        public partial class IsEmailAddressAvailableApiResponse : mailslurp.Client.ApiResponse, IIsEmailAddressAvailableApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<IsEmailAddressAvailableApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="IsEmailAddressAvailableApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public IsEmailAddressAvailableApiResponse(ILogger<IsEmailAddressAvailableApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailAvailableResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailAvailableResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailAvailableResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListInboxRulesets(ref Guid inboxId, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<string> searchFilter, ref Option<DateTime> since, ref Option<DateTime> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <returns></returns>
        private void ValidateListInboxRulesets(Option<string> sort, Option<string> searchFilter)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (searchFilter.IsSet && searchFilter.Value == null)
                throw new ArgumentNullException(nameof(searchFilter));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void AfterListInboxRulesetsDefaultImplementation(IListInboxRulesetsApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLog = false;
            AfterListInboxRulesets(ref suppressDefaultLog, apiResponseLocalVar, inboxId, page, size, sort, searchFilter, since, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void AfterListInboxRulesets(ref bool suppressDefaultLog, IListInboxRulesetsApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void OnErrorListInboxRulesetsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListInboxRulesets(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, page, size, sort, searchFilter, since, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void OnErrorListInboxRulesets(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// List inbox rulesets List all rulesets attached to an inbox
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox ruleset list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox ruleset list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListInboxRulesetsApiResponse"/>&gt;</returns>
        public async Task<IListInboxRulesetsApiResponse> ListInboxRulesetsOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListInboxRulesetsAsync(inboxId, page, size, sort, searchFilter, since, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List inbox rulesets List all rulesets attached to an inbox
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox ruleset list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox ruleset list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListInboxRulesetsApiResponse"/>&gt;</returns>
        public async Task<IListInboxRulesetsApiResponse> ListInboxRulesetsAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListInboxRulesets(sort, searchFilter);

                FormatListInboxRulesets(ref inboxId, ref page, ref size, ref sort, ref searchFilter, ref since, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/rulesets"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/rulesets");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (searchFilter.IsSet)
                        parseQueryStringLocalVar["searchFilter"] = ClientUtils.ParameterToString(searchFilter.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ListInboxRulesetsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListInboxRulesetsApiResponse>();

                        ListInboxRulesetsApiResponse apiResponseLocalVar = new ListInboxRulesetsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/rulesets", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListInboxRulesetsDefaultImplementation(apiResponseLocalVar, inboxId, page, size, sort, searchFilter, since, before);

                        Events.ExecuteOnListInboxRulesets(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListInboxRulesetsDefaultImplementation(e, "/inboxes/{inboxId}/rulesets", uriBuilderLocalVar.Path, inboxId, page, size, sort, searchFilter, since, before);
                Events.ExecuteOnErrorListInboxRulesets(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListInboxRulesetsApiResponse"/>
        /// </summary>
        public partial class ListInboxRulesetsApiResponse : mailslurp.Client.ApiResponse, IListInboxRulesetsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListInboxRulesetsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListInboxRulesetsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListInboxRulesetsApiResponse(ILogger<ListInboxRulesetsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageInboxRulesetDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageInboxRulesetDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageInboxRulesetDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListInboxTrackingPixels(ref Guid inboxId, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<string> searchFilter, ref Option<DateTime> since, ref Option<DateTime> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <returns></returns>
        private void ValidateListInboxTrackingPixels(Option<string> sort, Option<string> searchFilter)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (searchFilter.IsSet && searchFilter.Value == null)
                throw new ArgumentNullException(nameof(searchFilter));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void AfterListInboxTrackingPixelsDefaultImplementation(IListInboxTrackingPixelsApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLog = false;
            AfterListInboxTrackingPixels(ref suppressDefaultLog, apiResponseLocalVar, inboxId, page, size, sort, searchFilter, since, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void AfterListInboxTrackingPixels(ref bool suppressDefaultLog, IListInboxTrackingPixelsApiResponse apiResponseLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void OnErrorListInboxTrackingPixelsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListInboxTrackingPixels(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, page, size, sort, searchFilter, since, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void OnErrorListInboxTrackingPixels(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// List inbox tracking pixels List all tracking pixels sent from an inbox
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListInboxTrackingPixelsApiResponse"/>&gt;</returns>
        public async Task<IListInboxTrackingPixelsApiResponse> ListInboxTrackingPixelsOrDefaultAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListInboxTrackingPixelsAsync(inboxId, page, size, sort, searchFilter, since, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List inbox tracking pixels List all tracking pixels sent from an inbox
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListInboxTrackingPixelsApiResponse"/>&gt;</returns>
        public async Task<IListInboxTrackingPixelsApiResponse> ListInboxTrackingPixelsAsync(Guid inboxId, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListInboxTrackingPixels(sort, searchFilter);

                FormatListInboxTrackingPixels(ref inboxId, ref page, ref size, ref sort, ref searchFilter, ref since, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/tracking-pixels"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/tracking-pixels");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (searchFilter.IsSet)
                        parseQueryStringLocalVar["searchFilter"] = ClientUtils.ParameterToString(searchFilter.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ListInboxTrackingPixelsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListInboxTrackingPixelsApiResponse>();

                        ListInboxTrackingPixelsApiResponse apiResponseLocalVar = new ListInboxTrackingPixelsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/tracking-pixels", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListInboxTrackingPixelsDefaultImplementation(apiResponseLocalVar, inboxId, page, size, sort, searchFilter, since, before);

                        Events.ExecuteOnListInboxTrackingPixels(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListInboxTrackingPixelsDefaultImplementation(e, "/inboxes/{inboxId}/tracking-pixels", uriBuilderLocalVar.Path, inboxId, page, size, sort, searchFilter, since, before);
                Events.ExecuteOnErrorListInboxTrackingPixels(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListInboxTrackingPixelsApiResponse"/>
        /// </summary>
        public partial class ListInboxTrackingPixelsApiResponse : mailslurp.Client.ApiResponse, IListInboxTrackingPixelsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListInboxTrackingPixelsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListInboxTrackingPixelsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListInboxTrackingPixelsApiResponse(ILogger<ListInboxTrackingPixelsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageTrackingPixelProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageTrackingPixelProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageTrackingPixelProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchInboxes(SearchInboxesOptions searchInboxesOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="searchInboxesOptions"></param>
        /// <returns></returns>
        private void ValidateSearchInboxes(SearchInboxesOptions searchInboxesOptions)
        {
            if (searchInboxesOptions == null)
                throw new ArgumentNullException(nameof(searchInboxesOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="searchInboxesOptions"></param>
        private void AfterSearchInboxesDefaultImplementation(ISearchInboxesApiResponse apiResponseLocalVar, SearchInboxesOptions searchInboxesOptions)
        {
            bool suppressDefaultLog = false;
            AfterSearchInboxes(ref suppressDefaultLog, apiResponseLocalVar, searchInboxesOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="searchInboxesOptions"></param>
        partial void AfterSearchInboxes(ref bool suppressDefaultLog, ISearchInboxesApiResponse apiResponseLocalVar, SearchInboxesOptions searchInboxesOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="searchInboxesOptions"></param>
        private void OnErrorSearchInboxesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SearchInboxesOptions searchInboxesOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchInboxes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, searchInboxesOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="searchInboxesOptions"></param>
        partial void OnErrorSearchInboxes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SearchInboxesOptions searchInboxesOptions);

        /// <summary>
        /// Search all inboxes and return matching inboxes Search inboxes and return in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <param name="searchInboxesOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchInboxesApiResponse"/>&gt;</returns>
        public async Task<ISearchInboxesApiResponse> SearchInboxesOrDefaultAsync(SearchInboxesOptions searchInboxesOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchInboxesAsync(searchInboxesOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search all inboxes and return matching inboxes Search inboxes and return in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchInboxesOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchInboxesApiResponse"/>&gt;</returns>
        public async Task<ISearchInboxesApiResponse> SearchInboxesAsync(SearchInboxesOptions searchInboxesOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchInboxes(searchInboxesOptions);

                FormatSearchInboxes(searchInboxesOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/search");

                    httpRequestMessageLocalVar.Content = (searchInboxesOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(searchInboxesOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SearchInboxesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchInboxesApiResponse>();

                        SearchInboxesApiResponse apiResponseLocalVar = new SearchInboxesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/search", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSearchInboxesDefaultImplementation(apiResponseLocalVar, searchInboxesOptions);

                        Events.ExecuteOnSearchInboxes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchInboxesDefaultImplementation(e, "/inboxes/search", uriBuilderLocalVar.Path, searchInboxesOptions);
                Events.ExecuteOnErrorSearchInboxes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchInboxesApiResponse"/>
        /// </summary>
        public partial class SearchInboxesApiResponse : mailslurp.Client.ApiResponse, ISearchInboxesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchInboxesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchInboxesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchInboxesApiResponse(ILogger<SearchInboxesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageInboxProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageInboxProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageInboxProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendEmail(ref Guid inboxId, SendEmailOptions sendEmailOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sendEmailOptions"></param>
        /// <returns></returns>
        private void ValidateSendEmail(SendEmailOptions sendEmailOptions)
        {
            if (sendEmailOptions == null)
                throw new ArgumentNullException(nameof(sendEmailOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        private void AfterSendEmailDefaultImplementation(ISendEmailApiResponse apiResponseLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions)
        {
            bool suppressDefaultLog = false;
            AfterSendEmail(ref suppressDefaultLog, apiResponseLocalVar, inboxId, sendEmailOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        partial void AfterSendEmail(ref bool suppressDefaultLog, ISendEmailApiResponse apiResponseLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        private void OnErrorSendEmailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendEmail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, sendEmailOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        partial void OnErrorSendEmail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions);

        /// <summary>
        /// Send Email Send an email from an inbox&#39;s email address.  The request body should contain the &#x60;SendEmailOptions&#x60; that include recipients, attachments, body etc. See &#x60;SendEmailOptions&#x60; for all available properties. Note the &#x60;inboxId&#x60; refers to the inbox&#39;s id not the inbox&#39;s email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method &#x60;sendEmailAndConfirm&#x60;.
        /// </summary>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailApiResponse"/>&gt;</returns>
        public async Task<ISendEmailApiResponse> SendEmailOrDefaultAsync(Guid inboxId, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendEmailAsync(inboxId, sendEmailOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send Email Send an email from an inbox&#39;s email address.  The request body should contain the &#x60;SendEmailOptions&#x60; that include recipients, attachments, body etc. See &#x60;SendEmailOptions&#x60; for all available properties. Note the &#x60;inboxId&#x60; refers to the inbox&#39;s id not the inbox&#39;s email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method &#x60;sendEmailAndConfirm&#x60;.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailApiResponse"/>&gt;</returns>
        public async Task<ISendEmailApiResponse> SendEmailAsync(Guid inboxId, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendEmail(sendEmailOptions);

                FormatSendEmail(ref inboxId, sendEmailOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    httpRequestMessageLocalVar.Content = (sendEmailOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendEmailOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SendEmailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendEmailApiResponse>();

                        SendEmailApiResponse apiResponseLocalVar = new SendEmailApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendEmailDefaultImplementation(apiResponseLocalVar, inboxId, sendEmailOptions);

                        Events.ExecuteOnSendEmail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendEmailDefaultImplementation(e, "/inboxes/{inboxId}", uriBuilderLocalVar.Path, inboxId, sendEmailOptions);
                Events.ExecuteOnErrorSendEmail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendEmailApiResponse"/>
        /// </summary>
        public partial class SendEmailApiResponse : mailslurp.Client.ApiResponse, ISendEmailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendEmailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendEmailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendEmailApiResponse(ILogger<SendEmailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendEmailAndConfirm(ref Guid inboxId, SendEmailOptions sendEmailOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sendEmailOptions"></param>
        /// <returns></returns>
        private void ValidateSendEmailAndConfirm(SendEmailOptions sendEmailOptions)
        {
            if (sendEmailOptions == null)
                throw new ArgumentNullException(nameof(sendEmailOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        private void AfterSendEmailAndConfirmDefaultImplementation(ISendEmailAndConfirmApiResponse apiResponseLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions)
        {
            bool suppressDefaultLog = false;
            AfterSendEmailAndConfirm(ref suppressDefaultLog, apiResponseLocalVar, inboxId, sendEmailOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        partial void AfterSendEmailAndConfirm(ref bool suppressDefaultLog, ISendEmailAndConfirmApiResponse apiResponseLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        private void OnErrorSendEmailAndConfirmDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendEmailAndConfirm(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, sendEmailOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        partial void OnErrorSendEmailAndConfirm(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions);

        /// <summary>
        /// Send email and return sent confirmation Sister method for standard &#x60;sendEmail&#x60; method with the benefit of returning a &#x60;SentEmail&#x60; entity confirming the successful sending of the email with a link to the sent object created for it.
        /// </summary>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailAndConfirmApiResponse"/>&gt;</returns>
        public async Task<ISendEmailAndConfirmApiResponse> SendEmailAndConfirmOrDefaultAsync(Guid inboxId, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendEmailAndConfirmAsync(inboxId, sendEmailOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send email and return sent confirmation Sister method for standard &#x60;sendEmail&#x60; method with the benefit of returning a &#x60;SentEmail&#x60; entity confirming the successful sending of the email with a link to the sent object created for it.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailAndConfirmApiResponse"/>&gt;</returns>
        public async Task<ISendEmailAndConfirmApiResponse> SendEmailAndConfirmAsync(Guid inboxId, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendEmailAndConfirm(sendEmailOptions);

                FormatSendEmailAndConfirm(ref inboxId, sendEmailOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/confirm"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/confirm");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    httpRequestMessageLocalVar.Content = (sendEmailOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendEmailOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SendEmailAndConfirmApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendEmailAndConfirmApiResponse>();

                        SendEmailAndConfirmApiResponse apiResponseLocalVar = new SendEmailAndConfirmApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/confirm", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendEmailAndConfirmDefaultImplementation(apiResponseLocalVar, inboxId, sendEmailOptions);

                        Events.ExecuteOnSendEmailAndConfirm(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendEmailAndConfirmDefaultImplementation(e, "/inboxes/{inboxId}/confirm", uriBuilderLocalVar.Path, inboxId, sendEmailOptions);
                Events.ExecuteOnErrorSendEmailAndConfirm(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendEmailAndConfirmApiResponse"/>
        /// </summary>
        public partial class SendEmailAndConfirmApiResponse : mailslurp.Client.ApiResponse, ISendEmailAndConfirmApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendEmailAndConfirmApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendEmailAndConfirmApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendEmailAndConfirmApiResponse(ILogger<SendEmailAndConfirmApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.SentEmailDto Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.SentEmailDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out mailslurp.Model.SentEmailDto result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendEmailWithQueue(ref Guid inboxId, ref bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sendEmailOptions"></param>
        /// <returns></returns>
        private void ValidateSendEmailWithQueue(SendEmailOptions sendEmailOptions)
        {
            if (sendEmailOptions == null)
                throw new ArgumentNullException(nameof(sendEmailOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="validateBeforeEnqueue"></param>
        /// <param name="sendEmailOptions"></param>
        private void AfterSendEmailWithQueueDefaultImplementation(ISendEmailWithQueueApiResponse apiResponseLocalVar, Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions)
        {
            bool suppressDefaultLog = false;
            AfterSendEmailWithQueue(ref suppressDefaultLog, apiResponseLocalVar, inboxId, validateBeforeEnqueue, sendEmailOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="validateBeforeEnqueue"></param>
        /// <param name="sendEmailOptions"></param>
        partial void AfterSendEmailWithQueue(ref bool suppressDefaultLog, ISendEmailWithQueueApiResponse apiResponseLocalVar, Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="validateBeforeEnqueue"></param>
        /// <param name="sendEmailOptions"></param>
        private void OnErrorSendEmailWithQueueDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendEmailWithQueue(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, validateBeforeEnqueue, sendEmailOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="validateBeforeEnqueue"></param>
        /// <param name="sendEmailOptions"></param>
        partial void OnErrorSendEmailWithQueue(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions);

        /// <summary>
        /// Send email with queue Send an email using a queue. Will place the email onto a queue that will then be processed and sent. Use this queue method to enable any failed email sending to be recovered. This will prevent lost emails when sending if your account encounters a block or payment issue.
        /// </summary>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailWithQueueApiResponse"/>&gt;</returns>
        public async Task<ISendEmailWithQueueApiResponse> SendEmailWithQueueOrDefaultAsync(Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendEmailWithQueueAsync(inboxId, validateBeforeEnqueue, sendEmailOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send email with queue Send an email using a queue. Will place the email onto a queue that will then be processed and sent. Use this queue method to enable any failed email sending to be recovered. This will prevent lost emails when sending if your account encounters a block or payment issue.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailWithQueueApiResponse"/>&gt;</returns>
        public async Task<ISendEmailWithQueueApiResponse> SendEmailWithQueueAsync(Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendEmailWithQueue(sendEmailOptions);

                FormatSendEmailWithQueue(ref inboxId, ref validateBeforeEnqueue, sendEmailOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/with-queue"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/with-queue");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["validateBeforeEnqueue"] = ClientUtils.ParameterToString(validateBeforeEnqueue);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (sendEmailOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendEmailOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SendEmailWithQueueApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendEmailWithQueueApiResponse>();

                        SendEmailWithQueueApiResponse apiResponseLocalVar = new SendEmailWithQueueApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/with-queue", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendEmailWithQueueDefaultImplementation(apiResponseLocalVar, inboxId, validateBeforeEnqueue, sendEmailOptions);

                        Events.ExecuteOnSendEmailWithQueue(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendEmailWithQueueDefaultImplementation(e, "/inboxes/{inboxId}/with-queue", uriBuilderLocalVar.Path, inboxId, validateBeforeEnqueue, sendEmailOptions);
                Events.ExecuteOnErrorSendEmailWithQueue(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendEmailWithQueueApiResponse"/>
        /// </summary>
        public partial class SendEmailWithQueueApiResponse : mailslurp.Client.ApiResponse, ISendEmailWithQueueApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendEmailWithQueueApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendEmailWithQueueApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendEmailWithQueueApiResponse(ILogger<SendEmailWithQueueApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendSmtpEnvelope(ref Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <returns></returns>
        private void ValidateSendSmtpEnvelope(SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions)
        {
            if (sendSMTPEnvelopeOptions == null)
                throw new ArgumentNullException(nameof(sendSMTPEnvelopeOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        private void AfterSendSmtpEnvelopeDefaultImplementation(ISendSmtpEnvelopeApiResponse apiResponseLocalVar, Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions)
        {
            bool suppressDefaultLog = false;
            AfterSendSmtpEnvelope(ref suppressDefaultLog, apiResponseLocalVar, inboxId, sendSMTPEnvelopeOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        partial void AfterSendSmtpEnvelope(ref bool suppressDefaultLog, ISendSmtpEnvelopeApiResponse apiResponseLocalVar, Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        private void OnErrorSendSmtpEnvelopeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendSmtpEnvelope(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, sendSMTPEnvelopeOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        partial void OnErrorSendSmtpEnvelope(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions);

        /// <summary>
        /// Send email using an SMTP mail envelope and message body and return sent confirmation Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.
        /// </summary>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendSmtpEnvelopeApiResponse"/>&gt;</returns>
        public async Task<ISendSmtpEnvelopeApiResponse> SendSmtpEnvelopeOrDefaultAsync(Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendSmtpEnvelopeAsync(inboxId, sendSMTPEnvelopeOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send email using an SMTP mail envelope and message body and return sent confirmation Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendSmtpEnvelopeApiResponse"/>&gt;</returns>
        public async Task<ISendSmtpEnvelopeApiResponse> SendSmtpEnvelopeAsync(Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendSmtpEnvelope(sendSMTPEnvelopeOptions);

                FormatSendSmtpEnvelope(ref inboxId, sendSMTPEnvelopeOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/smtp-envelope"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/smtp-envelope");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    httpRequestMessageLocalVar.Content = (sendSMTPEnvelopeOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendSMTPEnvelopeOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SendSmtpEnvelopeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendSmtpEnvelopeApiResponse>();

                        SendSmtpEnvelopeApiResponse apiResponseLocalVar = new SendSmtpEnvelopeApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/smtp-envelope", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendSmtpEnvelopeDefaultImplementation(apiResponseLocalVar, inboxId, sendSMTPEnvelopeOptions);

                        Events.ExecuteOnSendSmtpEnvelope(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendSmtpEnvelopeDefaultImplementation(e, "/inboxes/{inboxId}/smtp-envelope", uriBuilderLocalVar.Path, inboxId, sendSMTPEnvelopeOptions);
                Events.ExecuteOnErrorSendSmtpEnvelope(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendSmtpEnvelopeApiResponse"/>
        /// </summary>
        public partial class SendSmtpEnvelopeApiResponse : mailslurp.Client.ApiResponse, ISendSmtpEnvelopeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendSmtpEnvelopeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendSmtpEnvelopeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendSmtpEnvelopeApiResponse(ILogger<SendSmtpEnvelopeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.SentEmailDto Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.SentEmailDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out mailslurp.Model.SentEmailDto result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendTestEmail(ref Guid inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterSendTestEmailDefaultImplementation(ISendTestEmailApiResponse apiResponseLocalVar, Guid inboxId)
        {
            bool suppressDefaultLog = false;
            AfterSendTestEmail(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterSendTestEmail(ref bool suppressDefaultLog, ISendTestEmailApiResponse apiResponseLocalVar, Guid inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorSendTestEmailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendTestEmail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorSendTestEmail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId);

        /// <summary>
        /// Send a test email to inbox Send an inbox a test email to test email receiving is working
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTestEmailApiResponse"/>&gt;</returns>
        public async Task<ISendTestEmailApiResponse> SendTestEmailOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendTestEmailAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send a test email to inbox Send an inbox a test email to test email receiving is working
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendTestEmailApiResponse"/>&gt;</returns>
        public async Task<ISendTestEmailApiResponse> SendTestEmailAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatSendTestEmail(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/send-test-email"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/send-test-email");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SendTestEmailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendTestEmailApiResponse>();

                        SendTestEmailApiResponse apiResponseLocalVar = new SendTestEmailApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/send-test-email", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendTestEmailDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnSendTestEmail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendTestEmailDefaultImplementation(e, "/inboxes/{inboxId}/send-test-email", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorSendTestEmail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendTestEmailApiResponse"/>
        /// </summary>
        public partial class SendTestEmailApiResponse : mailslurp.Client.ApiResponse, ISendTestEmailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendTestEmailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendTestEmailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendTestEmailApiResponse(ILogger<SendTestEmailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendWithSchedule(ref Guid inboxId, SendEmailOptions sendEmailOptions, ref Option<DateTime> sendAtTimestamp, ref Option<long> sendAtNowPlusSeconds, ref Option<bool> validateBeforeEnqueue);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sendEmailOptions"></param>
        /// <returns></returns>
        private void ValidateSendWithSchedule(SendEmailOptions sendEmailOptions)
        {
            if (sendEmailOptions == null)
                throw new ArgumentNullException(nameof(sendEmailOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp"></param>
        /// <param name="sendAtNowPlusSeconds"></param>
        /// <param name="validateBeforeEnqueue"></param>
        private void AfterSendWithScheduleDefaultImplementation(ISendWithScheduleApiResponse apiResponseLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions, Option<DateTime> sendAtTimestamp, Option<long> sendAtNowPlusSeconds, Option<bool> validateBeforeEnqueue)
        {
            bool suppressDefaultLog = false;
            AfterSendWithSchedule(ref suppressDefaultLog, apiResponseLocalVar, inboxId, sendEmailOptions, sendAtTimestamp, sendAtNowPlusSeconds, validateBeforeEnqueue);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp"></param>
        /// <param name="sendAtNowPlusSeconds"></param>
        /// <param name="validateBeforeEnqueue"></param>
        partial void AfterSendWithSchedule(ref bool suppressDefaultLog, ISendWithScheduleApiResponse apiResponseLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions, Option<DateTime> sendAtTimestamp, Option<long> sendAtNowPlusSeconds, Option<bool> validateBeforeEnqueue);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp"></param>
        /// <param name="sendAtNowPlusSeconds"></param>
        /// <param name="validateBeforeEnqueue"></param>
        private void OnErrorSendWithScheduleDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions, Option<DateTime> sendAtTimestamp, Option<long> sendAtNowPlusSeconds, Option<bool> validateBeforeEnqueue)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendWithSchedule(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, sendEmailOptions, sendAtTimestamp, sendAtNowPlusSeconds, validateBeforeEnqueue);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp"></param>
        /// <param name="sendAtNowPlusSeconds"></param>
        /// <param name="validateBeforeEnqueue"></param>
        partial void OnErrorSendWithSchedule(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions, Option<DateTime> sendAtTimestamp, Option<long> sendAtNowPlusSeconds, Option<bool> validateBeforeEnqueue);

        /// <summary>
        /// Send email with with delay or schedule Send an email using a delay. Will place the email onto a scheduler that will then be processed and sent. Use delays to schedule email sending.
        /// </summary>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp">Sending timestamp (optional)</param>
        /// <param name="sendAtNowPlusSeconds">Send after n seconds (optional)</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendWithScheduleApiResponse"/>&gt;</returns>
        public async Task<ISendWithScheduleApiResponse> SendWithScheduleOrDefaultAsync(Guid inboxId, SendEmailOptions sendEmailOptions, Option<DateTime> sendAtTimestamp = default, Option<long> sendAtNowPlusSeconds = default, Option<bool> validateBeforeEnqueue = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendWithScheduleAsync(inboxId, sendEmailOptions, sendAtTimestamp, sendAtNowPlusSeconds, validateBeforeEnqueue, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send email with with delay or schedule Send an email using a delay. Will place the email onto a scheduler that will then be processed and sent. Use delays to schedule email sending.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp">Sending timestamp (optional)</param>
        /// <param name="sendAtNowPlusSeconds">Send after n seconds (optional)</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendWithScheduleApiResponse"/>&gt;</returns>
        public async Task<ISendWithScheduleApiResponse> SendWithScheduleAsync(Guid inboxId, SendEmailOptions sendEmailOptions, Option<DateTime> sendAtTimestamp = default, Option<long> sendAtNowPlusSeconds = default, Option<bool> validateBeforeEnqueue = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendWithSchedule(sendEmailOptions);

                FormatSendWithSchedule(ref inboxId, sendEmailOptions, ref sendAtTimestamp, ref sendAtNowPlusSeconds, ref validateBeforeEnqueue);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/with-schedule"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/with-schedule");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (sendAtTimestamp.IsSet)
                        parseQueryStringLocalVar["sendAtTimestamp"] = ClientUtils.ParameterToString(sendAtTimestamp.Value);

                    if (sendAtNowPlusSeconds.IsSet)
                        parseQueryStringLocalVar["sendAtNowPlusSeconds"] = ClientUtils.ParameterToString(sendAtNowPlusSeconds.Value);

                    if (validateBeforeEnqueue.IsSet)
                        parseQueryStringLocalVar["validateBeforeEnqueue"] = ClientUtils.ParameterToString(validateBeforeEnqueue.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (sendEmailOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendEmailOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SendWithScheduleApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendWithScheduleApiResponse>();

                        SendWithScheduleApiResponse apiResponseLocalVar = new SendWithScheduleApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/with-schedule", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendWithScheduleDefaultImplementation(apiResponseLocalVar, inboxId, sendEmailOptions, sendAtTimestamp, sendAtNowPlusSeconds, validateBeforeEnqueue);

                        Events.ExecuteOnSendWithSchedule(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendWithScheduleDefaultImplementation(e, "/inboxes/{inboxId}/with-schedule", uriBuilderLocalVar.Path, inboxId, sendEmailOptions, sendAtTimestamp, sendAtNowPlusSeconds, validateBeforeEnqueue);
                Events.ExecuteOnErrorSendWithSchedule(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendWithScheduleApiResponse"/>
        /// </summary>
        public partial class SendWithScheduleApiResponse : mailslurp.Client.ApiResponse, ISendWithScheduleApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendWithScheduleApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendWithScheduleApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendWithScheduleApiResponse(ILogger<SendWithScheduleApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ScheduledJobDto Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ScheduledJobDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out mailslurp.Model.ScheduledJobDto result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSetInboxFavourited(ref Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <returns></returns>
        private void ValidateSetInboxFavourited(SetInboxFavouritedOptions setInboxFavouritedOptions)
        {
            if (setInboxFavouritedOptions == null)
                throw new ArgumentNullException(nameof(setInboxFavouritedOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="setInboxFavouritedOptions"></param>
        private void AfterSetInboxFavouritedDefaultImplementation(ISetInboxFavouritedApiResponse apiResponseLocalVar, Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions)
        {
            bool suppressDefaultLog = false;
            AfterSetInboxFavourited(ref suppressDefaultLog, apiResponseLocalVar, inboxId, setInboxFavouritedOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="setInboxFavouritedOptions"></param>
        partial void AfterSetInboxFavourited(ref bool suppressDefaultLog, ISetInboxFavouritedApiResponse apiResponseLocalVar, Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="setInboxFavouritedOptions"></param>
        private void OnErrorSetInboxFavouritedDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSetInboxFavourited(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, setInboxFavouritedOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="setInboxFavouritedOptions"></param>
        partial void OnErrorSetInboxFavourited(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions);

        /// <summary>
        /// Set inbox favourited state Set and return new favorite state for an inbox
        /// </summary>
        /// <param name="inboxId">ID of inbox to set favourite state</param>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetInboxFavouritedApiResponse"/>&gt;</returns>
        public async Task<ISetInboxFavouritedApiResponse> SetInboxFavouritedOrDefaultAsync(Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SetInboxFavouritedAsync(inboxId, setInboxFavouritedOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Set inbox favourited state Set and return new favorite state for an inbox
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to set favourite state</param>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetInboxFavouritedApiResponse"/>&gt;</returns>
        public async Task<ISetInboxFavouritedApiResponse> SetInboxFavouritedAsync(Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSetInboxFavourited(setInboxFavouritedOptions);

                FormatSetInboxFavourited(ref inboxId, setInboxFavouritedOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}/favourite"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}/favourite");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    httpRequestMessageLocalVar.Content = (setInboxFavouritedOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(setInboxFavouritedOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("PUT");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SetInboxFavouritedApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SetInboxFavouritedApiResponse>();

                        SetInboxFavouritedApiResponse apiResponseLocalVar = new SetInboxFavouritedApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}/favourite", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSetInboxFavouritedDefaultImplementation(apiResponseLocalVar, inboxId, setInboxFavouritedOptions);

                        Events.ExecuteOnSetInboxFavourited(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSetInboxFavouritedDefaultImplementation(e, "/inboxes/{inboxId}/favourite", uriBuilderLocalVar.Path, inboxId, setInboxFavouritedOptions);
                Events.ExecuteOnErrorSetInboxFavourited(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SetInboxFavouritedApiResponse"/>
        /// </summary>
        public partial class SetInboxFavouritedApiResponse : mailslurp.Client.ApiResponse, ISetInboxFavouritedApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SetInboxFavouritedApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SetInboxFavouritedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SetInboxFavouritedApiResponse(ILogger<SetInboxFavouritedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.InboxDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateImapAccess(UpdateImapAccessOptions updateImapAccessOptions, ref Option<Guid> inboxId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="updateImapAccessOptions"></param>
        /// <returns></returns>
        private void ValidateUpdateImapAccess(UpdateImapAccessOptions updateImapAccessOptions)
        {
            if (updateImapAccessOptions == null)
                throw new ArgumentNullException(nameof(updateImapAccessOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="updateImapAccessOptions"></param>
        /// <param name="inboxId"></param>
        private void AfterUpdateImapAccessDefaultImplementation(IUpdateImapAccessApiResponse apiResponseLocalVar, UpdateImapAccessOptions updateImapAccessOptions, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterUpdateImapAccess(ref suppressDefaultLog, apiResponseLocalVar, updateImapAccessOptions, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="updateImapAccessOptions"></param>
        /// <param name="inboxId"></param>
        partial void AfterUpdateImapAccess(ref bool suppressDefaultLog, IUpdateImapAccessApiResponse apiResponseLocalVar, UpdateImapAccessOptions updateImapAccessOptions, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="updateImapAccessOptions"></param>
        /// <param name="inboxId"></param>
        private void OnErrorUpdateImapAccessDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, UpdateImapAccessOptions updateImapAccessOptions, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateImapAccess(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, updateImapAccessOptions, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="updateImapAccessOptions"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorUpdateImapAccess(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, UpdateImapAccessOptions updateImapAccessOptions, Option<Guid> inboxId);

        /// <summary>
        ///  Update IMAP access usernames and passwords
        /// </summary>
        /// <param name="updateImapAccessOptions"></param>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateImapAccessApiResponse"/>&gt;</returns>
        public async Task<IUpdateImapAccessApiResponse> UpdateImapAccessOrDefaultAsync(UpdateImapAccessOptions updateImapAccessOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateImapAccessAsync(updateImapAccessOptions, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Update IMAP access usernames and passwords
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateImapAccessOptions"></param>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateImapAccessApiResponse"/>&gt;</returns>
        public async Task<IUpdateImapAccessApiResponse> UpdateImapAccessAsync(UpdateImapAccessOptions updateImapAccessOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateImapAccess(updateImapAccessOptions);

                FormatUpdateImapAccess(updateImapAccessOptions, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/imap-access"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/imap-access");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (updateImapAccessOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(updateImapAccessOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = new HttpMethod("PATCH");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UpdateImapAccessApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateImapAccessApiResponse>();

                        UpdateImapAccessApiResponse apiResponseLocalVar = new UpdateImapAccessApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/imap-access", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateImapAccessDefaultImplementation(apiResponseLocalVar, updateImapAccessOptions, inboxId);

                        Events.ExecuteOnUpdateImapAccess(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateImapAccessDefaultImplementation(e, "/inboxes/imap-access", uriBuilderLocalVar.Path, updateImapAccessOptions, inboxId);
                Events.ExecuteOnErrorUpdateImapAccess(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateImapAccessApiResponse"/>
        /// </summary>
        public partial class UpdateImapAccessApiResponse : mailslurp.Client.ApiResponse, IUpdateImapAccessApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateImapAccessApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateImapAccessApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateImapAccessApiResponse(ILogger<UpdateImapAccessApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateInbox(ref Guid inboxId, UpdateInboxOptions updateInboxOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="updateInboxOptions"></param>
        /// <returns></returns>
        private void ValidateUpdateInbox(UpdateInboxOptions updateInboxOptions)
        {
            if (updateInboxOptions == null)
                throw new ArgumentNullException(nameof(updateInboxOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        private void AfterUpdateInboxDefaultImplementation(IUpdateInboxApiResponse apiResponseLocalVar, Guid inboxId, UpdateInboxOptions updateInboxOptions)
        {
            bool suppressDefaultLog = false;
            AfterUpdateInbox(ref suppressDefaultLog, apiResponseLocalVar, inboxId, updateInboxOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        partial void AfterUpdateInbox(ref bool suppressDefaultLog, IUpdateInboxApiResponse apiResponseLocalVar, Guid inboxId, UpdateInboxOptions updateInboxOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        private void OnErrorUpdateInboxDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, UpdateInboxOptions updateInboxOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateInbox(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, updateInboxOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        partial void OnErrorUpdateInbox(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, UpdateInboxOptions updateInboxOptions);

        /// <summary>
        /// Update Inbox. Change name and description. Email address is not editable. Update editable fields on an inbox
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateInboxApiResponse"/>&gt;</returns>
        public async Task<IUpdateInboxApiResponse> UpdateInboxOrDefaultAsync(Guid inboxId, UpdateInboxOptions updateInboxOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateInboxAsync(inboxId, updateInboxOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update Inbox. Change name and description. Email address is not editable. Update editable fields on an inbox
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateInboxApiResponse"/>&gt;</returns>
        public async Task<IUpdateInboxApiResponse> UpdateInboxAsync(Guid inboxId, UpdateInboxOptions updateInboxOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateInbox(updateInboxOptions);

                FormatUpdateInbox(ref inboxId, updateInboxOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/{inboxId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/{inboxId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    httpRequestMessageLocalVar.Content = (updateInboxOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(updateInboxOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("PATCH");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UpdateInboxApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateInboxApiResponse>();

                        UpdateInboxApiResponse apiResponseLocalVar = new UpdateInboxApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/{inboxId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateInboxDefaultImplementation(apiResponseLocalVar, inboxId, updateInboxOptions);

                        Events.ExecuteOnUpdateInbox(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateInboxDefaultImplementation(e, "/inboxes/{inboxId}", uriBuilderLocalVar.Path, inboxId, updateInboxOptions);
                Events.ExecuteOnErrorUpdateInbox(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateInboxApiResponse"/>
        /// </summary>
        public partial class UpdateInboxApiResponse : mailslurp.Client.ApiResponse, IUpdateInboxApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateInboxApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateInboxApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateInboxApiResponse(ILogger<UpdateInboxApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.InboxDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateSmtpAccess(UpdateSmtpAccessOptions updateSmtpAccessOptions, ref Option<Guid> inboxId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="updateSmtpAccessOptions"></param>
        /// <returns></returns>
        private void ValidateUpdateSmtpAccess(UpdateSmtpAccessOptions updateSmtpAccessOptions)
        {
            if (updateSmtpAccessOptions == null)
                throw new ArgumentNullException(nameof(updateSmtpAccessOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="updateSmtpAccessOptions"></param>
        /// <param name="inboxId"></param>
        private void AfterUpdateSmtpAccessDefaultImplementation(IUpdateSmtpAccessApiResponse apiResponseLocalVar, UpdateSmtpAccessOptions updateSmtpAccessOptions, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterUpdateSmtpAccess(ref suppressDefaultLog, apiResponseLocalVar, updateSmtpAccessOptions, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="updateSmtpAccessOptions"></param>
        /// <param name="inboxId"></param>
        partial void AfterUpdateSmtpAccess(ref bool suppressDefaultLog, IUpdateSmtpAccessApiResponse apiResponseLocalVar, UpdateSmtpAccessOptions updateSmtpAccessOptions, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="updateSmtpAccessOptions"></param>
        /// <param name="inboxId"></param>
        private void OnErrorUpdateSmtpAccessDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, UpdateSmtpAccessOptions updateSmtpAccessOptions, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateSmtpAccess(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, updateSmtpAccessOptions, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="updateSmtpAccessOptions"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorUpdateSmtpAccess(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, UpdateSmtpAccessOptions updateSmtpAccessOptions, Option<Guid> inboxId);

        /// <summary>
        ///  Update SMTP access usernames and passwords
        /// </summary>
        /// <param name="updateSmtpAccessOptions"></param>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateSmtpAccessApiResponse"/>&gt;</returns>
        public async Task<IUpdateSmtpAccessApiResponse> UpdateSmtpAccessOrDefaultAsync(UpdateSmtpAccessOptions updateSmtpAccessOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateSmtpAccessAsync(updateSmtpAccessOptions, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Update SMTP access usernames and passwords
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateSmtpAccessOptions"></param>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateSmtpAccessApiResponse"/>&gt;</returns>
        public async Task<IUpdateSmtpAccessApiResponse> UpdateSmtpAccessAsync(UpdateSmtpAccessOptions updateSmtpAccessOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateSmtpAccess(updateSmtpAccessOptions);

                FormatUpdateSmtpAccess(updateSmtpAccessOptions, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/inboxes/smtp-access"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/inboxes/smtp-access");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (updateSmtpAccessOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(updateSmtpAccessOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = new HttpMethod("PATCH");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UpdateSmtpAccessApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateSmtpAccessApiResponse>();

                        UpdateSmtpAccessApiResponse apiResponseLocalVar = new UpdateSmtpAccessApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/inboxes/smtp-access", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateSmtpAccessDefaultImplementation(apiResponseLocalVar, updateSmtpAccessOptions, inboxId);

                        Events.ExecuteOnUpdateSmtpAccess(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateSmtpAccessDefaultImplementation(e, "/inboxes/smtp-access", uriBuilderLocalVar.Path, updateSmtpAccessOptions, inboxId);
                Events.ExecuteOnErrorUpdateSmtpAccess(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateSmtpAccessApiResponse"/>
        /// </summary>
        public partial class UpdateSmtpAccessApiResponse : mailslurp.Client.ApiResponse, IUpdateSmtpAccessApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateSmtpAccessApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateSmtpAccessApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateSmtpAccessApiResponse(ILogger<UpdateSmtpAccessApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
