/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IInboxControllerApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Cancel a scheduled email job
        /// </summary>
        /// <remarks>
        /// Get a scheduled email job and cancel it. Will fail if status of job is already cancelled, failed, or complete.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ScheduledJobDto</returns>
        ScheduledJobDto CancelScheduledJob(Guid jobId, int operationIndex = 0);

        /// <summary>
        /// Cancel a scheduled email job
        /// </summary>
        /// <remarks>
        /// Get a scheduled email job and cancel it. Will fail if status of job is already cancelled, failed, or complete.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ScheduledJobDto</returns>
        ApiResponse<ScheduledJobDto> CancelScheduledJobWithHttpInfo(Guid jobId, int operationIndex = 0);
        /// <summary>
        /// Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either &#x60;SMTP&#x60; or &#x60;HTTP&#x60; inboxes.
        /// </summary>
        /// <remarks>
        /// Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Avoid &#x60;SMTP&#x60; inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID. (optional)</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI. (optional)</param>
        /// <param name="name">Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails. (optional)</param>
        /// <param name="description">Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with (optional)</param>
        /// <param name="useDomainPool">Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types. (optional)</param>
        /// <param name="favourite">Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering (optional)</param>
        /// <param name="expiresAt">Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)</param>
        /// <param name="expiresIn">Number of milliseconds that inbox should exist for (optional)</param>
        /// <param name="allowTeamAccess">DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization. (optional)</param>
        /// <param name="inboxType">HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mx.mailslurp.com&#x60;. (optional)</param>
        /// <param name="virtualInbox">Virtual inbox prevents any outbound emails from being sent. It creates sent email records but will never send real emails to recipients. Great for testing and faking email sending. (optional)</param>
        /// <param name="useShortAddress">Use a shorter email address under 31 characters (optional)</param>
        /// <param name="domainId">ID of custom domain to use for email address. (optional)</param>
        /// <param name="domainName">FQDN domain name for the domain you have verified. Will be appended with a randomly assigned recipient name. Use the &#x60;emailAddress&#x60; option instead to specify the full custom inbox. (optional)</param>
        /// <param name="prefix">Prefix to add before the email address for easier labelling or identification. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxDto</returns>
        InboxDto CreateInbox(string emailAddress = default(string), List<string> tags = default(List<string>), string name = default(string), string description = default(string), bool? useDomainPool = default(bool?), bool? favourite = default(bool?), DateTime? expiresAt = default(DateTime?), long? expiresIn = default(long?), bool? allowTeamAccess = default(bool?), string inboxType = default(string), bool? virtualInbox = default(bool?), bool? useShortAddress = default(bool?), Guid? domainId = default(Guid?), string domainName = default(string), string prefix = default(string), int operationIndex = 0);

        /// <summary>
        /// Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either &#x60;SMTP&#x60; or &#x60;HTTP&#x60; inboxes.
        /// </summary>
        /// <remarks>
        /// Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Avoid &#x60;SMTP&#x60; inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID. (optional)</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI. (optional)</param>
        /// <param name="name">Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails. (optional)</param>
        /// <param name="description">Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with (optional)</param>
        /// <param name="useDomainPool">Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types. (optional)</param>
        /// <param name="favourite">Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering (optional)</param>
        /// <param name="expiresAt">Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)</param>
        /// <param name="expiresIn">Number of milliseconds that inbox should exist for (optional)</param>
        /// <param name="allowTeamAccess">DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization. (optional)</param>
        /// <param name="inboxType">HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mx.mailslurp.com&#x60;. (optional)</param>
        /// <param name="virtualInbox">Virtual inbox prevents any outbound emails from being sent. It creates sent email records but will never send real emails to recipients. Great for testing and faking email sending. (optional)</param>
        /// <param name="useShortAddress">Use a shorter email address under 31 characters (optional)</param>
        /// <param name="domainId">ID of custom domain to use for email address. (optional)</param>
        /// <param name="domainName">FQDN domain name for the domain you have verified. Will be appended with a randomly assigned recipient name. Use the &#x60;emailAddress&#x60; option instead to specify the full custom inbox. (optional)</param>
        /// <param name="prefix">Prefix to add before the email address for easier labelling or identification. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxDto</returns>
        ApiResponse<InboxDto> CreateInboxWithHttpInfo(string emailAddress = default(string), List<string> tags = default(List<string>), string name = default(string), string description = default(string), bool? useDomainPool = default(bool?), bool? favourite = default(bool?), DateTime? expiresAt = default(DateTime?), long? expiresIn = default(long?), bool? allowTeamAccess = default(bool?), string inboxType = default(string), bool? virtualInbox = default(bool?), bool? useShortAddress = default(bool?), Guid? domainId = default(Guid?), string domainName = default(string), string prefix = default(string), int operationIndex = 0);
        /// <summary>
        /// Create an inbox ruleset
        /// </summary>
        /// <remarks>
        /// Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">inboxId</param>
        /// <param name="createInboxRulesetOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxRulesetDto</returns>
        InboxRulesetDto CreateInboxRuleset(Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions, int operationIndex = 0);

        /// <summary>
        /// Create an inbox ruleset
        /// </summary>
        /// <remarks>
        /// Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">inboxId</param>
        /// <param name="createInboxRulesetOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxRulesetDto</returns>
        ApiResponse<InboxRulesetDto> CreateInboxRulesetWithHttpInfo(Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions, int operationIndex = 0);
        /// <summary>
        /// Create an inbox with default options. Uses MailSlurp domain pool address and is private.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxDto</returns>
        InboxDto CreateInboxWithDefaults(int operationIndex = 0);

        /// <summary>
        /// Create an inbox with default options. Uses MailSlurp domain pool address and is private.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxDto</returns>
        ApiResponse<InboxDto> CreateInboxWithDefaultsWithHttpInfo(int operationIndex = 0);
        /// <summary>
        /// Create an inbox with options. Extended options for inbox creation.
        /// </summary>
        /// <remarks>
        /// Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createInboxDto"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxDto</returns>
        InboxDto CreateInboxWithOptions(CreateInboxDto createInboxDto, int operationIndex = 0);

        /// <summary>
        /// Create an inbox with options. Extended options for inbox creation.
        /// </summary>
        /// <remarks>
        /// Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createInboxDto"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxDto</returns>
        ApiResponse<InboxDto> CreateInboxWithOptionsWithHttpInfo(CreateInboxDto createInboxDto, int operationIndex = 0);
        /// <summary>
        /// Delete all emails in a given inboxes.
        /// </summary>
        /// <remarks>
        /// Deletes all emails in an inbox. Be careful as emails cannot be recovered
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteAllInboxEmails(Guid inboxId, int operationIndex = 0);

        /// <summary>
        /// Delete all emails in a given inboxes.
        /// </summary>
        /// <remarks>
        /// Deletes all emails in an inbox. Be careful as emails cannot be recovered
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAllInboxEmailsWithHttpInfo(Guid inboxId, int operationIndex = 0);
        /// <summary>
        /// Delete all inboxes
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteAllInboxes(int operationIndex = 0);

        /// <summary>
        /// Delete all inboxes
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAllInboxesWithHttpInfo(int operationIndex = 0);
        /// <summary>
        /// Delete inboxes by description
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by description
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="description"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteAllInboxesByDescription(string description, int operationIndex = 0);

        /// <summary>
        /// Delete inboxes by description
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by description
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="description"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAllInboxesByDescriptionWithHttpInfo(string description, int operationIndex = 0);
        /// <summary>
        /// Delete inboxes by name
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by name
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteAllInboxesByName(string name, int operationIndex = 0);

        /// <summary>
        /// Delete inboxes by name
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by name
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAllInboxesByNameWithHttpInfo(string name, int operationIndex = 0);
        /// <summary>
        /// Delete inboxes by tag
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by tag
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteAllInboxesByTag(string tag, int operationIndex = 0);

        /// <summary>
        /// Delete inboxes by tag
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by tag
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAllInboxesByTagWithHttpInfo(string tag, int operationIndex = 0);
        /// <summary>
        /// Delete inbox
        /// </summary>
        /// <remarks>
        /// Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteInbox(Guid inboxId, int operationIndex = 0);

        /// <summary>
        /// Delete inbox
        /// </summary>
        /// <remarks>
        /// Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteInboxWithHttpInfo(Guid inboxId, int operationIndex = 0);
        /// <summary>
        /// Does inbox exist
        /// </summary>
        /// <remarks>
        /// Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">Email address</param>
        /// <param name="allowCatchAll"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxExistsDto</returns>
        InboxExistsDto DoesInboxExist(string emailAddress, bool? allowCatchAll = default(bool?), int operationIndex = 0);

        /// <summary>
        /// Does inbox exist
        /// </summary>
        /// <remarks>
        /// Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">Email address</param>
        /// <param name="allowCatchAll"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxExistsDto</returns>
        ApiResponse<InboxExistsDto> DoesInboxExistWithHttpInfo(string emailAddress, bool? allowCatchAll = default(bool?), int operationIndex = 0);
        /// <summary>
        /// Remove expired inboxes
        /// </summary>
        /// <remarks>
        /// Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Optional expired at before flag to flush expired inboxes that have expired before the given time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FlushExpiredInboxesResult</returns>
        FlushExpiredInboxesResult FlushExpired(DateTime? before = default(DateTime?), int operationIndex = 0);

        /// <summary>
        /// Remove expired inboxes
        /// </summary>
        /// <remarks>
        /// Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Optional expired at before flag to flush expired inboxes that have expired before the given time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FlushExpiredInboxesResult</returns>
        ApiResponse<FlushExpiredInboxesResult> FlushExpiredWithHttpInfo(DateTime? before = default(DateTime?), int operationIndex = 0);
        /// <summary>
        /// List All Inboxes Paginated
        /// </summary>
        /// <remarks>
        /// List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageInboxProjection</returns>
        PageInboxProjection GetAllInboxes(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0);

        /// <summary>
        /// List All Inboxes Paginated
        /// </summary>
        /// <remarks>
        /// List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageInboxProjection</returns>
        ApiResponse<PageInboxProjection> GetAllInboxesWithHttpInfo(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0);
        /// <summary>
        /// List All Inboxes Offset Paginated
        /// </summary>
        /// <remarks>
        /// List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageInboxProjection</returns>
        PageInboxProjection GetAllInboxesOffsetPaginated(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0);

        /// <summary>
        /// List All Inboxes Offset Paginated
        /// </summary>
        /// <remarks>
        /// List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageInboxProjection</returns>
        ApiResponse<PageInboxProjection> GetAllInboxesOffsetPaginatedWithHttpInfo(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0);
        /// <summary>
        /// Get all scheduled email sending jobs for account
        /// </summary>
        /// <remarks>
        /// Schedule sending of emails using scheduled jobs. These can be inbox or account level.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageScheduledJobs</returns>
        PageScheduledJobs GetAllScheduledJobs(int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);

        /// <summary>
        /// Get all scheduled email sending jobs for account
        /// </summary>
        /// <remarks>
        /// Schedule sending of emails using scheduled jobs. These can be inbox or account level.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageScheduledJobs</returns>
        ApiResponse<PageScheduledJobs> GetAllScheduledJobsWithHttpInfo(int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get all email delivery statuses for an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in delivery status list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in delivery status list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageDeliveryStatus</returns>
        [Obsolete]
        PageDeliveryStatus GetDeliveryStatusesByInboxId(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get all email delivery statuses for an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in delivery status list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in delivery status list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageDeliveryStatus</returns>
        [Obsolete]
        ApiResponse<PageDeliveryStatus> GetDeliveryStatusesByInboxIdWithHttpInfo(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);
        /// <summary>
        /// Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
        /// </summary>
        /// <remarks>
        /// List emails that an inbox has received. Only emails that are sent to the inbox&#39;s email address will appear in the inbox. It may take several seconds for any email you send to an inbox&#39;s email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the &#x60;minCount&#x60; parameter. The server will retry the inbox database until the &#x60;minCount&#x60; is satisfied or the &#x60;retryTimeout&#x60; is reached
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="size">Alias for limit. Assessed first before assessing any passed limit. (optional)</param>
        /// <param name="limit">Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller (optional)</param>
        /// <param name="sort">Sort the results by received date and direction ASC or DESC (optional)</param>
        /// <param name="retryTimeout">Maximum milliseconds to spend retrying inbox database until minCount emails are returned (optional)</param>
        /// <param name="delayTimeout"> (optional)</param>
        /// <param name="minCount">Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached. (optional)</param>
        /// <param name="unreadOnly"> (optional)</param>
        /// <param name="before">Exclude emails received after this ISO 8601 date time (optional)</param>
        /// <param name="since">Exclude emails received before this ISO 8601 date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        List<EmailPreview> GetEmails(Guid inboxId, int? size = default(int?), int? limit = default(int?), string sort = default(string), long? retryTimeout = default(long?), long? delayTimeout = default(long?), long? minCount = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), int operationIndex = 0);

        /// <summary>
        /// Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
        /// </summary>
        /// <remarks>
        /// List emails that an inbox has received. Only emails that are sent to the inbox&#39;s email address will appear in the inbox. It may take several seconds for any email you send to an inbox&#39;s email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the &#x60;minCount&#x60; parameter. The server will retry the inbox database until the &#x60;minCount&#x60; is satisfied or the &#x60;retryTimeout&#x60; is reached
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="size">Alias for limit. Assessed first before assessing any passed limit. (optional)</param>
        /// <param name="limit">Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller (optional)</param>
        /// <param name="sort">Sort the results by received date and direction ASC or DESC (optional)</param>
        /// <param name="retryTimeout">Maximum milliseconds to spend retrying inbox database until minCount emails are returned (optional)</param>
        /// <param name="delayTimeout"> (optional)</param>
        /// <param name="minCount">Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached. (optional)</param>
        /// <param name="unreadOnly"> (optional)</param>
        /// <param name="before">Exclude emails received after this ISO 8601 date time (optional)</param>
        /// <param name="since">Exclude emails received before this ISO 8601 date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        ApiResponse<List<EmailPreview>> GetEmailsWithHttpInfo(Guid inboxId, int? size = default(int?), int? limit = default(int?), string sort = default(string), long? retryTimeout = default(long?), long? delayTimeout = default(long?), long? minCount = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP access usernames and passwords
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ImapAccessDetails</returns>
        ImapAccessDetails GetImapAccess(Guid? inboxId = default(Guid?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP access usernames and passwords
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ImapAccessDetails</returns>
        ApiResponse<ImapAccessDetails> GetImapAccessWithHttpInfo(Guid? inboxId = default(Guid?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP access usernames and passwords
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ImapSmtpAccessDetails</returns>
        ImapSmtpAccessDetails GetImapSmtpAccess(Guid? inboxId = default(Guid?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP access usernames and passwords
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ImapSmtpAccessDetails</returns>
        ApiResponse<ImapSmtpAccessDetails> GetImapSmtpAccessWithHttpInfo(Guid? inboxId = default(Guid?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP access details in .env format
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        string GetImapSmtpAccessEnv(Guid? inboxId = default(Guid?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP access details in .env format
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> GetImapSmtpAccessEnvWithHttpInfo(Guid? inboxId = default(Guid?), int operationIndex = 0);
        /// <summary>
        /// Get Inbox. Returns properties of an inbox.
        /// </summary>
        /// <remarks>
        /// Returns an inbox&#39;s properties, including its email address and ID.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxDto</returns>
        InboxDto GetInbox(Guid inboxId, int operationIndex = 0);

        /// <summary>
        /// Get Inbox. Returns properties of an inbox.
        /// </summary>
        /// <remarks>
        /// Returns an inbox&#39;s properties, including its email address and ID.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxDto</returns>
        ApiResponse<InboxDto> GetInboxWithHttpInfo(Guid inboxId, int operationIndex = 0);
        /// <summary>
        /// Search for an inbox with the provided email address
        /// </summary>
        /// <remarks>
        /// Get a inbox result by email address
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxByEmailAddressResult</returns>
        InboxByEmailAddressResult GetInboxByEmailAddress(string emailAddress, int operationIndex = 0);

        /// <summary>
        /// Search for an inbox with the provided email address
        /// </summary>
        /// <remarks>
        /// Get a inbox result by email address
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxByEmailAddressResult</returns>
        ApiResponse<InboxByEmailAddressResult> GetInboxByEmailAddressWithHttpInfo(string emailAddress, int operationIndex = 0);
        /// <summary>
        /// Search for an inbox with the given name
        /// </summary>
        /// <remarks>
        /// Get a inbox result by name
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxByNameResult</returns>
        InboxByNameResult GetInboxByName(string name, int operationIndex = 0);

        /// <summary>
        /// Search for an inbox with the given name
        /// </summary>
        /// <remarks>
        /// Get a inbox result by name
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxByNameResult</returns>
        ApiResponse<InboxByNameResult> GetInboxByNameWithHttpInfo(string name, int operationIndex = 0);
        /// <summary>
        /// Get total inbox count
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CountDto</returns>
        CountDto GetInboxCount(int operationIndex = 0);

        /// <summary>
        /// Get total inbox count
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CountDto</returns>
        ApiResponse<CountDto> GetInboxCountWithHttpInfo(int operationIndex = 0);
        /// <summary>
        /// Get email count in inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CountDto</returns>
        CountDto GetInboxEmailCount(Guid inboxId, int operationIndex = 0);

        /// <summary>
        /// Get email count in inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CountDto</returns>
        ApiResponse<CountDto> GetInboxEmailCountWithHttpInfo(Guid inboxId, int operationIndex = 0);
        /// <summary>
        /// Get inbox emails paginated
        /// </summary>
        /// <remarks>
        /// Get a paginated list of emails in an inbox. Does not hold connections open.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="page">Optional page index in inbox emails list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox emails list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by received after given date time (optional)</param>
        /// <param name="before">Optional filter by received before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageEmailPreview</returns>
        PageEmailPreview GetInboxEmailsPaginated(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);

        /// <summary>
        /// Get inbox emails paginated
        /// </summary>
        /// <remarks>
        /// Get a paginated list of emails in an inbox. Does not hold connections open.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="page">Optional page index in inbox emails list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox emails list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by received after given date time (optional)</param>
        /// <param name="before">Optional filter by received before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageEmailPreview</returns>
        ApiResponse<PageEmailPreview> GetInboxEmailsPaginatedWithHttpInfo(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);
        /// <summary>
        /// Get all inbox IDs
        /// </summary>
        /// <remarks>
        /// Get list of inbox IDs
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxIdsResult</returns>
        [Obsolete]
        InboxIdsResult GetInboxIds(int operationIndex = 0);

        /// <summary>
        /// Get all inbox IDs
        /// </summary>
        /// <remarks>
        /// Get list of inbox IDs
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxIdsResult</returns>
        [Obsolete]
        ApiResponse<InboxIdsResult> GetInboxIdsWithHttpInfo(int operationIndex = 0);
        /// <summary>
        /// Get Inbox Sent Emails
        /// </summary>
        /// <remarks>
        /// Returns an inbox&#39;s sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional sent email search (optional)</param>
        /// <param name="since">Optional filter by sent after given date time (optional)</param>
        /// <param name="before">Optional filter by sent before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageSentEmailProjection</returns>
        [Obsolete]
        PageSentEmailProjection GetInboxSentEmails(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);

        /// <summary>
        /// Get Inbox Sent Emails
        /// </summary>
        /// <remarks>
        /// Returns an inbox&#39;s sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional sent email search (optional)</param>
        /// <param name="since">Optional filter by sent after given date time (optional)</param>
        /// <param name="before">Optional filter by sent before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageSentEmailProjection</returns>
        [Obsolete]
        ApiResponse<PageSentEmailProjection> GetInboxSentEmailsWithHttpInfo(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);
        /// <summary>
        /// Get inbox tags
        /// </summary>
        /// <remarks>
        /// Get all inbox tags
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;string&gt;</returns>
        [Obsolete]
        List<string> GetInboxTags(int operationIndex = 0);

        /// <summary>
        /// Get inbox tags
        /// </summary>
        /// <remarks>
        /// Get all inbox tags
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;string&gt;</returns>
        [Obsolete]
        ApiResponse<List<string>> GetInboxTagsWithHttpInfo(int operationIndex = 0);
        /// <summary>
        /// List Inboxes and email addresses
        /// </summary>
        /// <remarks>
        /// List the inboxes you have created. Note use of the more advanced &#x60;getAllInboxes&#x60; is recommended and allows paginated access using a limit and sort parameter.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries. (optional, default to 100)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="excludeCatchAllInboxes">Optional exclude catch all inboxes (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;InboxDto&gt;</returns>
        [Obsolete]
        List<InboxDto> GetInboxes(int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), bool? excludeCatchAllInboxes = default(bool?), DateTime? before = default(DateTime?), int operationIndex = 0);

        /// <summary>
        /// List Inboxes and email addresses
        /// </summary>
        /// <remarks>
        /// List the inboxes you have created. Note use of the more advanced &#x60;getAllInboxes&#x60; is recommended and allows paginated access using a limit and sort parameter.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries. (optional, default to 100)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="excludeCatchAllInboxes">Optional exclude catch all inboxes (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;InboxDto&gt;</returns>
        [Obsolete]
        ApiResponse<List<InboxDto>> GetInboxesWithHttpInfo(int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), bool? excludeCatchAllInboxes = default(bool?), DateTime? before = default(DateTime?), int operationIndex = 0);
        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.
        /// </summary>
        /// <remarks>
        /// Get the newest email in an inbox or wait for one to arrive
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="timeoutMillis">Timeout milliseconds to wait for latest email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        Email GetLatestEmailInInbox(Guid inboxId, long timeoutMillis, int operationIndex = 0);

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.
        /// </summary>
        /// <remarks>
        /// Get the newest email in an inbox or wait for one to arrive
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="timeoutMillis">Timeout milliseconds to wait for latest email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        ApiResponse<Email> GetLatestEmailInInboxWithHttpInfo(Guid inboxId, long timeoutMillis, int operationIndex = 0);
        /// <summary>
        /// List Organization Inboxes Paginated
        /// </summary>
        /// <remarks>
        /// List organization inboxes in paginated form. These are inboxes created with &#x60;allowTeamAccess&#x60; flag enabled. Organization inboxes are &#x60;readOnly&#x60; for non-admin users. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageOrganizationInboxProjection</returns>
        [Obsolete]
        PageOrganizationInboxProjection GetOrganizationInboxes(int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);

        /// <summary>
        /// List Organization Inboxes Paginated
        /// </summary>
        /// <remarks>
        /// List organization inboxes in paginated form. These are inboxes created with &#x60;allowTeamAccess&#x60; flag enabled. Organization inboxes are &#x60;readOnly&#x60; for non-admin users. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageOrganizationInboxProjection</returns>
        [Obsolete]
        ApiResponse<PageOrganizationInboxProjection> GetOrganizationInboxesWithHttpInfo(int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);
        /// <summary>
        /// Get a scheduled email job
        /// </summary>
        /// <remarks>
        /// Get a scheduled email job details.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ScheduledJobDto</returns>
        ScheduledJobDto GetScheduledJob(Guid jobId, int operationIndex = 0);

        /// <summary>
        /// Get a scheduled email job
        /// </summary>
        /// <remarks>
        /// Get a scheduled email job details.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ScheduledJobDto</returns>
        ApiResponse<ScheduledJobDto> GetScheduledJobWithHttpInfo(Guid jobId, int operationIndex = 0);
        /// <summary>
        /// Get all scheduled email sending jobs for the inbox
        /// </summary>
        /// <remarks>
        /// Schedule sending of emails using scheduled jobs.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageScheduledJobs</returns>
        PageScheduledJobs GetScheduledJobsByInboxId(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);

        /// <summary>
        /// Get all scheduled email sending jobs for the inbox
        /// </summary>
        /// <remarks>
        /// Schedule sending of emails using scheduled jobs.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageScheduledJobs</returns>
        ApiResponse<PageScheduledJobs> GetScheduledJobsByInboxIdWithHttpInfo(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get SMTP access usernames and passwords
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SmtpAccessDetails</returns>
        SmtpAccessDetails GetSmtpAccess(Guid? inboxId = default(Guid?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get SMTP access usernames and passwords
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SmtpAccessDetails</returns>
        ApiResponse<SmtpAccessDetails> GetSmtpAccessWithHttpInfo(Guid? inboxId = default(Guid?), int operationIndex = 0);
        /// <summary>
        /// List inbox rulesets
        /// </summary>
        /// <remarks>
        /// List all rulesets attached to an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox ruleset list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox ruleset list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageInboxRulesetDto</returns>
        PageInboxRulesetDto ListInboxRulesets(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);

        /// <summary>
        /// List inbox rulesets
        /// </summary>
        /// <remarks>
        /// List all rulesets attached to an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox ruleset list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox ruleset list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageInboxRulesetDto</returns>
        ApiResponse<PageInboxRulesetDto> ListInboxRulesetsWithHttpInfo(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);
        /// <summary>
        /// List inbox tracking pixels
        /// </summary>
        /// <remarks>
        /// List all tracking pixels sent from an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageTrackingPixelProjection</returns>
        PageTrackingPixelProjection ListInboxTrackingPixels(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);

        /// <summary>
        /// List inbox tracking pixels
        /// </summary>
        /// <remarks>
        /// List all tracking pixels sent from an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageTrackingPixelProjection</returns>
        ApiResponse<PageTrackingPixelProjection> ListInboxTrackingPixelsWithHttpInfo(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0);
        /// <summary>
        /// Search all inboxes and return matching inboxes
        /// </summary>
        /// <remarks>
        /// Search inboxes and return in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchInboxesOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageInboxProjection</returns>
        PageInboxProjection SearchInboxes(SearchInboxesOptions searchInboxesOptions, int operationIndex = 0);

        /// <summary>
        /// Search all inboxes and return matching inboxes
        /// </summary>
        /// <remarks>
        /// Search inboxes and return in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchInboxesOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageInboxProjection</returns>
        ApiResponse<PageInboxProjection> SearchInboxesWithHttpInfo(SearchInboxesOptions searchInboxesOptions, int operationIndex = 0);
        /// <summary>
        /// Send Email
        /// </summary>
        /// <remarks>
        /// Send an email from an inbox&#39;s email address.  The request body should contain the &#x60;SendEmailOptions&#x60; that include recipients, attachments, body etc. See &#x60;SendEmailOptions&#x60; for all available properties. Note the &#x60;inboxId&#x60; refers to the inbox&#39;s id not the inbox&#39;s email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method &#x60;sendEmailAndConfirm&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void SendEmail(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0);

        /// <summary>
        /// Send Email
        /// </summary>
        /// <remarks>
        /// Send an email from an inbox&#39;s email address.  The request body should contain the &#x60;SendEmailOptions&#x60; that include recipients, attachments, body etc. See &#x60;SendEmailOptions&#x60; for all available properties. Note the &#x60;inboxId&#x60; refers to the inbox&#39;s id not the inbox&#39;s email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method &#x60;sendEmailAndConfirm&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SendEmailWithHttpInfo(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0);
        /// <summary>
        /// Send email and return sent confirmation
        /// </summary>
        /// <remarks>
        /// Sister method for standard &#x60;sendEmail&#x60; method with the benefit of returning a &#x60;SentEmail&#x60; entity confirming the successful sending of the email with a link to the sent object created for it.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SentEmailDto</returns>
        SentEmailDto SendEmailAndConfirm(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0);

        /// <summary>
        /// Send email and return sent confirmation
        /// </summary>
        /// <remarks>
        /// Sister method for standard &#x60;sendEmail&#x60; method with the benefit of returning a &#x60;SentEmail&#x60; entity confirming the successful sending of the email with a link to the sent object created for it.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SentEmailDto</returns>
        ApiResponse<SentEmailDto> SendEmailAndConfirmWithHttpInfo(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0);
        /// <summary>
        /// Send email with queue
        /// </summary>
        /// <remarks>
        /// Send an email using a queue. Will place the email onto a queue that will then be processed and sent. Use this queue method to enable any failed email sending to be recovered. This will prevent lost emails when sending if your account encounters a block or payment issue.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void SendEmailWithQueue(Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions, int operationIndex = 0);

        /// <summary>
        /// Send email with queue
        /// </summary>
        /// <remarks>
        /// Send an email using a queue. Will place the email onto a queue that will then be processed and sent. Use this queue method to enable any failed email sending to be recovered. This will prevent lost emails when sending if your account encounters a block or payment issue.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SendEmailWithQueueWithHttpInfo(Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions, int operationIndex = 0);
        /// <summary>
        /// Send email using an SMTP mail envelope and message body and return sent confirmation
        /// </summary>
        /// <remarks>
        /// Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SentEmailDto</returns>
        SentEmailDto SendSmtpEnvelope(Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions, int operationIndex = 0);

        /// <summary>
        /// Send email using an SMTP mail envelope and message body and return sent confirmation
        /// </summary>
        /// <remarks>
        /// Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SentEmailDto</returns>
        ApiResponse<SentEmailDto> SendSmtpEnvelopeWithHttpInfo(Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions, int operationIndex = 0);
        /// <summary>
        /// Send a test email to inbox
        /// </summary>
        /// <remarks>
        /// Send an inbox a test email to test email receiving is working
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void SendTestEmail(Guid inboxId, int operationIndex = 0);

        /// <summary>
        /// Send a test email to inbox
        /// </summary>
        /// <remarks>
        /// Send an inbox a test email to test email receiving is working
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SendTestEmailWithHttpInfo(Guid inboxId, int operationIndex = 0);
        /// <summary>
        /// Send email with with delay or schedule
        /// </summary>
        /// <remarks>
        /// Send an email using a delay. Will place the email onto a scheduler that will then be processed and sent. Use delays to schedule email sending.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp">Sending timestamp (optional)</param>
        /// <param name="sendAtNowPlusSeconds">Send after n seconds (optional)</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ScheduledJobDto</returns>
        ScheduledJobDto SendWithSchedule(Guid inboxId, SendEmailOptions sendEmailOptions, DateTime? sendAtTimestamp = default(DateTime?), long? sendAtNowPlusSeconds = default(long?), bool? validateBeforeEnqueue = default(bool?), int operationIndex = 0);

        /// <summary>
        /// Send email with with delay or schedule
        /// </summary>
        /// <remarks>
        /// Send an email using a delay. Will place the email onto a scheduler that will then be processed and sent. Use delays to schedule email sending.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp">Sending timestamp (optional)</param>
        /// <param name="sendAtNowPlusSeconds">Send after n seconds (optional)</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ScheduledJobDto</returns>
        ApiResponse<ScheduledJobDto> SendWithScheduleWithHttpInfo(Guid inboxId, SendEmailOptions sendEmailOptions, DateTime? sendAtTimestamp = default(DateTime?), long? sendAtNowPlusSeconds = default(long?), bool? validateBeforeEnqueue = default(bool?), int operationIndex = 0);
        /// <summary>
        /// Set inbox favourited state
        /// </summary>
        /// <remarks>
        /// Set and return new favourite state for an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to set favourite state</param>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxDto</returns>
        InboxDto SetInboxFavourited(Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions, int operationIndex = 0);

        /// <summary>
        /// Set inbox favourited state
        /// </summary>
        /// <remarks>
        /// Set and return new favourite state for an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to set favourite state</param>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxDto</returns>
        ApiResponse<InboxDto> SetInboxFavouritedWithHttpInfo(Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions, int operationIndex = 0);
        /// <summary>
        /// Update Inbox. Change name and description. Email address is not editable.
        /// </summary>
        /// <remarks>
        /// Update editable fields on an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxDto</returns>
        InboxDto UpdateInbox(Guid inboxId, UpdateInboxOptions updateInboxOptions, int operationIndex = 0);

        /// <summary>
        /// Update Inbox. Change name and description. Email address is not editable.
        /// </summary>
        /// <remarks>
        /// Update editable fields on an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxDto</returns>
        ApiResponse<InboxDto> UpdateInboxWithHttpInfo(Guid inboxId, UpdateInboxOptions updateInboxOptions, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IInboxControllerApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Cancel a scheduled email job
        /// </summary>
        /// <remarks>
        /// Get a scheduled email job and cancel it. Will fail if status of job is already cancelled, failed, or complete.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ScheduledJobDto</returns>
        System.Threading.Tasks.Task<ScheduledJobDto> CancelScheduledJobAsync(Guid jobId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Cancel a scheduled email job
        /// </summary>
        /// <remarks>
        /// Get a scheduled email job and cancel it. Will fail if status of job is already cancelled, failed, or complete.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ScheduledJobDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<ScheduledJobDto>> CancelScheduledJobWithHttpInfoAsync(Guid jobId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either &#x60;SMTP&#x60; or &#x60;HTTP&#x60; inboxes.
        /// </summary>
        /// <remarks>
        /// Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Avoid &#x60;SMTP&#x60; inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID. (optional)</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI. (optional)</param>
        /// <param name="name">Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails. (optional)</param>
        /// <param name="description">Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with (optional)</param>
        /// <param name="useDomainPool">Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types. (optional)</param>
        /// <param name="favourite">Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering (optional)</param>
        /// <param name="expiresAt">Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)</param>
        /// <param name="expiresIn">Number of milliseconds that inbox should exist for (optional)</param>
        /// <param name="allowTeamAccess">DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization. (optional)</param>
        /// <param name="inboxType">HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mx.mailslurp.com&#x60;. (optional)</param>
        /// <param name="virtualInbox">Virtual inbox prevents any outbound emails from being sent. It creates sent email records but will never send real emails to recipients. Great for testing and faking email sending. (optional)</param>
        /// <param name="useShortAddress">Use a shorter email address under 31 characters (optional)</param>
        /// <param name="domainId">ID of custom domain to use for email address. (optional)</param>
        /// <param name="domainName">FQDN domain name for the domain you have verified. Will be appended with a randomly assigned recipient name. Use the &#x60;emailAddress&#x60; option instead to specify the full custom inbox. (optional)</param>
        /// <param name="prefix">Prefix to add before the email address for easier labelling or identification. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxDto</returns>
        System.Threading.Tasks.Task<InboxDto> CreateInboxAsync(string emailAddress = default(string), List<string> tags = default(List<string>), string name = default(string), string description = default(string), bool? useDomainPool = default(bool?), bool? favourite = default(bool?), DateTime? expiresAt = default(DateTime?), long? expiresIn = default(long?), bool? allowTeamAccess = default(bool?), string inboxType = default(string), bool? virtualInbox = default(bool?), bool? useShortAddress = default(bool?), Guid? domainId = default(Guid?), string domainName = default(string), string prefix = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either &#x60;SMTP&#x60; or &#x60;HTTP&#x60; inboxes.
        /// </summary>
        /// <remarks>
        /// Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Avoid &#x60;SMTP&#x60; inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID. (optional)</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI. (optional)</param>
        /// <param name="name">Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails. (optional)</param>
        /// <param name="description">Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with (optional)</param>
        /// <param name="useDomainPool">Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types. (optional)</param>
        /// <param name="favourite">Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering (optional)</param>
        /// <param name="expiresAt">Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)</param>
        /// <param name="expiresIn">Number of milliseconds that inbox should exist for (optional)</param>
        /// <param name="allowTeamAccess">DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization. (optional)</param>
        /// <param name="inboxType">HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mx.mailslurp.com&#x60;. (optional)</param>
        /// <param name="virtualInbox">Virtual inbox prevents any outbound emails from being sent. It creates sent email records but will never send real emails to recipients. Great for testing and faking email sending. (optional)</param>
        /// <param name="useShortAddress">Use a shorter email address under 31 characters (optional)</param>
        /// <param name="domainId">ID of custom domain to use for email address. (optional)</param>
        /// <param name="domainName">FQDN domain name for the domain you have verified. Will be appended with a randomly assigned recipient name. Use the &#x60;emailAddress&#x60; option instead to specify the full custom inbox. (optional)</param>
        /// <param name="prefix">Prefix to add before the email address for easier labelling or identification. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<InboxDto>> CreateInboxWithHttpInfoAsync(string emailAddress = default(string), List<string> tags = default(List<string>), string name = default(string), string description = default(string), bool? useDomainPool = default(bool?), bool? favourite = default(bool?), DateTime? expiresAt = default(DateTime?), long? expiresIn = default(long?), bool? allowTeamAccess = default(bool?), string inboxType = default(string), bool? virtualInbox = default(bool?), bool? useShortAddress = default(bool?), Guid? domainId = default(Guid?), string domainName = default(string), string prefix = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create an inbox ruleset
        /// </summary>
        /// <remarks>
        /// Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">inboxId</param>
        /// <param name="createInboxRulesetOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxRulesetDto</returns>
        System.Threading.Tasks.Task<InboxRulesetDto> CreateInboxRulesetAsync(Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create an inbox ruleset
        /// </summary>
        /// <remarks>
        /// Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">inboxId</param>
        /// <param name="createInboxRulesetOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxRulesetDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<InboxRulesetDto>> CreateInboxRulesetWithHttpInfoAsync(Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create an inbox with default options. Uses MailSlurp domain pool address and is private.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxDto</returns>
        System.Threading.Tasks.Task<InboxDto> CreateInboxWithDefaultsAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create an inbox with default options. Uses MailSlurp domain pool address and is private.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<InboxDto>> CreateInboxWithDefaultsWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create an inbox with options. Extended options for inbox creation.
        /// </summary>
        /// <remarks>
        /// Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createInboxDto"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxDto</returns>
        System.Threading.Tasks.Task<InboxDto> CreateInboxWithOptionsAsync(CreateInboxDto createInboxDto, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create an inbox with options. Extended options for inbox creation.
        /// </summary>
        /// <remarks>
        /// Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createInboxDto"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<InboxDto>> CreateInboxWithOptionsWithHttpInfoAsync(CreateInboxDto createInboxDto, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete all emails in a given inboxes.
        /// </summary>
        /// <remarks>
        /// Deletes all emails in an inbox. Be careful as emails cannot be recovered
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteAllInboxEmailsAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete all emails in a given inboxes.
        /// </summary>
        /// <remarks>
        /// Deletes all emails in an inbox. Be careful as emails cannot be recovered
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteAllInboxEmailsWithHttpInfoAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete all inboxes
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteAllInboxesAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete all inboxes
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteAllInboxesWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete inboxes by description
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by description
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="description"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteAllInboxesByDescriptionAsync(string description, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete inboxes by description
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by description
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="description"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteAllInboxesByDescriptionWithHttpInfoAsync(string description, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete inboxes by name
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by name
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteAllInboxesByNameAsync(string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete inboxes by name
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by name
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteAllInboxesByNameWithHttpInfoAsync(string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete inboxes by tag
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by tag
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteAllInboxesByTagAsync(string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete inboxes by tag
        /// </summary>
        /// <remarks>
        /// Permanently delete all inboxes by tag
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteAllInboxesByTagWithHttpInfoAsync(string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete inbox
        /// </summary>
        /// <remarks>
        /// Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteInboxAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete inbox
        /// </summary>
        /// <remarks>
        /// Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteInboxWithHttpInfoAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Does inbox exist
        /// </summary>
        /// <remarks>
        /// Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">Email address</param>
        /// <param name="allowCatchAll"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxExistsDto</returns>
        System.Threading.Tasks.Task<InboxExistsDto> DoesInboxExistAsync(string emailAddress, bool? allowCatchAll = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Does inbox exist
        /// </summary>
        /// <remarks>
        /// Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">Email address</param>
        /// <param name="allowCatchAll"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxExistsDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<InboxExistsDto>> DoesInboxExistWithHttpInfoAsync(string emailAddress, bool? allowCatchAll = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Remove expired inboxes
        /// </summary>
        /// <remarks>
        /// Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Optional expired at before flag to flush expired inboxes that have expired before the given time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FlushExpiredInboxesResult</returns>
        System.Threading.Tasks.Task<FlushExpiredInboxesResult> FlushExpiredAsync(DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Remove expired inboxes
        /// </summary>
        /// <remarks>
        /// Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Optional expired at before flag to flush expired inboxes that have expired before the given time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FlushExpiredInboxesResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<FlushExpiredInboxesResult>> FlushExpiredWithHttpInfoAsync(DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List All Inboxes Paginated
        /// </summary>
        /// <remarks>
        /// List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageInboxProjection</returns>
        System.Threading.Tasks.Task<PageInboxProjection> GetAllInboxesAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List All Inboxes Paginated
        /// </summary>
        /// <remarks>
        /// List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageInboxProjection)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageInboxProjection>> GetAllInboxesWithHttpInfoAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List All Inboxes Offset Paginated
        /// </summary>
        /// <remarks>
        /// List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageInboxProjection</returns>
        System.Threading.Tasks.Task<PageInboxProjection> GetAllInboxesOffsetPaginatedAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List All Inboxes Offset Paginated
        /// </summary>
        /// <remarks>
        /// List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageInboxProjection)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageInboxProjection>> GetAllInboxesOffsetPaginatedWithHttpInfoAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get all scheduled email sending jobs for account
        /// </summary>
        /// <remarks>
        /// Schedule sending of emails using scheduled jobs. These can be inbox or account level.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageScheduledJobs</returns>
        System.Threading.Tasks.Task<PageScheduledJobs> GetAllScheduledJobsAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get all scheduled email sending jobs for account
        /// </summary>
        /// <remarks>
        /// Schedule sending of emails using scheduled jobs. These can be inbox or account level.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageScheduledJobs)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageScheduledJobs>> GetAllScheduledJobsWithHttpInfoAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get all email delivery statuses for an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in delivery status list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in delivery status list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageDeliveryStatus</returns>
        [Obsolete]
        System.Threading.Tasks.Task<PageDeliveryStatus> GetDeliveryStatusesByInboxIdAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get all email delivery statuses for an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in delivery status list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in delivery status list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageDeliveryStatus)</returns>
        [Obsolete]
        System.Threading.Tasks.Task<ApiResponse<PageDeliveryStatus>> GetDeliveryStatusesByInboxIdWithHttpInfoAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
        /// </summary>
        /// <remarks>
        /// List emails that an inbox has received. Only emails that are sent to the inbox&#39;s email address will appear in the inbox. It may take several seconds for any email you send to an inbox&#39;s email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the &#x60;minCount&#x60; parameter. The server will retry the inbox database until the &#x60;minCount&#x60; is satisfied or the &#x60;retryTimeout&#x60; is reached
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="size">Alias for limit. Assessed first before assessing any passed limit. (optional)</param>
        /// <param name="limit">Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller (optional)</param>
        /// <param name="sort">Sort the results by received date and direction ASC or DESC (optional)</param>
        /// <param name="retryTimeout">Maximum milliseconds to spend retrying inbox database until minCount emails are returned (optional)</param>
        /// <param name="delayTimeout"> (optional)</param>
        /// <param name="minCount">Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached. (optional)</param>
        /// <param name="unreadOnly"> (optional)</param>
        /// <param name="before">Exclude emails received after this ISO 8601 date time (optional)</param>
        /// <param name="since">Exclude emails received before this ISO 8601 date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        System.Threading.Tasks.Task<List<EmailPreview>> GetEmailsAsync(Guid inboxId, int? size = default(int?), int? limit = default(int?), string sort = default(string), long? retryTimeout = default(long?), long? delayTimeout = default(long?), long? minCount = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
        /// </summary>
        /// <remarks>
        /// List emails that an inbox has received. Only emails that are sent to the inbox&#39;s email address will appear in the inbox. It may take several seconds for any email you send to an inbox&#39;s email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the &#x60;minCount&#x60; parameter. The server will retry the inbox database until the &#x60;minCount&#x60; is satisfied or the &#x60;retryTimeout&#x60; is reached
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="size">Alias for limit. Assessed first before assessing any passed limit. (optional)</param>
        /// <param name="limit">Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller (optional)</param>
        /// <param name="sort">Sort the results by received date and direction ASC or DESC (optional)</param>
        /// <param name="retryTimeout">Maximum milliseconds to spend retrying inbox database until minCount emails are returned (optional)</param>
        /// <param name="delayTimeout"> (optional)</param>
        /// <param name="minCount">Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached. (optional)</param>
        /// <param name="unreadOnly"> (optional)</param>
        /// <param name="before">Exclude emails received after this ISO 8601 date time (optional)</param>
        /// <param name="since">Exclude emails received before this ISO 8601 date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> GetEmailsWithHttpInfoAsync(Guid inboxId, int? size = default(int?), int? limit = default(int?), string sort = default(string), long? retryTimeout = default(long?), long? delayTimeout = default(long?), long? minCount = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP access usernames and passwords
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ImapAccessDetails</returns>
        System.Threading.Tasks.Task<ImapAccessDetails> GetImapAccessAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP access usernames and passwords
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ImapAccessDetails)</returns>
        System.Threading.Tasks.Task<ApiResponse<ImapAccessDetails>> GetImapAccessWithHttpInfoAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP access usernames and passwords
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ImapSmtpAccessDetails</returns>
        System.Threading.Tasks.Task<ImapSmtpAccessDetails> GetImapSmtpAccessAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP access usernames and passwords
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ImapSmtpAccessDetails)</returns>
        System.Threading.Tasks.Task<ApiResponse<ImapSmtpAccessDetails>> GetImapSmtpAccessWithHttpInfoAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP access details in .env format
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> GetImapSmtpAccessEnvAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get IMAP and SMTP access details in .env format
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> GetImapSmtpAccessEnvWithHttpInfoAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Inbox. Returns properties of an inbox.
        /// </summary>
        /// <remarks>
        /// Returns an inbox&#39;s properties, including its email address and ID.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxDto</returns>
        System.Threading.Tasks.Task<InboxDto> GetInboxAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Inbox. Returns properties of an inbox.
        /// </summary>
        /// <remarks>
        /// Returns an inbox&#39;s properties, including its email address and ID.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<InboxDto>> GetInboxWithHttpInfoAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Search for an inbox with the provided email address
        /// </summary>
        /// <remarks>
        /// Get a inbox result by email address
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxByEmailAddressResult</returns>
        System.Threading.Tasks.Task<InboxByEmailAddressResult> GetInboxByEmailAddressAsync(string emailAddress, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Search for an inbox with the provided email address
        /// </summary>
        /// <remarks>
        /// Get a inbox result by email address
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxByEmailAddressResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<InboxByEmailAddressResult>> GetInboxByEmailAddressWithHttpInfoAsync(string emailAddress, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Search for an inbox with the given name
        /// </summary>
        /// <remarks>
        /// Get a inbox result by name
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxByNameResult</returns>
        System.Threading.Tasks.Task<InboxByNameResult> GetInboxByNameAsync(string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Search for an inbox with the given name
        /// </summary>
        /// <remarks>
        /// Get a inbox result by name
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxByNameResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<InboxByNameResult>> GetInboxByNameWithHttpInfoAsync(string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get total inbox count
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountDto</returns>
        System.Threading.Tasks.Task<CountDto> GetInboxCountAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get total inbox count
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<CountDto>> GetInboxCountWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get email count in inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountDto</returns>
        System.Threading.Tasks.Task<CountDto> GetInboxEmailCountAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get email count in inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<CountDto>> GetInboxEmailCountWithHttpInfoAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get inbox emails paginated
        /// </summary>
        /// <remarks>
        /// Get a paginated list of emails in an inbox. Does not hold connections open.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="page">Optional page index in inbox emails list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox emails list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by received after given date time (optional)</param>
        /// <param name="before">Optional filter by received before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageEmailPreview</returns>
        System.Threading.Tasks.Task<PageEmailPreview> GetInboxEmailsPaginatedAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get inbox emails paginated
        /// </summary>
        /// <remarks>
        /// Get a paginated list of emails in an inbox. Does not hold connections open.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="page">Optional page index in inbox emails list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox emails list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by received after given date time (optional)</param>
        /// <param name="before">Optional filter by received before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageEmailPreview)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageEmailPreview>> GetInboxEmailsPaginatedWithHttpInfoAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get all inbox IDs
        /// </summary>
        /// <remarks>
        /// Get list of inbox IDs
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxIdsResult</returns>
        [Obsolete]
        System.Threading.Tasks.Task<InboxIdsResult> GetInboxIdsAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get all inbox IDs
        /// </summary>
        /// <remarks>
        /// Get list of inbox IDs
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxIdsResult)</returns>
        [Obsolete]
        System.Threading.Tasks.Task<ApiResponse<InboxIdsResult>> GetInboxIdsWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Inbox Sent Emails
        /// </summary>
        /// <remarks>
        /// Returns an inbox&#39;s sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional sent email search (optional)</param>
        /// <param name="since">Optional filter by sent after given date time (optional)</param>
        /// <param name="before">Optional filter by sent before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageSentEmailProjection</returns>
        [Obsolete]
        System.Threading.Tasks.Task<PageSentEmailProjection> GetInboxSentEmailsAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Inbox Sent Emails
        /// </summary>
        /// <remarks>
        /// Returns an inbox&#39;s sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional sent email search (optional)</param>
        /// <param name="since">Optional filter by sent after given date time (optional)</param>
        /// <param name="before">Optional filter by sent before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageSentEmailProjection)</returns>
        [Obsolete]
        System.Threading.Tasks.Task<ApiResponse<PageSentEmailProjection>> GetInboxSentEmailsWithHttpInfoAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get inbox tags
        /// </summary>
        /// <remarks>
        /// Get all inbox tags
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;string&gt;</returns>
        [Obsolete]
        System.Threading.Tasks.Task<List<string>> GetInboxTagsAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get inbox tags
        /// </summary>
        /// <remarks>
        /// Get all inbox tags
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;string&gt;)</returns>
        [Obsolete]
        System.Threading.Tasks.Task<ApiResponse<List<string>>> GetInboxTagsWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List Inboxes and email addresses
        /// </summary>
        /// <remarks>
        /// List the inboxes you have created. Note use of the more advanced &#x60;getAllInboxes&#x60; is recommended and allows paginated access using a limit and sort parameter.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries. (optional, default to 100)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="excludeCatchAllInboxes">Optional exclude catch all inboxes (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;InboxDto&gt;</returns>
        [Obsolete]
        System.Threading.Tasks.Task<List<InboxDto>> GetInboxesAsync(int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), bool? excludeCatchAllInboxes = default(bool?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List Inboxes and email addresses
        /// </summary>
        /// <remarks>
        /// List the inboxes you have created. Note use of the more advanced &#x60;getAllInboxes&#x60; is recommended and allows paginated access using a limit and sort parameter.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries. (optional, default to 100)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="excludeCatchAllInboxes">Optional exclude catch all inboxes (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;InboxDto&gt;)</returns>
        [Obsolete]
        System.Threading.Tasks.Task<ApiResponse<List<InboxDto>>> GetInboxesWithHttpInfoAsync(int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), bool? excludeCatchAllInboxes = default(bool?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.
        /// </summary>
        /// <remarks>
        /// Get the newest email in an inbox or wait for one to arrive
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="timeoutMillis">Timeout milliseconds to wait for latest email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        System.Threading.Tasks.Task<Email> GetLatestEmailInInboxAsync(Guid inboxId, long timeoutMillis, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.
        /// </summary>
        /// <remarks>
        /// Get the newest email in an inbox or wait for one to arrive
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="timeoutMillis">Timeout milliseconds to wait for latest email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        System.Threading.Tasks.Task<ApiResponse<Email>> GetLatestEmailInInboxWithHttpInfoAsync(Guid inboxId, long timeoutMillis, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List Organization Inboxes Paginated
        /// </summary>
        /// <remarks>
        /// List organization inboxes in paginated form. These are inboxes created with &#x60;allowTeamAccess&#x60; flag enabled. Organization inboxes are &#x60;readOnly&#x60; for non-admin users. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageOrganizationInboxProjection</returns>
        [Obsolete]
        System.Threading.Tasks.Task<PageOrganizationInboxProjection> GetOrganizationInboxesAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List Organization Inboxes Paginated
        /// </summary>
        /// <remarks>
        /// List organization inboxes in paginated form. These are inboxes created with &#x60;allowTeamAccess&#x60; flag enabled. Organization inboxes are &#x60;readOnly&#x60; for non-admin users. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageOrganizationInboxProjection)</returns>
        [Obsolete]
        System.Threading.Tasks.Task<ApiResponse<PageOrganizationInboxProjection>> GetOrganizationInboxesWithHttpInfoAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a scheduled email job
        /// </summary>
        /// <remarks>
        /// Get a scheduled email job details.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ScheduledJobDto</returns>
        System.Threading.Tasks.Task<ScheduledJobDto> GetScheduledJobAsync(Guid jobId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a scheduled email job
        /// </summary>
        /// <remarks>
        /// Get a scheduled email job details.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ScheduledJobDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<ScheduledJobDto>> GetScheduledJobWithHttpInfoAsync(Guid jobId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get all scheduled email sending jobs for the inbox
        /// </summary>
        /// <remarks>
        /// Schedule sending of emails using scheduled jobs.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageScheduledJobs</returns>
        System.Threading.Tasks.Task<PageScheduledJobs> GetScheduledJobsByInboxIdAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get all scheduled email sending jobs for the inbox
        /// </summary>
        /// <remarks>
        /// Schedule sending of emails using scheduled jobs.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageScheduledJobs)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageScheduledJobs>> GetScheduledJobsByInboxIdWithHttpInfoAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get SMTP access usernames and passwords
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SmtpAccessDetails</returns>
        System.Threading.Tasks.Task<SmtpAccessDetails> GetSmtpAccessAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get SMTP access usernames and passwords
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SmtpAccessDetails)</returns>
        System.Threading.Tasks.Task<ApiResponse<SmtpAccessDetails>> GetSmtpAccessWithHttpInfoAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List inbox rulesets
        /// </summary>
        /// <remarks>
        /// List all rulesets attached to an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox ruleset list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox ruleset list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageInboxRulesetDto</returns>
        System.Threading.Tasks.Task<PageInboxRulesetDto> ListInboxRulesetsAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List inbox rulesets
        /// </summary>
        /// <remarks>
        /// List all rulesets attached to an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox ruleset list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox ruleset list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageInboxRulesetDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageInboxRulesetDto>> ListInboxRulesetsWithHttpInfoAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List inbox tracking pixels
        /// </summary>
        /// <remarks>
        /// List all tracking pixels sent from an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageTrackingPixelProjection</returns>
        System.Threading.Tasks.Task<PageTrackingPixelProjection> ListInboxTrackingPixelsAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List inbox tracking pixels
        /// </summary>
        /// <remarks>
        /// List all tracking pixels sent from an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageTrackingPixelProjection)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageTrackingPixelProjection>> ListInboxTrackingPixelsWithHttpInfoAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Search all inboxes and return matching inboxes
        /// </summary>
        /// <remarks>
        /// Search inboxes and return in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchInboxesOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageInboxProjection</returns>
        System.Threading.Tasks.Task<PageInboxProjection> SearchInboxesAsync(SearchInboxesOptions searchInboxesOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Search all inboxes and return matching inboxes
        /// </summary>
        /// <remarks>
        /// Search inboxes and return in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchInboxesOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageInboxProjection)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageInboxProjection>> SearchInboxesWithHttpInfoAsync(SearchInboxesOptions searchInboxesOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send Email
        /// </summary>
        /// <remarks>
        /// Send an email from an inbox&#39;s email address.  The request body should contain the &#x60;SendEmailOptions&#x60; that include recipients, attachments, body etc. See &#x60;SendEmailOptions&#x60; for all available properties. Note the &#x60;inboxId&#x60; refers to the inbox&#39;s id not the inbox&#39;s email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method &#x60;sendEmailAndConfirm&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SendEmailAsync(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Send Email
        /// </summary>
        /// <remarks>
        /// Send an email from an inbox&#39;s email address.  The request body should contain the &#x60;SendEmailOptions&#x60; that include recipients, attachments, body etc. See &#x60;SendEmailOptions&#x60; for all available properties. Note the &#x60;inboxId&#x60; refers to the inbox&#39;s id not the inbox&#39;s email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method &#x60;sendEmailAndConfirm&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SendEmailWithHttpInfoAsync(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send email and return sent confirmation
        /// </summary>
        /// <remarks>
        /// Sister method for standard &#x60;sendEmail&#x60; method with the benefit of returning a &#x60;SentEmail&#x60; entity confirming the successful sending of the email with a link to the sent object created for it.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SentEmailDto</returns>
        System.Threading.Tasks.Task<SentEmailDto> SendEmailAndConfirmAsync(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Send email and return sent confirmation
        /// </summary>
        /// <remarks>
        /// Sister method for standard &#x60;sendEmail&#x60; method with the benefit of returning a &#x60;SentEmail&#x60; entity confirming the successful sending of the email with a link to the sent object created for it.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SentEmailDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<SentEmailDto>> SendEmailAndConfirmWithHttpInfoAsync(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send email with queue
        /// </summary>
        /// <remarks>
        /// Send an email using a queue. Will place the email onto a queue that will then be processed and sent. Use this queue method to enable any failed email sending to be recovered. This will prevent lost emails when sending if your account encounters a block or payment issue.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SendEmailWithQueueAsync(Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Send email with queue
        /// </summary>
        /// <remarks>
        /// Send an email using a queue. Will place the email onto a queue that will then be processed and sent. Use this queue method to enable any failed email sending to be recovered. This will prevent lost emails when sending if your account encounters a block or payment issue.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SendEmailWithQueueWithHttpInfoAsync(Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send email using an SMTP mail envelope and message body and return sent confirmation
        /// </summary>
        /// <remarks>
        /// Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SentEmailDto</returns>
        System.Threading.Tasks.Task<SentEmailDto> SendSmtpEnvelopeAsync(Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Send email using an SMTP mail envelope and message body and return sent confirmation
        /// </summary>
        /// <remarks>
        /// Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SentEmailDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<SentEmailDto>> SendSmtpEnvelopeWithHttpInfoAsync(Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send a test email to inbox
        /// </summary>
        /// <remarks>
        /// Send an inbox a test email to test email receiving is working
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SendTestEmailAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Send a test email to inbox
        /// </summary>
        /// <remarks>
        /// Send an inbox a test email to test email receiving is working
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SendTestEmailWithHttpInfoAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send email with with delay or schedule
        /// </summary>
        /// <remarks>
        /// Send an email using a delay. Will place the email onto a scheduler that will then be processed and sent. Use delays to schedule email sending.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp">Sending timestamp (optional)</param>
        /// <param name="sendAtNowPlusSeconds">Send after n seconds (optional)</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ScheduledJobDto</returns>
        System.Threading.Tasks.Task<ScheduledJobDto> SendWithScheduleAsync(Guid inboxId, SendEmailOptions sendEmailOptions, DateTime? sendAtTimestamp = default(DateTime?), long? sendAtNowPlusSeconds = default(long?), bool? validateBeforeEnqueue = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Send email with with delay or schedule
        /// </summary>
        /// <remarks>
        /// Send an email using a delay. Will place the email onto a scheduler that will then be processed and sent. Use delays to schedule email sending.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp">Sending timestamp (optional)</param>
        /// <param name="sendAtNowPlusSeconds">Send after n seconds (optional)</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ScheduledJobDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<ScheduledJobDto>> SendWithScheduleWithHttpInfoAsync(Guid inboxId, SendEmailOptions sendEmailOptions, DateTime? sendAtTimestamp = default(DateTime?), long? sendAtNowPlusSeconds = default(long?), bool? validateBeforeEnqueue = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Set inbox favourited state
        /// </summary>
        /// <remarks>
        /// Set and return new favourite state for an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to set favourite state</param>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxDto</returns>
        System.Threading.Tasks.Task<InboxDto> SetInboxFavouritedAsync(Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Set inbox favourited state
        /// </summary>
        /// <remarks>
        /// Set and return new favourite state for an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to set favourite state</param>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<InboxDto>> SetInboxFavouritedWithHttpInfoAsync(Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update Inbox. Change name and description. Email address is not editable.
        /// </summary>
        /// <remarks>
        /// Update editable fields on an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxDto</returns>
        System.Threading.Tasks.Task<InboxDto> UpdateInboxAsync(Guid inboxId, UpdateInboxOptions updateInboxOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update Inbox. Change name and description. Email address is not editable.
        /// </summary>
        /// <remarks>
        /// Update editable fields on an inbox
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<InboxDto>> UpdateInboxWithHttpInfoAsync(Guid inboxId, UpdateInboxOptions updateInboxOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IInboxControllerApi : IInboxControllerApiSync, IInboxControllerApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class InboxControllerApi : IInboxControllerApi
    {
        private mailslurp.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="InboxControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public InboxControllerApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InboxControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public InboxControllerApi(string basePath)
        {
            this.Configuration = mailslurp.Client.Configuration.MergeConfigurations(
                mailslurp.Client.GlobalConfiguration.Instance,
                new mailslurp.Client.Configuration { BasePath = basePath }
            );
            this.Client = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InboxControllerApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public InboxControllerApi(mailslurp.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = mailslurp.Client.Configuration.MergeConfigurations(
                mailslurp.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InboxControllerApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public InboxControllerApi(mailslurp.Client.ISynchronousClient client, mailslurp.Client.IAsynchronousClient asyncClient, mailslurp.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public mailslurp.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public mailslurp.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public mailslurp.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public mailslurp.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Cancel a scheduled email job Get a scheduled email job and cancel it. Will fail if status of job is already cancelled, failed, or complete.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ScheduledJobDto</returns>
        public ScheduledJobDto CancelScheduledJob(Guid jobId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<ScheduledJobDto> localVarResponse = CancelScheduledJobWithHttpInfo(jobId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel a scheduled email job Get a scheduled email job and cancel it. Will fail if status of job is already cancelled, failed, or complete.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ScheduledJobDto</returns>
        public mailslurp.Client.ApiResponse<ScheduledJobDto> CancelScheduledJobWithHttpInfo(Guid jobId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("jobId", mailslurp.Client.ClientUtils.ParameterToString(jobId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.CancelScheduledJob";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<ScheduledJobDto>("/inboxes/scheduled-jobs/{jobId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelScheduledJob", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel a scheduled email job Get a scheduled email job and cancel it. Will fail if status of job is already cancelled, failed, or complete.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ScheduledJobDto</returns>
        public async System.Threading.Tasks.Task<ScheduledJobDto> CancelScheduledJobAsync(Guid jobId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<ScheduledJobDto> localVarResponse = await CancelScheduledJobWithHttpInfoAsync(jobId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel a scheduled email job Get a scheduled email job and cancel it. Will fail if status of job is already cancelled, failed, or complete.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ScheduledJobDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<ScheduledJobDto>> CancelScheduledJobWithHttpInfoAsync(Guid jobId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("jobId", mailslurp.Client.ClientUtils.ParameterToString(jobId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.CancelScheduledJob";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<ScheduledJobDto>("/inboxes/scheduled-jobs/{jobId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelScheduledJob", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either &#x60;SMTP&#x60; or &#x60;HTTP&#x60; inboxes. Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Avoid &#x60;SMTP&#x60; inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID. (optional)</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI. (optional)</param>
        /// <param name="name">Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails. (optional)</param>
        /// <param name="description">Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with (optional)</param>
        /// <param name="useDomainPool">Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types. (optional)</param>
        /// <param name="favourite">Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering (optional)</param>
        /// <param name="expiresAt">Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)</param>
        /// <param name="expiresIn">Number of milliseconds that inbox should exist for (optional)</param>
        /// <param name="allowTeamAccess">DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization. (optional)</param>
        /// <param name="inboxType">HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mx.mailslurp.com&#x60;. (optional)</param>
        /// <param name="virtualInbox">Virtual inbox prevents any outbound emails from being sent. It creates sent email records but will never send real emails to recipients. Great for testing and faking email sending. (optional)</param>
        /// <param name="useShortAddress">Use a shorter email address under 31 characters (optional)</param>
        /// <param name="domainId">ID of custom domain to use for email address. (optional)</param>
        /// <param name="domainName">FQDN domain name for the domain you have verified. Will be appended with a randomly assigned recipient name. Use the &#x60;emailAddress&#x60; option instead to specify the full custom inbox. (optional)</param>
        /// <param name="prefix">Prefix to add before the email address for easier labelling or identification. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxDto</returns>
        public InboxDto CreateInbox(string emailAddress = default(string), List<string> tags = default(List<string>), string name = default(string), string description = default(string), bool? useDomainPool = default(bool?), bool? favourite = default(bool?), DateTime? expiresAt = default(DateTime?), long? expiresIn = default(long?), bool? allowTeamAccess = default(bool?), string inboxType = default(string), bool? virtualInbox = default(bool?), bool? useShortAddress = default(bool?), Guid? domainId = default(Guid?), string domainName = default(string), string prefix = default(string), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<InboxDto> localVarResponse = CreateInboxWithHttpInfo(emailAddress, tags, name, description, useDomainPool, favourite, expiresAt, expiresIn, allowTeamAccess, inboxType, virtualInbox, useShortAddress, domainId, domainName, prefix);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either &#x60;SMTP&#x60; or &#x60;HTTP&#x60; inboxes. Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Avoid &#x60;SMTP&#x60; inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID. (optional)</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI. (optional)</param>
        /// <param name="name">Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails. (optional)</param>
        /// <param name="description">Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with (optional)</param>
        /// <param name="useDomainPool">Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types. (optional)</param>
        /// <param name="favourite">Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering (optional)</param>
        /// <param name="expiresAt">Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)</param>
        /// <param name="expiresIn">Number of milliseconds that inbox should exist for (optional)</param>
        /// <param name="allowTeamAccess">DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization. (optional)</param>
        /// <param name="inboxType">HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mx.mailslurp.com&#x60;. (optional)</param>
        /// <param name="virtualInbox">Virtual inbox prevents any outbound emails from being sent. It creates sent email records but will never send real emails to recipients. Great for testing and faking email sending. (optional)</param>
        /// <param name="useShortAddress">Use a shorter email address under 31 characters (optional)</param>
        /// <param name="domainId">ID of custom domain to use for email address. (optional)</param>
        /// <param name="domainName">FQDN domain name for the domain you have verified. Will be appended with a randomly assigned recipient name. Use the &#x60;emailAddress&#x60; option instead to specify the full custom inbox. (optional)</param>
        /// <param name="prefix">Prefix to add before the email address for easier labelling or identification. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxDto</returns>
        public mailslurp.Client.ApiResponse<InboxDto> CreateInboxWithHttpInfo(string emailAddress = default(string), List<string> tags = default(List<string>), string name = default(string), string description = default(string), bool? useDomainPool = default(bool?), bool? favourite = default(bool?), DateTime? expiresAt = default(DateTime?), long? expiresIn = default(long?), bool? allowTeamAccess = default(bool?), string inboxType = default(string), bool? virtualInbox = default(bool?), bool? useShortAddress = default(bool?), Guid? domainId = default(Guid?), string domainName = default(string), string prefix = default(string), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (emailAddress != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "emailAddress", emailAddress));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }
            if (name != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "name", name));
            }
            if (description != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "description", description));
            }
            if (useDomainPool != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "useDomainPool", useDomainPool));
            }
            if (favourite != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourite", favourite));
            }
            if (expiresAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "expiresAt", expiresAt));
            }
            if (expiresIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "expiresIn", expiresIn));
            }
            if (allowTeamAccess != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "allowTeamAccess", allowTeamAccess));
            }
            if (inboxType != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxType", inboxType));
            }
            if (virtualInbox != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "virtualInbox", virtualInbox));
            }
            if (useShortAddress != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "useShortAddress", useShortAddress));
            }
            if (domainId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "domainId", domainId));
            }
            if (domainName != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "domainName", domainName));
            }
            if (prefix != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "prefix", prefix));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.CreateInbox";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<InboxDto>("/inboxes", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateInbox", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either &#x60;SMTP&#x60; or &#x60;HTTP&#x60; inboxes. Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Avoid &#x60;SMTP&#x60; inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID. (optional)</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI. (optional)</param>
        /// <param name="name">Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails. (optional)</param>
        /// <param name="description">Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with (optional)</param>
        /// <param name="useDomainPool">Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types. (optional)</param>
        /// <param name="favourite">Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering (optional)</param>
        /// <param name="expiresAt">Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)</param>
        /// <param name="expiresIn">Number of milliseconds that inbox should exist for (optional)</param>
        /// <param name="allowTeamAccess">DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization. (optional)</param>
        /// <param name="inboxType">HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mx.mailslurp.com&#x60;. (optional)</param>
        /// <param name="virtualInbox">Virtual inbox prevents any outbound emails from being sent. It creates sent email records but will never send real emails to recipients. Great for testing and faking email sending. (optional)</param>
        /// <param name="useShortAddress">Use a shorter email address under 31 characters (optional)</param>
        /// <param name="domainId">ID of custom domain to use for email address. (optional)</param>
        /// <param name="domainName">FQDN domain name for the domain you have verified. Will be appended with a randomly assigned recipient name. Use the &#x60;emailAddress&#x60; option instead to specify the full custom inbox. (optional)</param>
        /// <param name="prefix">Prefix to add before the email address for easier labelling or identification. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxDto</returns>
        public async System.Threading.Tasks.Task<InboxDto> CreateInboxAsync(string emailAddress = default(string), List<string> tags = default(List<string>), string name = default(string), string description = default(string), bool? useDomainPool = default(bool?), bool? favourite = default(bool?), DateTime? expiresAt = default(DateTime?), long? expiresIn = default(long?), bool? allowTeamAccess = default(bool?), string inboxType = default(string), bool? virtualInbox = default(bool?), bool? useShortAddress = default(bool?), Guid? domainId = default(Guid?), string domainName = default(string), string prefix = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<InboxDto> localVarResponse = await CreateInboxWithHttpInfoAsync(emailAddress, tags, name, description, useDomainPool, favourite, expiresAt, expiresIn, allowTeamAccess, inboxType, virtualInbox, useShortAddress, domainId, domainName, prefix, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either &#x60;SMTP&#x60; or &#x60;HTTP&#x60; inboxes. Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Avoid &#x60;SMTP&#x60; inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID. (optional)</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI. (optional)</param>
        /// <param name="name">Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails. (optional)</param>
        /// <param name="description">Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with (optional)</param>
        /// <param name="useDomainPool">Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types. (optional)</param>
        /// <param name="favourite">Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering (optional)</param>
        /// <param name="expiresAt">Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)</param>
        /// <param name="expiresIn">Number of milliseconds that inbox should exist for (optional)</param>
        /// <param name="allowTeamAccess">DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization. (optional)</param>
        /// <param name="inboxType">HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mx.mailslurp.com&#x60;. (optional)</param>
        /// <param name="virtualInbox">Virtual inbox prevents any outbound emails from being sent. It creates sent email records but will never send real emails to recipients. Great for testing and faking email sending. (optional)</param>
        /// <param name="useShortAddress">Use a shorter email address under 31 characters (optional)</param>
        /// <param name="domainId">ID of custom domain to use for email address. (optional)</param>
        /// <param name="domainName">FQDN domain name for the domain you have verified. Will be appended with a randomly assigned recipient name. Use the &#x60;emailAddress&#x60; option instead to specify the full custom inbox. (optional)</param>
        /// <param name="prefix">Prefix to add before the email address for easier labelling or identification. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<InboxDto>> CreateInboxWithHttpInfoAsync(string emailAddress = default(string), List<string> tags = default(List<string>), string name = default(string), string description = default(string), bool? useDomainPool = default(bool?), bool? favourite = default(bool?), DateTime? expiresAt = default(DateTime?), long? expiresIn = default(long?), bool? allowTeamAccess = default(bool?), string inboxType = default(string), bool? virtualInbox = default(bool?), bool? useShortAddress = default(bool?), Guid? domainId = default(Guid?), string domainName = default(string), string prefix = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (emailAddress != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "emailAddress", emailAddress));
            }
            if (tags != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("multi", "tags", tags));
            }
            if (name != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "name", name));
            }
            if (description != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "description", description));
            }
            if (useDomainPool != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "useDomainPool", useDomainPool));
            }
            if (favourite != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourite", favourite));
            }
            if (expiresAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "expiresAt", expiresAt));
            }
            if (expiresIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "expiresIn", expiresIn));
            }
            if (allowTeamAccess != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "allowTeamAccess", allowTeamAccess));
            }
            if (inboxType != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxType", inboxType));
            }
            if (virtualInbox != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "virtualInbox", virtualInbox));
            }
            if (useShortAddress != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "useShortAddress", useShortAddress));
            }
            if (domainId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "domainId", domainId));
            }
            if (domainName != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "domainName", domainName));
            }
            if (prefix != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "prefix", prefix));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.CreateInbox";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<InboxDto>("/inboxes", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateInbox", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inbox ruleset Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">inboxId</param>
        /// <param name="createInboxRulesetOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxRulesetDto</returns>
        public InboxRulesetDto CreateInboxRuleset(Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<InboxRulesetDto> localVarResponse = CreateInboxRulesetWithHttpInfo(inboxId, createInboxRulesetOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inbox ruleset Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">inboxId</param>
        /// <param name="createInboxRulesetOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxRulesetDto</returns>
        public mailslurp.Client.ApiResponse<InboxRulesetDto> CreateInboxRulesetWithHttpInfo(Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions, int operationIndex = 0)
        {
            // verify the required parameter 'createInboxRulesetOptions' is set
            if (createInboxRulesetOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'createInboxRulesetOptions' when calling InboxControllerApi->CreateInboxRuleset");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.Data = createInboxRulesetOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.CreateInboxRuleset";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<InboxRulesetDto>("/inboxes/{inboxId}/rulesets", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateInboxRuleset", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inbox ruleset Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">inboxId</param>
        /// <param name="createInboxRulesetOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxRulesetDto</returns>
        public async System.Threading.Tasks.Task<InboxRulesetDto> CreateInboxRulesetAsync(Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<InboxRulesetDto> localVarResponse = await CreateInboxRulesetWithHttpInfoAsync(inboxId, createInboxRulesetOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inbox ruleset Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">inboxId</param>
        /// <param name="createInboxRulesetOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxRulesetDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<InboxRulesetDto>> CreateInboxRulesetWithHttpInfoAsync(Guid inboxId, CreateInboxRulesetOptions createInboxRulesetOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'createInboxRulesetOptions' is set
            if (createInboxRulesetOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'createInboxRulesetOptions' when calling InboxControllerApi->CreateInboxRuleset");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.Data = createInboxRulesetOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.CreateInboxRuleset";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<InboxRulesetDto>("/inboxes/{inboxId}/rulesets", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateInboxRuleset", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inbox with default options. Uses MailSlurp domain pool address and is private. 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxDto</returns>
        public InboxDto CreateInboxWithDefaults(int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<InboxDto> localVarResponse = CreateInboxWithDefaultsWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inbox with default options. Uses MailSlurp domain pool address and is private. 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxDto</returns>
        public mailslurp.Client.ApiResponse<InboxDto> CreateInboxWithDefaultsWithHttpInfo(int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "InboxControllerApi.CreateInboxWithDefaults";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<InboxDto>("/inboxes/withDefaults", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateInboxWithDefaults", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inbox with default options. Uses MailSlurp domain pool address and is private. 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxDto</returns>
        public async System.Threading.Tasks.Task<InboxDto> CreateInboxWithDefaultsAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<InboxDto> localVarResponse = await CreateInboxWithDefaultsWithHttpInfoAsync(operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inbox with default options. Uses MailSlurp domain pool address and is private. 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<InboxDto>> CreateInboxWithDefaultsWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "InboxControllerApi.CreateInboxWithDefaults";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<InboxDto>("/inboxes/withDefaults", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateInboxWithDefaults", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inbox with options. Extended options for inbox creation. Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createInboxDto"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxDto</returns>
        public InboxDto CreateInboxWithOptions(CreateInboxDto createInboxDto, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<InboxDto> localVarResponse = CreateInboxWithOptionsWithHttpInfo(createInboxDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inbox with options. Extended options for inbox creation. Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createInboxDto"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxDto</returns>
        public mailslurp.Client.ApiResponse<InboxDto> CreateInboxWithOptionsWithHttpInfo(CreateInboxDto createInboxDto, int operationIndex = 0)
        {
            // verify the required parameter 'createInboxDto' is set
            if (createInboxDto == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'createInboxDto' when calling InboxControllerApi->CreateInboxWithOptions");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = createInboxDto;

            localVarRequestOptions.Operation = "InboxControllerApi.CreateInboxWithOptions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<InboxDto>("/inboxes/withOptions", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateInboxWithOptions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an inbox with options. Extended options for inbox creation. Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createInboxDto"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxDto</returns>
        public async System.Threading.Tasks.Task<InboxDto> CreateInboxWithOptionsAsync(CreateInboxDto createInboxDto, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<InboxDto> localVarResponse = await CreateInboxWithOptionsWithHttpInfoAsync(createInboxDto, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create an inbox with options. Extended options for inbox creation. Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createInboxDto"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<InboxDto>> CreateInboxWithOptionsWithHttpInfoAsync(CreateInboxDto createInboxDto, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'createInboxDto' is set
            if (createInboxDto == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'createInboxDto' when calling InboxControllerApi->CreateInboxWithOptions");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = createInboxDto;

            localVarRequestOptions.Operation = "InboxControllerApi.CreateInboxWithOptions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<InboxDto>("/inboxes/withOptions", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateInboxWithOptions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete all emails in a given inboxes. Deletes all emails in an inbox. Be careful as emails cannot be recovered
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteAllInboxEmails(Guid inboxId, int operationIndex = 0)
        {
            DeleteAllInboxEmailsWithHttpInfo(inboxId);
        }

        /// <summary>
        /// Delete all emails in a given inboxes. Deletes all emails in an inbox. Be careful as emails cannot be recovered
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> DeleteAllInboxEmailsWithHttpInfo(Guid inboxId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.DeleteAllInboxEmails";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/inboxes/{inboxId}/deleteAllInboxEmails", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAllInboxEmails", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete all emails in a given inboxes. Deletes all emails in an inbox. Be careful as emails cannot be recovered
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteAllInboxEmailsAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteAllInboxEmailsWithHttpInfoAsync(inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete all emails in a given inboxes. Deletes all emails in an inbox. Be careful as emails cannot be recovered
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> DeleteAllInboxEmailsWithHttpInfoAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.DeleteAllInboxEmails";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/inboxes/{inboxId}/deleteAllInboxEmails", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAllInboxEmails", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete all inboxes Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteAllInboxes(int operationIndex = 0)
        {
            DeleteAllInboxesWithHttpInfo();
        }

        /// <summary>
        /// Delete all inboxes Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> DeleteAllInboxesWithHttpInfo(int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "InboxControllerApi.DeleteAllInboxes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/inboxes", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAllInboxes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete all inboxes Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteAllInboxesAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteAllInboxesWithHttpInfoAsync(operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete all inboxes Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> DeleteAllInboxesWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "InboxControllerApi.DeleteAllInboxes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/inboxes", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAllInboxes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete inboxes by description Permanently delete all inboxes by description
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="description"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteAllInboxesByDescription(string description, int operationIndex = 0)
        {
            DeleteAllInboxesByDescriptionWithHttpInfo(description);
        }

        /// <summary>
        /// Delete inboxes by description Permanently delete all inboxes by description
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="description"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> DeleteAllInboxesByDescriptionWithHttpInfo(string description, int operationIndex = 0)
        {
            // verify the required parameter 'description' is set
            if (description == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'description' when calling InboxControllerApi->DeleteAllInboxesByDescription");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "description", description));

            localVarRequestOptions.Operation = "InboxControllerApi.DeleteAllInboxesByDescription";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/inboxes/by-description", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAllInboxesByDescription", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete inboxes by description Permanently delete all inboxes by description
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="description"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteAllInboxesByDescriptionAsync(string description, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteAllInboxesByDescriptionWithHttpInfoAsync(description, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete inboxes by description Permanently delete all inboxes by description
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="description"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> DeleteAllInboxesByDescriptionWithHttpInfoAsync(string description, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'description' is set
            if (description == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'description' when calling InboxControllerApi->DeleteAllInboxesByDescription");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "description", description));

            localVarRequestOptions.Operation = "InboxControllerApi.DeleteAllInboxesByDescription";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/inboxes/by-description", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAllInboxesByDescription", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete inboxes by name Permanently delete all inboxes by name
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteAllInboxesByName(string name, int operationIndex = 0)
        {
            DeleteAllInboxesByNameWithHttpInfo(name);
        }

        /// <summary>
        /// Delete inboxes by name Permanently delete all inboxes by name
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> DeleteAllInboxesByNameWithHttpInfo(string name, int operationIndex = 0)
        {
            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'name' when calling InboxControllerApi->DeleteAllInboxesByName");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "name", name));

            localVarRequestOptions.Operation = "InboxControllerApi.DeleteAllInboxesByName";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/inboxes/by-name", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAllInboxesByName", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete inboxes by name Permanently delete all inboxes by name
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteAllInboxesByNameAsync(string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteAllInboxesByNameWithHttpInfoAsync(name, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete inboxes by name Permanently delete all inboxes by name
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> DeleteAllInboxesByNameWithHttpInfoAsync(string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'name' when calling InboxControllerApi->DeleteAllInboxesByName");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "name", name));

            localVarRequestOptions.Operation = "InboxControllerApi.DeleteAllInboxesByName";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/inboxes/by-name", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAllInboxesByName", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete inboxes by tag Permanently delete all inboxes by tag
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteAllInboxesByTag(string tag, int operationIndex = 0)
        {
            DeleteAllInboxesByTagWithHttpInfo(tag);
        }

        /// <summary>
        /// Delete inboxes by tag Permanently delete all inboxes by tag
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> DeleteAllInboxesByTagWithHttpInfo(string tag, int operationIndex = 0)
        {
            // verify the required parameter 'tag' is set
            if (tag == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'tag' when calling InboxControllerApi->DeleteAllInboxesByTag");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "tag", tag));

            localVarRequestOptions.Operation = "InboxControllerApi.DeleteAllInboxesByTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/inboxes/by-tag", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAllInboxesByTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete inboxes by tag Permanently delete all inboxes by tag
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteAllInboxesByTagAsync(string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteAllInboxesByTagWithHttpInfoAsync(tag, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete inboxes by tag Permanently delete all inboxes by tag
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> DeleteAllInboxesByTagWithHttpInfoAsync(string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'tag' is set
            if (tag == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'tag' when calling InboxControllerApi->DeleteAllInboxesByTag");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "tag", tag));

            localVarRequestOptions.Operation = "InboxControllerApi.DeleteAllInboxesByTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/inboxes/by-tag", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAllInboxesByTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete inbox Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteInbox(Guid inboxId, int operationIndex = 0)
        {
            DeleteInboxWithHttpInfo(inboxId);
        }

        /// <summary>
        /// Delete inbox Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> DeleteInboxWithHttpInfo(Guid inboxId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.DeleteInbox";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/inboxes/{inboxId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteInbox", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete inbox Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteInboxAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteInboxWithHttpInfoAsync(inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete inbox Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> DeleteInboxWithHttpInfoAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.DeleteInbox";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/inboxes/{inboxId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteInbox", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Does inbox exist Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">Email address</param>
        /// <param name="allowCatchAll"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxExistsDto</returns>
        public InboxExistsDto DoesInboxExist(string emailAddress, bool? allowCatchAll = default(bool?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<InboxExistsDto> localVarResponse = DoesInboxExistWithHttpInfo(emailAddress, allowCatchAll);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Does inbox exist Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">Email address</param>
        /// <param name="allowCatchAll"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxExistsDto</returns>
        public mailslurp.Client.ApiResponse<InboxExistsDto> DoesInboxExistWithHttpInfo(string emailAddress, bool? allowCatchAll = default(bool?), int operationIndex = 0)
        {
            // verify the required parameter 'emailAddress' is set
            if (emailAddress == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'emailAddress' when calling InboxControllerApi->DoesInboxExist");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "emailAddress", emailAddress));
            if (allowCatchAll != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "allowCatchAll", allowCatchAll));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.DoesInboxExist";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<InboxExistsDto>("/inboxes/exists", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DoesInboxExist", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Does inbox exist Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">Email address</param>
        /// <param name="allowCatchAll"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxExistsDto</returns>
        public async System.Threading.Tasks.Task<InboxExistsDto> DoesInboxExistAsync(string emailAddress, bool? allowCatchAll = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<InboxExistsDto> localVarResponse = await DoesInboxExistWithHttpInfoAsync(emailAddress, allowCatchAll, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Does inbox exist Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress">Email address</param>
        /// <param name="allowCatchAll"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxExistsDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<InboxExistsDto>> DoesInboxExistWithHttpInfoAsync(string emailAddress, bool? allowCatchAll = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'emailAddress' is set
            if (emailAddress == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'emailAddress' when calling InboxControllerApi->DoesInboxExist");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "emailAddress", emailAddress));
            if (allowCatchAll != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "allowCatchAll", allowCatchAll));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.DoesInboxExist";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<InboxExistsDto>("/inboxes/exists", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DoesInboxExist", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Remove expired inboxes Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Optional expired at before flag to flush expired inboxes that have expired before the given time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FlushExpiredInboxesResult</returns>
        public FlushExpiredInboxesResult FlushExpired(DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<FlushExpiredInboxesResult> localVarResponse = FlushExpiredWithHttpInfo(before);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Remove expired inboxes Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Optional expired at before flag to flush expired inboxes that have expired before the given time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FlushExpiredInboxesResult</returns>
        public mailslurp.Client.ApiResponse<FlushExpiredInboxesResult> FlushExpiredWithHttpInfo(DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.FlushExpired";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<FlushExpiredInboxesResult>("/inboxes/expired", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("FlushExpired", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Remove expired inboxes Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Optional expired at before flag to flush expired inboxes that have expired before the given time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FlushExpiredInboxesResult</returns>
        public async System.Threading.Tasks.Task<FlushExpiredInboxesResult> FlushExpiredAsync(DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<FlushExpiredInboxesResult> localVarResponse = await FlushExpiredWithHttpInfoAsync(before, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Remove expired inboxes Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Optional expired at before flag to flush expired inboxes that have expired before the given time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FlushExpiredInboxesResult)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<FlushExpiredInboxesResult>> FlushExpiredWithHttpInfoAsync(DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.FlushExpired";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<FlushExpiredInboxesResult>("/inboxes/expired", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("FlushExpired", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List All Inboxes Paginated List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageInboxProjection</returns>
        public PageInboxProjection GetAllInboxes(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageInboxProjection> localVarResponse = GetAllInboxesWithHttpInfo(page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List All Inboxes Paginated List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageInboxProjection</returns>
        public mailslurp.Client.ApiResponse<PageInboxProjection> GetAllInboxesWithHttpInfo(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (favourite != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourite", favourite));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }
            if (tag != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "tag", tag));
            }
            if (teamAccess != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "teamAccess", teamAccess));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (inboxType != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxType", inboxType));
            }
            if (inboxFunction != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxFunction", inboxFunction));
            }
            if (domainId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "domainId", domainId));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetAllInboxes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageInboxProjection>("/inboxes/paginated", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAllInboxes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List All Inboxes Paginated List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageInboxProjection</returns>
        public async System.Threading.Tasks.Task<PageInboxProjection> GetAllInboxesAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<PageInboxProjection> localVarResponse = await GetAllInboxesWithHttpInfoAsync(page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List All Inboxes Paginated List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageInboxProjection)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageInboxProjection>> GetAllInboxesWithHttpInfoAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (favourite != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourite", favourite));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }
            if (tag != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "tag", tag));
            }
            if (teamAccess != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "teamAccess", teamAccess));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (inboxType != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxType", inboxType));
            }
            if (inboxFunction != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxFunction", inboxFunction));
            }
            if (domainId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "domainId", domainId));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetAllInboxes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageInboxProjection>("/inboxes/paginated", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAllInboxes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List All Inboxes Offset Paginated List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageInboxProjection</returns>
        public PageInboxProjection GetAllInboxesOffsetPaginated(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageInboxProjection> localVarResponse = GetAllInboxesOffsetPaginatedWithHttpInfo(page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List All Inboxes Offset Paginated List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageInboxProjection</returns>
        public mailslurp.Client.ApiResponse<PageInboxProjection> GetAllInboxesOffsetPaginatedWithHttpInfo(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (favourite != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourite", favourite));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }
            if (tag != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "tag", tag));
            }
            if (teamAccess != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "teamAccess", teamAccess));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (inboxType != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxType", inboxType));
            }
            if (inboxFunction != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxFunction", inboxFunction));
            }
            if (domainId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "domainId", domainId));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetAllInboxesOffsetPaginated";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageInboxProjection>("/inboxes/offset-paginated", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAllInboxesOffsetPaginated", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List All Inboxes Offset Paginated List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageInboxProjection</returns>
        public async System.Threading.Tasks.Task<PageInboxProjection> GetAllInboxesOffsetPaginatedAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<PageInboxProjection> localVarResponse = await GetAllInboxesOffsetPaginatedWithHttpInfoAsync(page, size, sort, favourite, search, tag, teamAccess, since, before, inboxType, inboxFunction, domainId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List All Inboxes Offset Paginated List inboxes in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="favourite">Optionally filter results for favourites only (optional, default to false)</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address (optional)</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags (optional)</param>
        /// <param name="teamAccess">DEPRECATED. Optionally filter by team access. (optional) (deprecated)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="inboxType">Optional filter by inbox type (optional)</param>
        /// <param name="inboxFunction">Optional filter by inbox function (optional)</param>
        /// <param name="domainId">Optional domain ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageInboxProjection)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageInboxProjection>> GetAllInboxesOffsetPaginatedWithHttpInfoAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), bool? favourite = default(bool?), string search = default(string), string tag = default(string), bool? teamAccess = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string inboxType = default(string), string inboxFunction = default(string), Guid? domainId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (favourite != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourite", favourite));
            }
            if (search != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "search", search));
            }
            if (tag != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "tag", tag));
            }
            if (teamAccess != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "teamAccess", teamAccess));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (inboxType != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxType", inboxType));
            }
            if (inboxFunction != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxFunction", inboxFunction));
            }
            if (domainId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "domainId", domainId));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetAllInboxesOffsetPaginated";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageInboxProjection>("/inboxes/offset-paginated", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAllInboxesOffsetPaginated", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all scheduled email sending jobs for account Schedule sending of emails using scheduled jobs. These can be inbox or account level.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageScheduledJobs</returns>
        public PageScheduledJobs GetAllScheduledJobs(int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageScheduledJobs> localVarResponse = GetAllScheduledJobsWithHttpInfo(page, size, sort, since, before);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all scheduled email sending jobs for account Schedule sending of emails using scheduled jobs. These can be inbox or account level.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageScheduledJobs</returns>
        public mailslurp.Client.ApiResponse<PageScheduledJobs> GetAllScheduledJobsWithHttpInfo(int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetAllScheduledJobs";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageScheduledJobs>("/inboxes/scheduled-jobs", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAllScheduledJobs", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all scheduled email sending jobs for account Schedule sending of emails using scheduled jobs. These can be inbox or account level.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageScheduledJobs</returns>
        public async System.Threading.Tasks.Task<PageScheduledJobs> GetAllScheduledJobsAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<PageScheduledJobs> localVarResponse = await GetAllScheduledJobsWithHttpInfoAsync(page, size, sort, since, before, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all scheduled email sending jobs for account Schedule sending of emails using scheduled jobs. These can be inbox or account level.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageScheduledJobs)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageScheduledJobs>> GetAllScheduledJobsWithHttpInfoAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetAllScheduledJobs";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageScheduledJobs>("/inboxes/scheduled-jobs", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAllScheduledJobs", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get all email delivery statuses for an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in delivery status list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in delivery status list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageDeliveryStatus</returns>
        [Obsolete]
        public PageDeliveryStatus GetDeliveryStatusesByInboxId(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageDeliveryStatus> localVarResponse = GetDeliveryStatusesByInboxIdWithHttpInfo(inboxId, page, size, sort, since, before);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get all email delivery statuses for an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in delivery status list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in delivery status list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageDeliveryStatus</returns>
        [Obsolete]
        public mailslurp.Client.ApiResponse<PageDeliveryStatus> GetDeliveryStatusesByInboxIdWithHttpInfo(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetDeliveryStatusesByInboxId";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageDeliveryStatus>("/inboxes/{inboxId}/delivery-status", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDeliveryStatusesByInboxId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get all email delivery statuses for an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in delivery status list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in delivery status list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageDeliveryStatus</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<PageDeliveryStatus> GetDeliveryStatusesByInboxIdAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<PageDeliveryStatus> localVarResponse = await GetDeliveryStatusesByInboxIdWithHttpInfoAsync(inboxId, page, size, sort, since, before, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get all email delivery statuses for an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in delivery status list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in delivery status list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageDeliveryStatus)</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageDeliveryStatus>> GetDeliveryStatusesByInboxIdWithHttpInfoAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetDeliveryStatusesByInboxId";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageDeliveryStatus>("/inboxes/{inboxId}/delivery-status", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDeliveryStatusesByInboxId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead. List emails that an inbox has received. Only emails that are sent to the inbox&#39;s email address will appear in the inbox. It may take several seconds for any email you send to an inbox&#39;s email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the &#x60;minCount&#x60; parameter. The server will retry the inbox database until the &#x60;minCount&#x60; is satisfied or the &#x60;retryTimeout&#x60; is reached
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="size">Alias for limit. Assessed first before assessing any passed limit. (optional)</param>
        /// <param name="limit">Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller (optional)</param>
        /// <param name="sort">Sort the results by received date and direction ASC or DESC (optional)</param>
        /// <param name="retryTimeout">Maximum milliseconds to spend retrying inbox database until minCount emails are returned (optional)</param>
        /// <param name="delayTimeout"> (optional)</param>
        /// <param name="minCount">Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached. (optional)</param>
        /// <param name="unreadOnly"> (optional)</param>
        /// <param name="before">Exclude emails received after this ISO 8601 date time (optional)</param>
        /// <param name="since">Exclude emails received before this ISO 8601 date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        public List<EmailPreview> GetEmails(Guid inboxId, int? size = default(int?), int? limit = default(int?), string sort = default(string), long? retryTimeout = default(long?), long? delayTimeout = default(long?), long? minCount = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = GetEmailsWithHttpInfo(inboxId, size, limit, sort, retryTimeout, delayTimeout, minCount, unreadOnly, before, since);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead. List emails that an inbox has received. Only emails that are sent to the inbox&#39;s email address will appear in the inbox. It may take several seconds for any email you send to an inbox&#39;s email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the &#x60;minCount&#x60; parameter. The server will retry the inbox database until the &#x60;minCount&#x60; is satisfied or the &#x60;retryTimeout&#x60; is reached
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="size">Alias for limit. Assessed first before assessing any passed limit. (optional)</param>
        /// <param name="limit">Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller (optional)</param>
        /// <param name="sort">Sort the results by received date and direction ASC or DESC (optional)</param>
        /// <param name="retryTimeout">Maximum milliseconds to spend retrying inbox database until minCount emails are returned (optional)</param>
        /// <param name="delayTimeout"> (optional)</param>
        /// <param name="minCount">Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached. (optional)</param>
        /// <param name="unreadOnly"> (optional)</param>
        /// <param name="before">Exclude emails received after this ISO 8601 date time (optional)</param>
        /// <param name="since">Exclude emails received before this ISO 8601 date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        public mailslurp.Client.ApiResponse<List<EmailPreview>> GetEmailsWithHttpInfo(Guid inboxId, int? size = default(int?), int? limit = default(int?), string sort = default(string), long? retryTimeout = default(long?), long? delayTimeout = default(long?), long? minCount = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (retryTimeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "retryTimeout", retryTimeout));
            }
            if (delayTimeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delayTimeout", delayTimeout));
            }
            if (minCount != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "minCount", minCount));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetEmails";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<EmailPreview>>("/inboxes/{inboxId}/emails", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmails", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead. List emails that an inbox has received. Only emails that are sent to the inbox&#39;s email address will appear in the inbox. It may take several seconds for any email you send to an inbox&#39;s email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the &#x60;minCount&#x60; parameter. The server will retry the inbox database until the &#x60;minCount&#x60; is satisfied or the &#x60;retryTimeout&#x60; is reached
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="size">Alias for limit. Assessed first before assessing any passed limit. (optional)</param>
        /// <param name="limit">Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller (optional)</param>
        /// <param name="sort">Sort the results by received date and direction ASC or DESC (optional)</param>
        /// <param name="retryTimeout">Maximum milliseconds to spend retrying inbox database until minCount emails are returned (optional)</param>
        /// <param name="delayTimeout"> (optional)</param>
        /// <param name="minCount">Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached. (optional)</param>
        /// <param name="unreadOnly"> (optional)</param>
        /// <param name="before">Exclude emails received after this ISO 8601 date time (optional)</param>
        /// <param name="since">Exclude emails received before this ISO 8601 date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        public async System.Threading.Tasks.Task<List<EmailPreview>> GetEmailsAsync(Guid inboxId, int? size = default(int?), int? limit = default(int?), string sort = default(string), long? retryTimeout = default(long?), long? delayTimeout = default(long?), long? minCount = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = await GetEmailsWithHttpInfoAsync(inboxId, size, limit, sort, retryTimeout, delayTimeout, minCount, unreadOnly, before, since, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead. List emails that an inbox has received. Only emails that are sent to the inbox&#39;s email address will appear in the inbox. It may take several seconds for any email you send to an inbox&#39;s email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the &#x60;minCount&#x60; parameter. The server will retry the inbox database until the &#x60;minCount&#x60; is satisfied or the &#x60;retryTimeout&#x60; is reached
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="size">Alias for limit. Assessed first before assessing any passed limit. (optional)</param>
        /// <param name="limit">Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller (optional)</param>
        /// <param name="sort">Sort the results by received date and direction ASC or DESC (optional)</param>
        /// <param name="retryTimeout">Maximum milliseconds to spend retrying inbox database until minCount emails are returned (optional)</param>
        /// <param name="delayTimeout"> (optional)</param>
        /// <param name="minCount">Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached. (optional)</param>
        /// <param name="unreadOnly"> (optional)</param>
        /// <param name="before">Exclude emails received after this ISO 8601 date time (optional)</param>
        /// <param name="since">Exclude emails received before this ISO 8601 date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<List<EmailPreview>>> GetEmailsWithHttpInfoAsync(Guid inboxId, int? size = default(int?), int? limit = default(int?), string sort = default(string), long? retryTimeout = default(long?), long? delayTimeout = default(long?), long? minCount = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (retryTimeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "retryTimeout", retryTimeout));
            }
            if (delayTimeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delayTimeout", delayTimeout));
            }
            if (minCount != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "minCount", minCount));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetEmails";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<EmailPreview>>("/inboxes/{inboxId}/emails", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmails", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get IMAP access usernames and passwords
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ImapAccessDetails</returns>
        public ImapAccessDetails GetImapAccess(Guid? inboxId = default(Guid?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<ImapAccessDetails> localVarResponse = GetImapAccessWithHttpInfo(inboxId);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get IMAP access usernames and passwords
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ImapAccessDetails</returns>
        public mailslurp.Client.ApiResponse<ImapAccessDetails> GetImapAccessWithHttpInfo(Guid? inboxId = default(Guid?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetImapAccess";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ImapAccessDetails>("/inboxes/imap-access", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetImapAccess", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get IMAP access usernames and passwords
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ImapAccessDetails</returns>
        public async System.Threading.Tasks.Task<ImapAccessDetails> GetImapAccessAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<ImapAccessDetails> localVarResponse = await GetImapAccessWithHttpInfoAsync(inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get IMAP access usernames and passwords
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ImapAccessDetails)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<ImapAccessDetails>> GetImapAccessWithHttpInfoAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetImapAccess";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ImapAccessDetails>("/inboxes/imap-access", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetImapAccess", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get IMAP and SMTP access usernames and passwords
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ImapSmtpAccessDetails</returns>
        public ImapSmtpAccessDetails GetImapSmtpAccess(Guid? inboxId = default(Guid?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<ImapSmtpAccessDetails> localVarResponse = GetImapSmtpAccessWithHttpInfo(inboxId);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get IMAP and SMTP access usernames and passwords
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ImapSmtpAccessDetails</returns>
        public mailslurp.Client.ApiResponse<ImapSmtpAccessDetails> GetImapSmtpAccessWithHttpInfo(Guid? inboxId = default(Guid?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetImapSmtpAccess";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ImapSmtpAccessDetails>("/inboxes/imap-smtp-access", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetImapSmtpAccess", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get IMAP and SMTP access usernames and passwords
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ImapSmtpAccessDetails</returns>
        public async System.Threading.Tasks.Task<ImapSmtpAccessDetails> GetImapSmtpAccessAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<ImapSmtpAccessDetails> localVarResponse = await GetImapSmtpAccessWithHttpInfoAsync(inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get IMAP and SMTP access usernames and passwords
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ImapSmtpAccessDetails)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<ImapSmtpAccessDetails>> GetImapSmtpAccessWithHttpInfoAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetImapSmtpAccess";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ImapSmtpAccessDetails>("/inboxes/imap-smtp-access", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetImapSmtpAccess", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get IMAP and SMTP access details in .env format
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        public string GetImapSmtpAccessEnv(Guid? inboxId = default(Guid?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<string> localVarResponse = GetImapSmtpAccessEnvWithHttpInfo(inboxId);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get IMAP and SMTP access details in .env format
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        public mailslurp.Client.ApiResponse<string> GetImapSmtpAccessEnvWithHttpInfo(Guid? inboxId = default(Guid?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetImapSmtpAccessEnv";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<string>("/inboxes/imap-smtp-access/env", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetImapSmtpAccessEnv", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get IMAP and SMTP access details in .env format
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> GetImapSmtpAccessEnvAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<string> localVarResponse = await GetImapSmtpAccessEnvWithHttpInfoAsync(inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get IMAP and SMTP access details in .env format
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<string>> GetImapSmtpAccessEnvWithHttpInfoAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetImapSmtpAccessEnv";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<string>("/inboxes/imap-smtp-access/env", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetImapSmtpAccessEnv", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Inbox. Returns properties of an inbox. Returns an inbox&#39;s properties, including its email address and ID.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxDto</returns>
        public InboxDto GetInbox(Guid inboxId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<InboxDto> localVarResponse = GetInboxWithHttpInfo(inboxId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Inbox. Returns properties of an inbox. Returns an inbox&#39;s properties, including its email address and ID.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxDto</returns>
        public mailslurp.Client.ApiResponse<InboxDto> GetInboxWithHttpInfo(Guid inboxId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.GetInbox";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<InboxDto>("/inboxes/{inboxId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInbox", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Inbox. Returns properties of an inbox. Returns an inbox&#39;s properties, including its email address and ID.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxDto</returns>
        public async System.Threading.Tasks.Task<InboxDto> GetInboxAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<InboxDto> localVarResponse = await GetInboxWithHttpInfoAsync(inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Inbox. Returns properties of an inbox. Returns an inbox&#39;s properties, including its email address and ID.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<InboxDto>> GetInboxWithHttpInfoAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.GetInbox";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<InboxDto>("/inboxes/{inboxId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInbox", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search for an inbox with the provided email address Get a inbox result by email address
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxByEmailAddressResult</returns>
        public InboxByEmailAddressResult GetInboxByEmailAddress(string emailAddress, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<InboxByEmailAddressResult> localVarResponse = GetInboxByEmailAddressWithHttpInfo(emailAddress);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search for an inbox with the provided email address Get a inbox result by email address
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxByEmailAddressResult</returns>
        public mailslurp.Client.ApiResponse<InboxByEmailAddressResult> GetInboxByEmailAddressWithHttpInfo(string emailAddress, int operationIndex = 0)
        {
            // verify the required parameter 'emailAddress' is set
            if (emailAddress == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'emailAddress' when calling InboxControllerApi->GetInboxByEmailAddress");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "emailAddress", emailAddress));

            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxByEmailAddress";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<InboxByEmailAddressResult>("/inboxes/byEmailAddress", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxByEmailAddress", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search for an inbox with the provided email address Get a inbox result by email address
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxByEmailAddressResult</returns>
        public async System.Threading.Tasks.Task<InboxByEmailAddressResult> GetInboxByEmailAddressAsync(string emailAddress, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<InboxByEmailAddressResult> localVarResponse = await GetInboxByEmailAddressWithHttpInfoAsync(emailAddress, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search for an inbox with the provided email address Get a inbox result by email address
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxByEmailAddressResult)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<InboxByEmailAddressResult>> GetInboxByEmailAddressWithHttpInfoAsync(string emailAddress, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'emailAddress' is set
            if (emailAddress == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'emailAddress' when calling InboxControllerApi->GetInboxByEmailAddress");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "emailAddress", emailAddress));

            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxByEmailAddress";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<InboxByEmailAddressResult>("/inboxes/byEmailAddress", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxByEmailAddress", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search for an inbox with the given name Get a inbox result by name
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxByNameResult</returns>
        public InboxByNameResult GetInboxByName(string name, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<InboxByNameResult> localVarResponse = GetInboxByNameWithHttpInfo(name);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search for an inbox with the given name Get a inbox result by name
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxByNameResult</returns>
        public mailslurp.Client.ApiResponse<InboxByNameResult> GetInboxByNameWithHttpInfo(string name, int operationIndex = 0)
        {
            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'name' when calling InboxControllerApi->GetInboxByName");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "name", name));

            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxByName";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<InboxByNameResult>("/inboxes/byName", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxByName", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search for an inbox with the given name Get a inbox result by name
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxByNameResult</returns>
        public async System.Threading.Tasks.Task<InboxByNameResult> GetInboxByNameAsync(string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<InboxByNameResult> localVarResponse = await GetInboxByNameWithHttpInfoAsync(name, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search for an inbox with the given name Get a inbox result by name
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxByNameResult)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<InboxByNameResult>> GetInboxByNameWithHttpInfoAsync(string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'name' when calling InboxControllerApi->GetInboxByName");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "name", name));

            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxByName";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<InboxByNameResult>("/inboxes/byName", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxByName", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get total inbox count 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CountDto</returns>
        public CountDto GetInboxCount(int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<CountDto> localVarResponse = GetInboxCountWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get total inbox count 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CountDto</returns>
        public mailslurp.Client.ApiResponse<CountDto> GetInboxCountWithHttpInfo(int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxCount";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<CountDto>("/inboxes/count", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxCount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get total inbox count 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountDto</returns>
        public async System.Threading.Tasks.Task<CountDto> GetInboxCountAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<CountDto> localVarResponse = await GetInboxCountWithHttpInfoAsync(operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get total inbox count 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<CountDto>> GetInboxCountWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxCount";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<CountDto>("/inboxes/count", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxCount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email count in inbox 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CountDto</returns>
        public CountDto GetInboxEmailCount(Guid inboxId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<CountDto> localVarResponse = GetInboxEmailCountWithHttpInfo(inboxId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email count in inbox 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CountDto</returns>
        public mailslurp.Client.ApiResponse<CountDto> GetInboxEmailCountWithHttpInfo(Guid inboxId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxEmailCount";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<CountDto>("/inboxes/{inboxId}/emails/count", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxEmailCount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email count in inbox 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountDto</returns>
        public async System.Threading.Tasks.Task<CountDto> GetInboxEmailCountAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<CountDto> localVarResponse = await GetInboxEmailCountWithHttpInfoAsync(inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email count in inbox 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<CountDto>> GetInboxEmailCountWithHttpInfoAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxEmailCount";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<CountDto>("/inboxes/{inboxId}/emails/count", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxEmailCount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get inbox emails paginated Get a paginated list of emails in an inbox. Does not hold connections open.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="page">Optional page index in inbox emails list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox emails list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by received after given date time (optional)</param>
        /// <param name="before">Optional filter by received before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageEmailPreview</returns>
        public PageEmailPreview GetInboxEmailsPaginated(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageEmailPreview> localVarResponse = GetInboxEmailsPaginatedWithHttpInfo(inboxId, page, size, sort, since, before);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get inbox emails paginated Get a paginated list of emails in an inbox. Does not hold connections open.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="page">Optional page index in inbox emails list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox emails list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by received after given date time (optional)</param>
        /// <param name="before">Optional filter by received before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageEmailPreview</returns>
        public mailslurp.Client.ApiResponse<PageEmailPreview> GetInboxEmailsPaginatedWithHttpInfo(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxEmailsPaginated";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageEmailPreview>("/inboxes/{inboxId}/emails/paginated", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxEmailsPaginated", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get inbox emails paginated Get a paginated list of emails in an inbox. Does not hold connections open.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="page">Optional page index in inbox emails list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox emails list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by received after given date time (optional)</param>
        /// <param name="before">Optional filter by received before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageEmailPreview</returns>
        public async System.Threading.Tasks.Task<PageEmailPreview> GetInboxEmailsPaginatedAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<PageEmailPreview> localVarResponse = await GetInboxEmailsPaginatedWithHttpInfoAsync(inboxId, page, size, sort, since, before, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get inbox emails paginated Get a paginated list of emails in an inbox. Does not hold connections open.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of inbox that emails belongs to</param>
        /// <param name="page">Optional page index in inbox emails list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox emails list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by received after given date time (optional)</param>
        /// <param name="before">Optional filter by received before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageEmailPreview)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageEmailPreview>> GetInboxEmailsPaginatedWithHttpInfoAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxEmailsPaginated";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageEmailPreview>("/inboxes/{inboxId}/emails/paginated", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxEmailsPaginated", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all inbox IDs Get list of inbox IDs
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxIdsResult</returns>
        [Obsolete]
        public InboxIdsResult GetInboxIds(int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<InboxIdsResult> localVarResponse = GetInboxIdsWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all inbox IDs Get list of inbox IDs
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxIdsResult</returns>
        [Obsolete]
        public mailslurp.Client.ApiResponse<InboxIdsResult> GetInboxIdsWithHttpInfo(int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxIds";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<InboxIdsResult>("/inboxes/ids", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxIds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all inbox IDs Get list of inbox IDs
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxIdsResult</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<InboxIdsResult> GetInboxIdsAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<InboxIdsResult> localVarResponse = await GetInboxIdsWithHttpInfoAsync(operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all inbox IDs Get list of inbox IDs
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxIdsResult)</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<InboxIdsResult>> GetInboxIdsWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxIds";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<InboxIdsResult>("/inboxes/ids", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxIds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Inbox Sent Emails Returns an inbox&#39;s sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional sent email search (optional)</param>
        /// <param name="since">Optional filter by sent after given date time (optional)</param>
        /// <param name="before">Optional filter by sent before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageSentEmailProjection</returns>
        [Obsolete]
        public PageSentEmailProjection GetInboxSentEmails(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageSentEmailProjection> localVarResponse = GetInboxSentEmailsWithHttpInfo(inboxId, page, size, sort, searchFilter, since, before);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Inbox Sent Emails Returns an inbox&#39;s sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional sent email search (optional)</param>
        /// <param name="since">Optional filter by sent after given date time (optional)</param>
        /// <param name="before">Optional filter by sent before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageSentEmailProjection</returns>
        [Obsolete]
        public mailslurp.Client.ApiResponse<PageSentEmailProjection> GetInboxSentEmailsWithHttpInfo(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxSentEmails";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageSentEmailProjection>("/inboxes/{inboxId}/sent", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxSentEmails", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Inbox Sent Emails Returns an inbox&#39;s sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional sent email search (optional)</param>
        /// <param name="since">Optional filter by sent after given date time (optional)</param>
        /// <param name="before">Optional filter by sent before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageSentEmailProjection</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<PageSentEmailProjection> GetInboxSentEmailsAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<PageSentEmailProjection> localVarResponse = await GetInboxSentEmailsWithHttpInfoAsync(inboxId, page, size, sort, searchFilter, since, before, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Inbox Sent Emails Returns an inbox&#39;s sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional sent email search (optional)</param>
        /// <param name="since">Optional filter by sent after given date time (optional)</param>
        /// <param name="before">Optional filter by sent before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageSentEmailProjection)</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageSentEmailProjection>> GetInboxSentEmailsWithHttpInfoAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxSentEmails";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageSentEmailProjection>("/inboxes/{inboxId}/sent", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxSentEmails", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get inbox tags Get all inbox tags
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;string&gt;</returns>
        [Obsolete]
        public List<string> GetInboxTags(int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<List<string>> localVarResponse = GetInboxTagsWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get inbox tags Get all inbox tags
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;string&gt;</returns>
        [Obsolete]
        public mailslurp.Client.ApiResponse<List<string>> GetInboxTagsWithHttpInfo(int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxTags";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<string>>("/inboxes/tags", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxTags", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get inbox tags Get all inbox tags
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;string&gt;</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<List<string>> GetInboxTagsAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<List<string>> localVarResponse = await GetInboxTagsWithHttpInfoAsync(operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get inbox tags Get all inbox tags
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;string&gt;)</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<List<string>>> GetInboxTagsWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxTags";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<string>>("/inboxes/tags", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxTags", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Inboxes and email addresses List the inboxes you have created. Note use of the more advanced &#x60;getAllInboxes&#x60; is recommended and allows paginated access using a limit and sort parameter.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries. (optional, default to 100)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="excludeCatchAllInboxes">Optional exclude catch all inboxes (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;InboxDto&gt;</returns>
        [Obsolete]
        public List<InboxDto> GetInboxes(int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), bool? excludeCatchAllInboxes = default(bool?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<List<InboxDto>> localVarResponse = GetInboxesWithHttpInfo(size, sort, since, excludeCatchAllInboxes, before);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Inboxes and email addresses List the inboxes you have created. Note use of the more advanced &#x60;getAllInboxes&#x60; is recommended and allows paginated access using a limit and sort parameter.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries. (optional, default to 100)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="excludeCatchAllInboxes">Optional exclude catch all inboxes (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;InboxDto&gt;</returns>
        [Obsolete]
        public mailslurp.Client.ApiResponse<List<InboxDto>> GetInboxesWithHttpInfo(int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), bool? excludeCatchAllInboxes = default(bool?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (excludeCatchAllInboxes != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "excludeCatchAllInboxes", excludeCatchAllInboxes));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<InboxDto>>("/inboxes", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Inboxes and email addresses List the inboxes you have created. Note use of the more advanced &#x60;getAllInboxes&#x60; is recommended and allows paginated access using a limit and sort parameter.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries. (optional, default to 100)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="excludeCatchAllInboxes">Optional exclude catch all inboxes (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;InboxDto&gt;</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<List<InboxDto>> GetInboxesAsync(int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), bool? excludeCatchAllInboxes = default(bool?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<List<InboxDto>> localVarResponse = await GetInboxesWithHttpInfoAsync(size, sort, since, excludeCatchAllInboxes, before, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Inboxes and email addresses List the inboxes you have created. Note use of the more advanced &#x60;getAllInboxes&#x60; is recommended and allows paginated access using a limit and sort parameter.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries. (optional, default to 100)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="excludeCatchAllInboxes">Optional exclude catch all inboxes (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;InboxDto&gt;)</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<List<InboxDto>>> GetInboxesWithHttpInfoAsync(int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), bool? excludeCatchAllInboxes = default(bool?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (excludeCatchAllInboxes != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "excludeCatchAllInboxes", excludeCatchAllInboxes));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetInboxes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<InboxDto>>("/inboxes", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInboxes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet. Get the newest email in an inbox or wait for one to arrive
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="timeoutMillis">Timeout milliseconds to wait for latest email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        public Email GetLatestEmailInInbox(Guid inboxId, long timeoutMillis, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = GetLatestEmailInInboxWithHttpInfo(inboxId, timeoutMillis);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet. Get the newest email in an inbox or wait for one to arrive
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="timeoutMillis">Timeout milliseconds to wait for latest email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        public mailslurp.Client.ApiResponse<Email> GetLatestEmailInInboxWithHttpInfo(Guid inboxId, long timeoutMillis, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeoutMillis", timeoutMillis));

            localVarRequestOptions.Operation = "InboxControllerApi.GetLatestEmailInInbox";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Email>("/inboxes/getLatestEmail", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLatestEmailInInbox", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet. Get the newest email in an inbox or wait for one to arrive
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="timeoutMillis">Timeout milliseconds to wait for latest email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        public async System.Threading.Tasks.Task<Email> GetLatestEmailInInboxAsync(Guid inboxId, long timeoutMillis, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = await GetLatestEmailInInboxWithHttpInfoAsync(inboxId, timeoutMillis, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet. Get the newest email in an inbox or wait for one to arrive
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="timeoutMillis">Timeout milliseconds to wait for latest email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Email>> GetLatestEmailInInboxWithHttpInfoAsync(Guid inboxId, long timeoutMillis, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeoutMillis", timeoutMillis));

            localVarRequestOptions.Operation = "InboxControllerApi.GetLatestEmailInInbox";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Email>("/inboxes/getLatestEmail", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLatestEmailInInbox", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Organization Inboxes Paginated List organization inboxes in paginated form. These are inboxes created with &#x60;allowTeamAccess&#x60; flag enabled. Organization inboxes are &#x60;readOnly&#x60; for non-admin users. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageOrganizationInboxProjection</returns>
        [Obsolete]
        public PageOrganizationInboxProjection GetOrganizationInboxes(int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageOrganizationInboxProjection> localVarResponse = GetOrganizationInboxesWithHttpInfo(page, size, sort, searchFilter, since, before);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Organization Inboxes Paginated List organization inboxes in paginated form. These are inboxes created with &#x60;allowTeamAccess&#x60; flag enabled. Organization inboxes are &#x60;readOnly&#x60; for non-admin users. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageOrganizationInboxProjection</returns>
        [Obsolete]
        public mailslurp.Client.ApiResponse<PageOrganizationInboxProjection> GetOrganizationInboxesWithHttpInfo(int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetOrganizationInboxes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageOrganizationInboxProjection>("/inboxes/organization", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOrganizationInboxes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Organization Inboxes Paginated List organization inboxes in paginated form. These are inboxes created with &#x60;allowTeamAccess&#x60; flag enabled. Organization inboxes are &#x60;readOnly&#x60; for non-admin users. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageOrganizationInboxProjection</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<PageOrganizationInboxProjection> GetOrganizationInboxesAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<PageOrganizationInboxProjection> localVarResponse = await GetOrganizationInboxesWithHttpInfoAsync(page, size, sort, searchFilter, since, before, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Organization Inboxes Paginated List organization inboxes in paginated form. These are inboxes created with &#x60;allowTeamAccess&#x60; flag enabled. Organization inboxes are &#x60;readOnly&#x60; for non-admin users. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageOrganizationInboxProjection)</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageOrganizationInboxProjection>> GetOrganizationInboxesWithHttpInfoAsync(int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetOrganizationInboxes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageOrganizationInboxProjection>("/inboxes/organization", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOrganizationInboxes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a scheduled email job Get a scheduled email job details.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ScheduledJobDto</returns>
        public ScheduledJobDto GetScheduledJob(Guid jobId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<ScheduledJobDto> localVarResponse = GetScheduledJobWithHttpInfo(jobId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a scheduled email job Get a scheduled email job details.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ScheduledJobDto</returns>
        public mailslurp.Client.ApiResponse<ScheduledJobDto> GetScheduledJobWithHttpInfo(Guid jobId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("jobId", mailslurp.Client.ClientUtils.ParameterToString(jobId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.GetScheduledJob";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ScheduledJobDto>("/inboxes/scheduled-jobs/{jobId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetScheduledJob", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a scheduled email job Get a scheduled email job details.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ScheduledJobDto</returns>
        public async System.Threading.Tasks.Task<ScheduledJobDto> GetScheduledJobAsync(Guid jobId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<ScheduledJobDto> localVarResponse = await GetScheduledJobWithHttpInfoAsync(jobId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a scheduled email job Get a scheduled email job details.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ScheduledJobDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<ScheduledJobDto>> GetScheduledJobWithHttpInfoAsync(Guid jobId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("jobId", mailslurp.Client.ClientUtils.ParameterToString(jobId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.GetScheduledJob";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ScheduledJobDto>("/inboxes/scheduled-jobs/{jobId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetScheduledJob", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all scheduled email sending jobs for the inbox Schedule sending of emails using scheduled jobs.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageScheduledJobs</returns>
        public PageScheduledJobs GetScheduledJobsByInboxId(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageScheduledJobs> localVarResponse = GetScheduledJobsByInboxIdWithHttpInfo(inboxId, page, size, sort, since, before);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all scheduled email sending jobs for the inbox Schedule sending of emails using scheduled jobs.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageScheduledJobs</returns>
        public mailslurp.Client.ApiResponse<PageScheduledJobs> GetScheduledJobsByInboxIdWithHttpInfo(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetScheduledJobsByInboxId";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageScheduledJobs>("/inboxes/{inboxId}/scheduled-jobs", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetScheduledJobsByInboxId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all scheduled email sending jobs for the inbox Schedule sending of emails using scheduled jobs.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageScheduledJobs</returns>
        public async System.Threading.Tasks.Task<PageScheduledJobs> GetScheduledJobsByInboxIdAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<PageScheduledJobs> localVarResponse = await GetScheduledJobsByInboxIdWithHttpInfoAsync(inboxId, page, size, sort, since, before, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all scheduled email sending jobs for the inbox Schedule sending of emails using scheduled jobs.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in scheduled job list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in scheduled job list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageScheduledJobs)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageScheduledJobs>> GetScheduledJobsByInboxIdWithHttpInfoAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetScheduledJobsByInboxId";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageScheduledJobs>("/inboxes/{inboxId}/scheduled-jobs", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetScheduledJobsByInboxId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get SMTP access usernames and passwords
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SmtpAccessDetails</returns>
        public SmtpAccessDetails GetSmtpAccess(Guid? inboxId = default(Guid?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<SmtpAccessDetails> localVarResponse = GetSmtpAccessWithHttpInfo(inboxId);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get SMTP access usernames and passwords
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SmtpAccessDetails</returns>
        public mailslurp.Client.ApiResponse<SmtpAccessDetails> GetSmtpAccessWithHttpInfo(Guid? inboxId = default(Guid?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetSmtpAccess";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<SmtpAccessDetails>("/inboxes/smtp-access", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSmtpAccess", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get SMTP access usernames and passwords
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SmtpAccessDetails</returns>
        public async System.Threading.Tasks.Task<SmtpAccessDetails> GetSmtpAccessAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<SmtpAccessDetails> localVarResponse = await GetSmtpAccessWithHttpInfoAsync(inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get SMTP access usernames and passwords
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Inbox ID (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SmtpAccessDetails)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<SmtpAccessDetails>> GetSmtpAccessWithHttpInfoAsync(Guid? inboxId = default(Guid?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.GetSmtpAccess";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<SmtpAccessDetails>("/inboxes/smtp-access", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSmtpAccess", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List inbox rulesets List all rulesets attached to an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox ruleset list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox ruleset list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageInboxRulesetDto</returns>
        public PageInboxRulesetDto ListInboxRulesets(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageInboxRulesetDto> localVarResponse = ListInboxRulesetsWithHttpInfo(inboxId, page, size, sort, searchFilter, since, before);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List inbox rulesets List all rulesets attached to an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox ruleset list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox ruleset list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageInboxRulesetDto</returns>
        public mailslurp.Client.ApiResponse<PageInboxRulesetDto> ListInboxRulesetsWithHttpInfo(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.ListInboxRulesets";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageInboxRulesetDto>("/inboxes/{inboxId}/rulesets", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListInboxRulesets", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List inbox rulesets List all rulesets attached to an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox ruleset list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox ruleset list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageInboxRulesetDto</returns>
        public async System.Threading.Tasks.Task<PageInboxRulesetDto> ListInboxRulesetsAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<PageInboxRulesetDto> localVarResponse = await ListInboxRulesetsWithHttpInfoAsync(inboxId, page, size, sort, searchFilter, since, before, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List inbox rulesets List all rulesets attached to an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox ruleset list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox ruleset list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageInboxRulesetDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageInboxRulesetDto>> ListInboxRulesetsWithHttpInfoAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.ListInboxRulesets";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageInboxRulesetDto>("/inboxes/{inboxId}/rulesets", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListInboxRulesets", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List inbox tracking pixels List all tracking pixels sent from an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageTrackingPixelProjection</returns>
        public PageTrackingPixelProjection ListInboxTrackingPixels(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageTrackingPixelProjection> localVarResponse = ListInboxTrackingPixelsWithHttpInfo(inboxId, page, size, sort, searchFilter, since, before);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List inbox tracking pixels List all tracking pixels sent from an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageTrackingPixelProjection</returns>
        public mailslurp.Client.ApiResponse<PageTrackingPixelProjection> ListInboxTrackingPixelsWithHttpInfo(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.ListInboxTrackingPixels";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageTrackingPixelProjection>("/inboxes/{inboxId}/tracking-pixels", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListInboxTrackingPixels", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List inbox tracking pixels List all tracking pixels sent from an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageTrackingPixelProjection</returns>
        public async System.Threading.Tasks.Task<PageTrackingPixelProjection> ListInboxTrackingPixelsAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<PageTrackingPixelProjection> localVarResponse = await ListInboxTrackingPixelsWithHttpInfoAsync(inboxId, page, size, sort, searchFilter, since, before, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List inbox tracking pixels List all tracking pixels sent from an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="page">Optional page index in inbox tracking pixel list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox tracking pixel list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter (optional)</param>
        /// <param name="since">Optional filter by created after given date time (optional)</param>
        /// <param name="before">Optional filter by created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageTrackingPixelProjection)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageTrackingPixelProjection>> ListInboxTrackingPixelsWithHttpInfoAsync(Guid inboxId, int? page = default(int?), int? size = default(int?), string sort = default(string), string searchFilter = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "InboxControllerApi.ListInboxTrackingPixels";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageTrackingPixelProjection>("/inboxes/{inboxId}/tracking-pixels", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListInboxTrackingPixels", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search all inboxes and return matching inboxes Search inboxes and return in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchInboxesOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageInboxProjection</returns>
        public PageInboxProjection SearchInboxes(SearchInboxesOptions searchInboxesOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageInboxProjection> localVarResponse = SearchInboxesWithHttpInfo(searchInboxesOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search all inboxes and return matching inboxes Search inboxes and return in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchInboxesOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageInboxProjection</returns>
        public mailslurp.Client.ApiResponse<PageInboxProjection> SearchInboxesWithHttpInfo(SearchInboxesOptions searchInboxesOptions, int operationIndex = 0)
        {
            // verify the required parameter 'searchInboxesOptions' is set
            if (searchInboxesOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'searchInboxesOptions' when calling InboxControllerApi->SearchInboxes");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = searchInboxesOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SearchInboxes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PageInboxProjection>("/inboxes/search", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchInboxes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search all inboxes and return matching inboxes Search inboxes and return in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchInboxesOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageInboxProjection</returns>
        public async System.Threading.Tasks.Task<PageInboxProjection> SearchInboxesAsync(SearchInboxesOptions searchInboxesOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<PageInboxProjection> localVarResponse = await SearchInboxesWithHttpInfoAsync(searchInboxesOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search all inboxes and return matching inboxes Search inboxes and return in paginated form. The results are available on the &#x60;content&#x60; property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative &#x60;getInboxes&#x60; method returns a full list of inboxes but is limited to 100 results.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchInboxesOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageInboxProjection)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageInboxProjection>> SearchInboxesWithHttpInfoAsync(SearchInboxesOptions searchInboxesOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'searchInboxesOptions' is set
            if (searchInboxesOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'searchInboxesOptions' when calling InboxControllerApi->SearchInboxes");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = searchInboxesOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SearchInboxes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PageInboxProjection>("/inboxes/search", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchInboxes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send Email Send an email from an inbox&#39;s email address.  The request body should contain the &#x60;SendEmailOptions&#x60; that include recipients, attachments, body etc. See &#x60;SendEmailOptions&#x60; for all available properties. Note the &#x60;inboxId&#x60; refers to the inbox&#39;s id not the inbox&#39;s email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method &#x60;sendEmailAndConfirm&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void SendEmail(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0)
        {
            SendEmailWithHttpInfo(inboxId, sendEmailOptions);
        }

        /// <summary>
        /// Send Email Send an email from an inbox&#39;s email address.  The request body should contain the &#x60;SendEmailOptions&#x60; that include recipients, attachments, body etc. See &#x60;SendEmailOptions&#x60; for all available properties. Note the &#x60;inboxId&#x60; refers to the inbox&#39;s id not the inbox&#39;s email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method &#x60;sendEmailAndConfirm&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> SendEmailWithHttpInfo(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0)
        {
            // verify the required parameter 'sendEmailOptions' is set
            if (sendEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendEmailOptions' when calling InboxControllerApi->SendEmail");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.Data = sendEmailOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SendEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/inboxes/{inboxId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send Email Send an email from an inbox&#39;s email address.  The request body should contain the &#x60;SendEmailOptions&#x60; that include recipients, attachments, body etc. See &#x60;SendEmailOptions&#x60; for all available properties. Note the &#x60;inboxId&#x60; refers to the inbox&#39;s id not the inbox&#39;s email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method &#x60;sendEmailAndConfirm&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SendEmailAsync(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await SendEmailWithHttpInfoAsync(inboxId, sendEmailOptions, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Send Email Send an email from an inbox&#39;s email address.  The request body should contain the &#x60;SendEmailOptions&#x60; that include recipients, attachments, body etc. See &#x60;SendEmailOptions&#x60; for all available properties. Note the &#x60;inboxId&#x60; refers to the inbox&#39;s id not the inbox&#39;s email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method &#x60;sendEmailAndConfirm&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> SendEmailWithHttpInfoAsync(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'sendEmailOptions' is set
            if (sendEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendEmailOptions' when calling InboxControllerApi->SendEmail");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.Data = sendEmailOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SendEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/inboxes/{inboxId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send email and return sent confirmation Sister method for standard &#x60;sendEmail&#x60; method with the benefit of returning a &#x60;SentEmail&#x60; entity confirming the successful sending of the email with a link to the sent object created for it.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SentEmailDto</returns>
        public SentEmailDto SendEmailAndConfirm(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<SentEmailDto> localVarResponse = SendEmailAndConfirmWithHttpInfo(inboxId, sendEmailOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send email and return sent confirmation Sister method for standard &#x60;sendEmail&#x60; method with the benefit of returning a &#x60;SentEmail&#x60; entity confirming the successful sending of the email with a link to the sent object created for it.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SentEmailDto</returns>
        public mailslurp.Client.ApiResponse<SentEmailDto> SendEmailAndConfirmWithHttpInfo(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0)
        {
            // verify the required parameter 'sendEmailOptions' is set
            if (sendEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendEmailOptions' when calling InboxControllerApi->SendEmailAndConfirm");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.Data = sendEmailOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SendEmailAndConfirm";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SentEmailDto>("/inboxes/{inboxId}/confirm", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendEmailAndConfirm", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send email and return sent confirmation Sister method for standard &#x60;sendEmail&#x60; method with the benefit of returning a &#x60;SentEmail&#x60; entity confirming the successful sending of the email with a link to the sent object created for it.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SentEmailDto</returns>
        public async System.Threading.Tasks.Task<SentEmailDto> SendEmailAndConfirmAsync(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<SentEmailDto> localVarResponse = await SendEmailAndConfirmWithHttpInfoAsync(inboxId, sendEmailOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send email and return sent confirmation Sister method for standard &#x60;sendEmail&#x60; method with the benefit of returning a &#x60;SentEmail&#x60; entity confirming the successful sending of the email with a link to the sent object created for it.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SentEmailDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<SentEmailDto>> SendEmailAndConfirmWithHttpInfoAsync(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'sendEmailOptions' is set
            if (sendEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendEmailOptions' when calling InboxControllerApi->SendEmailAndConfirm");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.Data = sendEmailOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SendEmailAndConfirm";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SentEmailDto>("/inboxes/{inboxId}/confirm", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendEmailAndConfirm", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send email with queue Send an email using a queue. Will place the email onto a queue that will then be processed and sent. Use this queue method to enable any failed email sending to be recovered. This will prevent lost emails when sending if your account encounters a block or payment issue.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void SendEmailWithQueue(Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions, int operationIndex = 0)
        {
            SendEmailWithQueueWithHttpInfo(inboxId, validateBeforeEnqueue, sendEmailOptions);
        }

        /// <summary>
        /// Send email with queue Send an email using a queue. Will place the email onto a queue that will then be processed and sent. Use this queue method to enable any failed email sending to be recovered. This will prevent lost emails when sending if your account encounters a block or payment issue.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> SendEmailWithQueueWithHttpInfo(Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions, int operationIndex = 0)
        {
            // verify the required parameter 'sendEmailOptions' is set
            if (sendEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendEmailOptions' when calling InboxControllerApi->SendEmailWithQueue");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "validateBeforeEnqueue", validateBeforeEnqueue));
            localVarRequestOptions.Data = sendEmailOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SendEmailWithQueue";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/inboxes/{inboxId}/with-queue", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendEmailWithQueue", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send email with queue Send an email using a queue. Will place the email onto a queue that will then be processed and sent. Use this queue method to enable any failed email sending to be recovered. This will prevent lost emails when sending if your account encounters a block or payment issue.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SendEmailWithQueueAsync(Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await SendEmailWithQueueWithHttpInfoAsync(inboxId, validateBeforeEnqueue, sendEmailOptions, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Send email with queue Send an email using a queue. Will place the email onto a queue that will then be processed and sent. Use this queue method to enable any failed email sending to be recovered. This will prevent lost emails when sending if your account encounters a block or payment issue.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> SendEmailWithQueueWithHttpInfoAsync(Guid inboxId, bool validateBeforeEnqueue, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'sendEmailOptions' is set
            if (sendEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendEmailOptions' when calling InboxControllerApi->SendEmailWithQueue");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "validateBeforeEnqueue", validateBeforeEnqueue));
            localVarRequestOptions.Data = sendEmailOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SendEmailWithQueue";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/inboxes/{inboxId}/with-queue", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendEmailWithQueue", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send email using an SMTP mail envelope and message body and return sent confirmation Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SentEmailDto</returns>
        public SentEmailDto SendSmtpEnvelope(Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<SentEmailDto> localVarResponse = SendSmtpEnvelopeWithHttpInfo(inboxId, sendSMTPEnvelopeOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send email using an SMTP mail envelope and message body and return sent confirmation Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SentEmailDto</returns>
        public mailslurp.Client.ApiResponse<SentEmailDto> SendSmtpEnvelopeWithHttpInfo(Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions, int operationIndex = 0)
        {
            // verify the required parameter 'sendSMTPEnvelopeOptions' is set
            if (sendSMTPEnvelopeOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendSMTPEnvelopeOptions' when calling InboxControllerApi->SendSmtpEnvelope");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.Data = sendSMTPEnvelopeOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SendSmtpEnvelope";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SentEmailDto>("/inboxes/{inboxId}/smtp-envelope", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendSmtpEnvelope", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send email using an SMTP mail envelope and message body and return sent confirmation Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SentEmailDto</returns>
        public async System.Threading.Tasks.Task<SentEmailDto> SendSmtpEnvelopeAsync(Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<SentEmailDto> localVarResponse = await SendSmtpEnvelopeWithHttpInfoAsync(inboxId, sendSMTPEnvelopeOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send email using an SMTP mail envelope and message body and return sent confirmation Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendSMTPEnvelopeOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SentEmailDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<SentEmailDto>> SendSmtpEnvelopeWithHttpInfoAsync(Guid inboxId, SendSMTPEnvelopeOptions sendSMTPEnvelopeOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'sendSMTPEnvelopeOptions' is set
            if (sendSMTPEnvelopeOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendSMTPEnvelopeOptions' when calling InboxControllerApi->SendSmtpEnvelope");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.Data = sendSMTPEnvelopeOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SendSmtpEnvelope";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SentEmailDto>("/inboxes/{inboxId}/smtp-envelope", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendSmtpEnvelope", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send a test email to inbox Send an inbox a test email to test email receiving is working
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void SendTestEmail(Guid inboxId, int operationIndex = 0)
        {
            SendTestEmailWithHttpInfo(inboxId);
        }

        /// <summary>
        /// Send a test email to inbox Send an inbox a test email to test email receiving is working
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> SendTestEmailWithHttpInfo(Guid inboxId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.SendTestEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/inboxes/{inboxId}/send-test-email", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendTestEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send a test email to inbox Send an inbox a test email to test email receiving is working
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SendTestEmailAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await SendTestEmailWithHttpInfoAsync(inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Send a test email to inbox Send an inbox a test email to test email receiving is working
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> SendTestEmailWithHttpInfoAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter

            localVarRequestOptions.Operation = "InboxControllerApi.SendTestEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/inboxes/{inboxId}/send-test-email", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendTestEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send email with with delay or schedule Send an email using a delay. Will place the email onto a scheduler that will then be processed and sent. Use delays to schedule email sending.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp">Sending timestamp (optional)</param>
        /// <param name="sendAtNowPlusSeconds">Send after n seconds (optional)</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ScheduledJobDto</returns>
        public ScheduledJobDto SendWithSchedule(Guid inboxId, SendEmailOptions sendEmailOptions, DateTime? sendAtTimestamp = default(DateTime?), long? sendAtNowPlusSeconds = default(long?), bool? validateBeforeEnqueue = default(bool?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<ScheduledJobDto> localVarResponse = SendWithScheduleWithHttpInfo(inboxId, sendEmailOptions, sendAtTimestamp, sendAtNowPlusSeconds, validateBeforeEnqueue);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send email with with delay or schedule Send an email using a delay. Will place the email onto a scheduler that will then be processed and sent. Use delays to schedule email sending.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp">Sending timestamp (optional)</param>
        /// <param name="sendAtNowPlusSeconds">Send after n seconds (optional)</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ScheduledJobDto</returns>
        public mailslurp.Client.ApiResponse<ScheduledJobDto> SendWithScheduleWithHttpInfo(Guid inboxId, SendEmailOptions sendEmailOptions, DateTime? sendAtTimestamp = default(DateTime?), long? sendAtNowPlusSeconds = default(long?), bool? validateBeforeEnqueue = default(bool?), int operationIndex = 0)
        {
            // verify the required parameter 'sendEmailOptions' is set
            if (sendEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendEmailOptions' when calling InboxControllerApi->SendWithSchedule");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (sendAtTimestamp != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sendAtTimestamp", sendAtTimestamp));
            }
            if (sendAtNowPlusSeconds != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sendAtNowPlusSeconds", sendAtNowPlusSeconds));
            }
            if (validateBeforeEnqueue != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "validateBeforeEnqueue", validateBeforeEnqueue));
            }
            localVarRequestOptions.Data = sendEmailOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SendWithSchedule";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ScheduledJobDto>("/inboxes/{inboxId}/with-schedule", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendWithSchedule", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send email with with delay or schedule Send an email using a delay. Will place the email onto a scheduler that will then be processed and sent. Use delays to schedule email sending.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp">Sending timestamp (optional)</param>
        /// <param name="sendAtNowPlusSeconds">Send after n seconds (optional)</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ScheduledJobDto</returns>
        public async System.Threading.Tasks.Task<ScheduledJobDto> SendWithScheduleAsync(Guid inboxId, SendEmailOptions sendEmailOptions, DateTime? sendAtTimestamp = default(DateTime?), long? sendAtNowPlusSeconds = default(long?), bool? validateBeforeEnqueue = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<ScheduledJobDto> localVarResponse = await SendWithScheduleWithHttpInfoAsync(inboxId, sendEmailOptions, sendAtTimestamp, sendAtNowPlusSeconds, validateBeforeEnqueue, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send email with with delay or schedule Send an email using a delay. Will place the email onto a scheduler that will then be processed and sent. Use delays to schedule email sending.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="sendAtTimestamp">Sending timestamp (optional)</param>
        /// <param name="sendAtNowPlusSeconds">Send after n seconds (optional)</param>
        /// <param name="validateBeforeEnqueue">Validate before adding to queue (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ScheduledJobDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<ScheduledJobDto>> SendWithScheduleWithHttpInfoAsync(Guid inboxId, SendEmailOptions sendEmailOptions, DateTime? sendAtTimestamp = default(DateTime?), long? sendAtNowPlusSeconds = default(long?), bool? validateBeforeEnqueue = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'sendEmailOptions' is set
            if (sendEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendEmailOptions' when calling InboxControllerApi->SendWithSchedule");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            if (sendAtTimestamp != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sendAtTimestamp", sendAtTimestamp));
            }
            if (sendAtNowPlusSeconds != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sendAtNowPlusSeconds", sendAtNowPlusSeconds));
            }
            if (validateBeforeEnqueue != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "validateBeforeEnqueue", validateBeforeEnqueue));
            }
            localVarRequestOptions.Data = sendEmailOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SendWithSchedule";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ScheduledJobDto>("/inboxes/{inboxId}/with-schedule", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendWithSchedule", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set inbox favourited state Set and return new favourite state for an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to set favourite state</param>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxDto</returns>
        public InboxDto SetInboxFavourited(Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<InboxDto> localVarResponse = SetInboxFavouritedWithHttpInfo(inboxId, setInboxFavouritedOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set inbox favourited state Set and return new favourite state for an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to set favourite state</param>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxDto</returns>
        public mailslurp.Client.ApiResponse<InboxDto> SetInboxFavouritedWithHttpInfo(Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions, int operationIndex = 0)
        {
            // verify the required parameter 'setInboxFavouritedOptions' is set
            if (setInboxFavouritedOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'setInboxFavouritedOptions' when calling InboxControllerApi->SetInboxFavourited");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.Data = setInboxFavouritedOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SetInboxFavourited";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<InboxDto>("/inboxes/{inboxId}/favourite", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetInboxFavourited", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set inbox favourited state Set and return new favourite state for an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to set favourite state</param>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxDto</returns>
        public async System.Threading.Tasks.Task<InboxDto> SetInboxFavouritedAsync(Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<InboxDto> localVarResponse = await SetInboxFavouritedWithHttpInfoAsync(inboxId, setInboxFavouritedOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set inbox favourited state Set and return new favourite state for an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to set favourite state</param>
        /// <param name="setInboxFavouritedOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<InboxDto>> SetInboxFavouritedWithHttpInfoAsync(Guid inboxId, SetInboxFavouritedOptions setInboxFavouritedOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'setInboxFavouritedOptions' is set
            if (setInboxFavouritedOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'setInboxFavouritedOptions' when calling InboxControllerApi->SetInboxFavourited");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.Data = setInboxFavouritedOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.SetInboxFavourited";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<InboxDto>("/inboxes/{inboxId}/favourite", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetInboxFavourited", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update Inbox. Change name and description. Email address is not editable. Update editable fields on an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>InboxDto</returns>
        public InboxDto UpdateInbox(Guid inboxId, UpdateInboxOptions updateInboxOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<InboxDto> localVarResponse = UpdateInboxWithHttpInfo(inboxId, updateInboxOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update Inbox. Change name and description. Email address is not editable. Update editable fields on an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of InboxDto</returns>
        public mailslurp.Client.ApiResponse<InboxDto> UpdateInboxWithHttpInfo(Guid inboxId, UpdateInboxOptions updateInboxOptions, int operationIndex = 0)
        {
            // verify the required parameter 'updateInboxOptions' is set
            if (updateInboxOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'updateInboxOptions' when calling InboxControllerApi->UpdateInbox");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.Data = updateInboxOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.UpdateInbox";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<InboxDto>("/inboxes/{inboxId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateInbox", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update Inbox. Change name and description. Email address is not editable. Update editable fields on an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InboxDto</returns>
        public async System.Threading.Tasks.Task<InboxDto> UpdateInboxAsync(Guid inboxId, UpdateInboxOptions updateInboxOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<InboxDto> localVarResponse = await UpdateInboxWithHttpInfoAsync(inboxId, updateInboxOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update Inbox. Change name and description. Email address is not editable. Update editable fields on an inbox
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"></param>
        /// <param name="updateInboxOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InboxDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<InboxDto>> UpdateInboxWithHttpInfoAsync(Guid inboxId, UpdateInboxOptions updateInboxOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'updateInboxOptions' is set
            if (updateInboxOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'updateInboxOptions' when calling InboxControllerApi->UpdateInbox");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("inboxId", mailslurp.Client.ClientUtils.ParameterToString(inboxId)); // path parameter
            localVarRequestOptions.Data = updateInboxOptions;

            localVarRequestOptions.Operation = "InboxControllerApi.UpdateInbox";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<InboxDto>("/inboxes/{inboxId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateInbox", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
