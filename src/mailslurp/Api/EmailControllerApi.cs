// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IEmailControllerApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        EmailControllerApiEvents Events { get; }

        /// <summary>
        /// Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag.
        /// </summary>
        /// <remarks>
        /// Apply RFC3501 section-2.3.2 IMAP flag operations on an email
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApplyImapFlagOperationApiResponse"/>&gt;</returns>
        Task<IApplyImapFlagOperationApiResponse> ApplyImapFlagOperationAsync(Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag.
        /// </summary>
        /// <remarks>
        /// Apply RFC3501 section-2.3.2 IMAP flag operations on an email
        /// </remarks>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApplyImapFlagOperationApiResponse"/>&gt;</returns>
        Task<IApplyImapFlagOperationApiResponse> ApplyImapFlagOperationOrDefaultAsync(Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Check if email can be sent and options are valid.
        /// </summary>
        /// <remarks>
        /// Can user send email to given recipient or is the recipient blocked
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICanSendApiResponse"/>&gt;</returns>
        Task<ICanSendApiResponse> CanSendAsync(Guid inboxId, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Check if email can be sent and options are valid.
        /// </summary>
        /// <remarks>
        /// Can user send email to given recipient or is the recipient blocked
        /// </remarks>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICanSendApiResponse"/>&gt;</returns>
        Task<ICanSendApiResponse> CanSendOrDefaultAsync(Guid inboxId, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detect broken links, spelling, and images in email content
        /// </summary>
        /// <remarks>
        /// Find dead links, broken images, and spelling mistakes in email body. Will call included links via HTTP so do not invoke if your links are sensitive or stateful. Any resource that returns a 4xx or 5xx response or is not reachable via HEAD or GET HTTP operations will be considered unhealthy.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckEmailBodyApiResponse"/>&gt;</returns>
        Task<ICheckEmailBodyApiResponse> CheckEmailBodyAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detect broken links, spelling, and images in email content
        /// </summary>
        /// <remarks>
        /// Find dead links, broken images, and spelling mistakes in email body. Will call included links via HTTP so do not invoke if your links are sensitive or stateful. Any resource that returns a 4xx or 5xx response or is not reachable via HEAD or GET HTTP operations will be considered unhealthy.
        /// </remarks>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckEmailBodyApiResponse"/>&gt;</returns>
        Task<ICheckEmailBodyApiResponse> CheckEmailBodyOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Show which mail clients support the HTML and CSS features used in an email body.
        /// </summary>
        /// <remarks>
        /// Detect HTML and CSS features inside an email body and return a report of email client support across different platforms and versions.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckEmailBodyFeatureSupportApiResponse"/>&gt;</returns>
        Task<ICheckEmailBodyFeatureSupportApiResponse> CheckEmailBodyFeatureSupportAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Show which mail clients support the HTML and CSS features used in an email body.
        /// </summary>
        /// <remarks>
        /// Detect HTML and CSS features inside an email body and return a report of email client support across different platforms and versions.
        /// </remarks>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckEmailBodyFeatureSupportApiResponse"/>&gt;</returns>
        Task<ICheckEmailBodyFeatureSupportApiResponse> CheckEmailBodyFeatureSupportOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Show which email programs and devices support the features used in an email body.
        /// </summary>
        /// <remarks>
        /// Evaluate the features used in an email body and return a report of email client support across different platforms and versions.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckEmailClientSupportApiResponse"/>&gt;</returns>
        Task<ICheckEmailClientSupportApiResponse> CheckEmailClientSupportAsync(CheckEmailClientSupportOptions checkEmailClientSupportOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Show which email programs and devices support the features used in an email body.
        /// </summary>
        /// <remarks>
        /// Evaluate the features used in an email body and return a report of email client support across different platforms and versions.
        /// </remarks>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckEmailClientSupportApiResponse"/>&gt;</returns>
        Task<ICheckEmailClientSupportApiResponse> CheckEmailClientSupportOrDefaultAsync(CheckEmailClientSupportOptions checkEmailClientSupportOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete all emails in all inboxes.
        /// </summary>
        /// <remarks>
        /// Deletes all emails in your account. Be careful as emails cannot be recovered
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllEmailsApiResponse"/>&gt;</returns>
        Task<IDeleteAllEmailsApiResponse> DeleteAllEmailsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete all emails in all inboxes.
        /// </summary>
        /// <remarks>
        /// Deletes all emails in your account. Be careful as emails cannot be recovered
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllEmailsApiResponse"/>&gt;</returns>
        Task<IDeleteAllEmailsApiResponse> DeleteAllEmailsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an email
        /// </summary>
        /// <remarks>
        /// Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteEmailApiResponse"/>&gt;</returns>
        Task<IDeleteEmailApiResponse> DeleteEmailAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an email
        /// </summary>
        /// <remarks>
        /// Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
        /// </remarks>
        /// <param name="emailId">ID of email to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteEmailApiResponse"/>&gt;</returns>
        Task<IDeleteEmailApiResponse> DeleteEmailOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="apiKey">Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentApiResponse"/>&gt;</returns>
        Task<IDownloadAttachmentApiResponse> DownloadAttachmentAsync(Guid emailId, string attachmentId, Option<string> apiKey = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </remarks>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="apiKey">Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentApiResponse"/>&gt;</returns>
        Task<IDownloadAttachmentApiResponse> DownloadAttachmentOrDefaultAsync(Guid emailId, string attachmentId, Option<string> apiKey = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentBase64ApiResponse"/>&gt;</returns>
        Task<IDownloadAttachmentBase64ApiResponse> DownloadAttachmentBase64Async(Guid emailId, string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </remarks>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentBase64ApiResponse"/>&gt;</returns>
        Task<IDownloadAttachmentBase64ApiResponse> DownloadAttachmentBase64OrDefaultAsync(Guid emailId, string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email body as string. Returned as &#x60;plain/text&#x60; with content type header.
        /// </summary>
        /// <remarks>
        /// Returns the specified email body for a given email as a string
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadBodyApiResponse"/>&gt;</returns>
        Task<IDownloadBodyApiResponse> DownloadBodyAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email body as string. Returned as &#x60;plain/text&#x60; with content type header.
        /// </summary>
        /// <remarks>
        /// Returns the specified email body for a given email as a string
        /// </remarks>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadBodyApiResponse"/>&gt;</returns>
        Task<IDownloadBodyApiResponse> DownloadBodyOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header.
        /// </summary>
        /// <remarks>
        /// Returns the specified email body for a given email as a stream / array of bytes.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadBodyBytesApiResponse"/>&gt;</returns>
        Task<IDownloadBodyBytesApiResponse> DownloadBodyBytesAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header.
        /// </summary>
        /// <remarks>
        /// Returns the specified email body for a given email as a stream / array of bytes.
        /// </remarks>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadBodyBytesApiResponse"/>&gt;</returns>
        Task<IDownloadBodyBytesApiResponse> DownloadBodyBytesOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Forward email to recipients
        /// </summary>
        /// <remarks>
        /// Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the &#x60;from&#x60; option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="forwardEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IForwardEmailApiResponse"/>&gt;</returns>
        Task<IForwardEmailApiResponse> ForwardEmailAsync(Guid emailId, ForwardEmailOptions forwardEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Forward email to recipients
        /// </summary>
        /// <remarks>
        /// Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the &#x60;from&#x60; option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
        /// </remarks>
        /// <param name="emailId">ID of email</param>
        /// <param name="forwardEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IForwardEmailApiResponse"/>&gt;</returns>
        Task<IForwardEmailApiResponse> ForwardEmailOrDefaultAsync(Guid emailId, ForwardEmailOptions forwardEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods.
        /// </summary>
        /// <remarks>
        /// Returns the metadata such as name and content-type for a given attachment and email.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentMetaDataApiResponse"/>&gt;</returns>
        Task<IGetAttachmentMetaDataApiResponse> GetAttachmentMetaDataAsync(Guid emailId, string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods.
        /// </summary>
        /// <remarks>
        /// Returns the metadata such as name and content-type for a given attachment and email.
        /// </remarks>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentMetaDataApiResponse"/>&gt;</returns>
        Task<IGetAttachmentMetaDataApiResponse> GetAttachmentMetaDataOrDefaultAsync(Guid emailId, string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
        /// </summary>
        /// <remarks>
        /// Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailApiResponse"/>&gt;</returns>
        Task<IGetEmailApiResponse> GetEmailAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
        /// </summary>
        /// <remarks>
        /// Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
        /// </remarks>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailApiResponse"/>&gt;</returns>
        Task<IGetEmailApiResponse> GetEmailOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all email attachment metadata. Metadata includes name and size of attachments.
        /// </summary>
        /// <remarks>
        /// Returns an array of attachment metadata such as name and content-type for a given email if present.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailAttachmentsApiResponse"/>&gt;</returns>
        Task<IGetEmailAttachmentsApiResponse> GetEmailAttachmentsAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all email attachment metadata. Metadata includes name and size of attachments.
        /// </summary>
        /// <remarks>
        /// Returns an array of attachment metadata such as name and content-type for a given email if present.
        /// </remarks>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailAttachmentsApiResponse"/>&gt;</returns>
        Task<IGetEmailAttachmentsApiResponse> GetEmailAttachmentsOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content regex pattern match results. Runs regex against email body and returns match groups.
        /// </summary>
        /// <remarks>
        /// Return the matches for a given Java style regex pattern. Do not include the typical &#x60;/&#x60; at start or end of regex in some languages. Given an example &#x60;your code is: 12345&#x60; the pattern to extract match looks like &#x60;code is: (\\d{6})&#x60;. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: &#x60;[&#39;code is: 123456&#39;, &#39;123456&#39;]&#x60; See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentMatchOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailContentMatchApiResponse"/>&gt;</returns>
        Task<IGetEmailContentMatchApiResponse> GetEmailContentMatchAsync(Guid emailId, ContentMatchOptions contentMatchOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content regex pattern match results. Runs regex against email body and returns match groups.
        /// </summary>
        /// <remarks>
        /// Return the matches for a given Java style regex pattern. Do not include the typical &#x60;/&#x60; at start or end of regex in some languages. Given an example &#x60;your code is: 12345&#x60; the pattern to extract match looks like &#x60;code is: (\\d{6})&#x60;. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: &#x60;[&#39;code is: 123456&#39;, &#39;123456&#39;]&#x60; See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
        /// </remarks>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentMatchOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailContentMatchApiResponse"/>&gt;</returns>
        Task<IGetEmailContentMatchApiResponse> GetEmailContentMatchOrDefaultAsync(Guid emailId, ContentMatchOptions contentMatchOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content part by content type
        /// </summary>
        /// <remarks>
        /// Get email body content parts from a multipart email message for a given content type
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailContentPartApiResponse"/>&gt;</returns>
        Task<IGetEmailContentPartApiResponse> GetEmailContentPartAsync(Guid emailId, string contentType, Option<bool> strict = default, Option<int> index = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content part by content type
        /// </summary>
        /// <remarks>
        /// Get email body content parts from a multipart email message for a given content type
        /// </remarks>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailContentPartApiResponse"/>&gt;</returns>
        Task<IGetEmailContentPartApiResponse> GetEmailContentPartOrDefaultAsync(Guid emailId, string contentType, Option<bool> strict = default, Option<int> index = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content part by content type raw response
        /// </summary>
        /// <remarks>
        /// Get email body content parts from a multipart email message for a given content type and return as response
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple. Starts from 0 and applies to the result list after selecting for your content type. Content type parts are sorted by order found in original MIME message. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailContentPartContentApiResponse"/>&gt;</returns>
        Task<IGetEmailContentPartContentApiResponse> GetEmailContentPartContentAsync(Guid emailId, string contentType, Option<bool> strict = default, Option<int> index = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content part by content type raw response
        /// </summary>
        /// <remarks>
        /// Get email body content parts from a multipart email message for a given content type and return as response
        /// </remarks>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple. Starts from 0 and applies to the result list after selecting for your content type. Content type parts are sorted by order found in original MIME message. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailContentPartContentApiResponse"/>&gt;</returns>
        Task<IGetEmailContentPartContentApiResponse> GetEmailContentPartContentOrDefaultAsync(Guid emailId, string contentType, Option<bool> strict = default, Option<int> index = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email count
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailCountApiResponse"/>&gt;</returns>
        Task<IGetEmailCountApiResponse> GetEmailCountAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email count
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailCountApiResponse"/>&gt;</returns>
        Task<IGetEmailCountApiResponse> GetEmailCountOrDefaultAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content as HTML. For displaying emails in browser context.
        /// </summary>
        /// <remarks>
        /// Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: &#x60;?apiKey&#x3D;xxx&#x60;. Returns content-type &#x60;text/html;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON. For JSON response see the &#x60;getEmailHTMLJson&#x60; method.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailHTMLApiResponse"/>&gt;</returns>
        Task<IGetEmailHTMLApiResponse> GetEmailHTMLAsync(Guid emailId, Option<bool> replaceCidImages = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content as HTML. For displaying emails in browser context.
        /// </summary>
        /// <remarks>
        /// Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: &#x60;?apiKey&#x3D;xxx&#x60;. Returns content-type &#x60;text/html;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON. For JSON response see the &#x60;getEmailHTMLJson&#x60; method.
        /// </remarks>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailHTMLApiResponse"/>&gt;</returns>
        Task<IGetEmailHTMLApiResponse> GetEmailHTMLOrDefaultAsync(Guid emailId, Option<bool> replaceCidImages = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content
        /// </summary>
        /// <remarks>
        /// Retrieve email content as HTML response. Decodes quoted-printable entities and converts charset to UTF-8. Returns content-type &#x60;application/json;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailHTMLJsonApiResponse"/>&gt;</returns>
        Task<IGetEmailHTMLJsonApiResponse> GetEmailHTMLJsonAsync(Guid emailId, Option<bool> replaceCidImages = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content
        /// </summary>
        /// <remarks>
        /// Retrieve email content as HTML response. Decodes quoted-printable entities and converts charset to UTF-8. Returns content-type &#x60;application/json;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON.
        /// </remarks>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailHTMLJsonApiResponse"/>&gt;</returns>
        Task<IGetEmailHTMLJsonApiResponse> GetEmailHTMLJsonOrDefaultAsync(Guid emailId, Option<bool> replaceCidImages = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters
        /// </summary>
        /// <remarks>
        /// Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to perform HTML query on</param>
        /// <param name="htmlSelector">HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailHTMLQueryApiResponse"/>&gt;</returns>
        Task<IGetEmailHTMLQueryApiResponse> GetEmailHTMLQueryAsync(Guid emailId, string htmlSelector, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters
        /// </summary>
        /// <remarks>
        /// Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
        /// </remarks>
        /// <param name="emailId">ID of email to perform HTML query on</param>
        /// <param name="htmlSelector">HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailHTMLQueryApiResponse"/>&gt;</returns>
        Task<IGetEmailHTMLQueryApiResponse> GetEmailHTMLQueryOrDefaultAsync(Guid emailId, string htmlSelector, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Parse and return list of links found in an email (only works for HTML content)
        /// </summary>
        /// <remarks>
        /// HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="selector">Optional HTML query selector for links (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailLinksApiResponse"/>&gt;</returns>
        Task<IGetEmailLinksApiResponse> GetEmailLinksAsync(Guid emailId, Option<string> selector = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Parse and return list of links found in an email (only works for HTML content)
        /// </summary>
        /// <remarks>
        /// HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes
        /// </remarks>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="selector">Optional HTML query selector for links (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailLinksApiResponse"/>&gt;</returns>
        Task<IGetEmailLinksApiResponse> GetEmailLinksOrDefaultAsync(Guid emailId, Option<string> selector = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email URLs for viewing in browser or downloading
        /// </summary>
        /// <remarks>
        /// Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailPreviewURLsApiResponse"/>&gt;</returns>
        Task<IGetEmailPreviewURLsApiResponse> GetEmailPreviewURLsAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email URLs for viewing in browser or downloading
        /// </summary>
        /// <remarks>
        /// Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.
        /// </remarks>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailPreviewURLsApiResponse"/>&gt;</returns>
        Task<IGetEmailPreviewURLsApiResponse> GetEmailPreviewURLsOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Take a screenshot of an email in a browser and return base64 encoded string
        /// </summary>
        /// <remarks>
        /// Capture image of email screenshot and return as base64 encoded string. Useful for embedding in HTML. Be careful as this may contain sensitive information.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailScreenshotAsBase64ApiResponse"/>&gt;</returns>
        Task<IGetEmailScreenshotAsBase64ApiResponse> GetEmailScreenshotAsBase64Async(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Take a screenshot of an email in a browser and return base64 encoded string
        /// </summary>
        /// <remarks>
        /// Capture image of email screenshot and return as base64 encoded string. Useful for embedding in HTML. Be careful as this may contain sensitive information.
        /// </remarks>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailScreenshotAsBase64ApiResponse"/>&gt;</returns>
        Task<IGetEmailScreenshotAsBase64ApiResponse> GetEmailScreenshotAsBase64OrDefaultAsync(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Take a screenshot of an email in a browser
        /// </summary>
        /// <remarks>
        /// Returns binary octet-stream of screenshot of the given email
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailScreenshotAsBinaryApiResponse"/>&gt;</returns>
        Task<IGetEmailScreenshotAsBinaryApiResponse> GetEmailScreenshotAsBinaryAsync(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Take a screenshot of an email in a browser
        /// </summary>
        /// <remarks>
        /// Returns binary octet-stream of screenshot of the given email
        /// </remarks>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailScreenshotAsBinaryApiResponse"/>&gt;</returns>
        Task<IGetEmailScreenshotAsBinaryApiResponse> GetEmailScreenshotAsBinaryOrDefaultAsync(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email data including headers but not body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
        /// </summary>
        /// <remarks>
        /// Returns a email summary object with headers. To retrieve the body see getEmail and to get raw unparsed email use the getRawEmail endpoints
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="decode"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailSummaryApiResponse"/>&gt;</returns>
        Task<IGetEmailSummaryApiResponse> GetEmailSummaryAsync(Guid emailId, Option<bool> decode = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email data including headers but not body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
        /// </summary>
        /// <remarks>
        /// Returns a email summary object with headers. To retrieve the body see getEmail and to get raw unparsed email use the getRawEmail endpoints
        /// </remarks>
        /// <param name="emailId"></param>
        /// <param name="decode"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailSummaryApiResponse"/>&gt;</returns>
        Task<IGetEmailSummaryApiResponse> GetEmailSummaryOrDefaultAsync(Guid emailId, Option<bool> decode = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters
        /// </summary>
        /// <remarks>
        /// Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="decodeHtmlEntities">Decode HTML entities (optional)</param>
        /// <param name="lineSeparator">Line separator character (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailTextLinesApiResponse"/>&gt;</returns>
        Task<IGetEmailTextLinesApiResponse> GetEmailTextLinesAsync(Guid emailId, Option<bool> decodeHtmlEntities = default, Option<string> lineSeparator = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters
        /// </summary>
        /// <remarks>
        /// Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
        /// </remarks>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="decodeHtmlEntities">Decode HTML entities (optional)</param>
        /// <param name="lineSeparator">Line separator character (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailTextLinesApiResponse"/>&gt;</returns>
        Task<IGetEmailTextLinesApiResponse> GetEmailTextLinesOrDefaultAsync(Guid emailId, Option<bool> decodeHtmlEntities = default, Option<string> lineSeparator = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Return email thread information. Use items endpoints to get messages for thread.
        /// </summary>
        /// <remarks>
        /// Return email message thread summary from Message-ID, In-Reply-To, and References header. Get messages using items endpoint
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailThreadApiResponse"/>&gt;</returns>
        Task<IGetEmailThreadApiResponse> GetEmailThreadAsync(Guid threadId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Return email thread information. Use items endpoints to get messages for thread.
        /// </summary>
        /// <remarks>
        /// Return email message thread summary from Message-ID, In-Reply-To, and References header. Get messages using items endpoint
        /// </remarks>
        /// <param name="threadId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailThreadApiResponse"/>&gt;</returns>
        Task<IGetEmailThreadApiResponse> GetEmailThreadOrDefaultAsync(Guid threadId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Return email thread items.
        /// </summary>
        /// <remarks>
        /// Return email thread messages based on Message-ID, In-Reply-To, and References header
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailThreadItemsApiResponse"/>&gt;</returns>
        Task<IGetEmailThreadItemsApiResponse> GetEmailThreadItemsAsync(Guid threadId, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Return email thread items.
        /// </summary>
        /// <remarks>
        /// Return email thread messages based on Message-ID, In-Reply-To, and References header
        /// </remarks>
        /// <param name="threadId"></param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailThreadItemsApiResponse"/>&gt;</returns>
        Task<IGetEmailThreadItemsApiResponse> GetEmailThreadItemsOrDefaultAsync(Guid threadId, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Return email threads in paginated form
        /// </summary>
        /// <remarks>
        /// Return email message chains built from Message-ID, In-Reply-To, and References header.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="htmlSelector">Optional inbox filter (optional)</param>
        /// <param name="page">Optional page index in email thread pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email thread pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter search filter for email threads. (optional)</param>
        /// <param name="since">Optional filter email threads created since time (optional)</param>
        /// <param name="before">Optional filter emails threads created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailThreadsApiResponse"/>&gt;</returns>
        Task<IGetEmailThreadsApiResponse> GetEmailThreadsAsync(Option<Guid> htmlSelector = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Return email threads in paginated form
        /// </summary>
        /// <remarks>
        /// Return email message chains built from Message-ID, In-Reply-To, and References header.
        /// </remarks>
        /// <param name="htmlSelector">Optional inbox filter (optional)</param>
        /// <param name="page">Optional page index in email thread pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email thread pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter search filter for email threads. (optional)</param>
        /// <param name="since">Optional filter email threads created since time (optional)</param>
        /// <param name="before">Optional filter emails threads created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailThreadsApiResponse"/>&gt;</returns>
        Task<IGetEmailThreadsApiResponse> GetEmailThreadsOrDefaultAsync(Option<Guid> htmlSelector = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all.
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailsOffsetPaginatedApiResponse"/>&gt;</returns>
        Task<IGetEmailsOffsetPaginatedApiResponse> GetEmailsOffsetPaginatedAsync(Option<List<Guid>> inboxId = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> unreadOnly = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> favourited = default, Option<bool> syncConnectors = default, Option<Guid> plusAddressId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all.
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailsOffsetPaginatedApiResponse"/>&gt;</returns>
        Task<IGetEmailsOffsetPaginatedApiResponse> GetEmailsOffsetPaginatedOrDefaultAsync(Option<List<Guid>> inboxId = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> unreadOnly = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> favourited = default, Option<bool> syncConnectors = default, Option<Guid> plusAddressId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all.
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailsPaginatedApiResponse"/>&gt;</returns>
        Task<IGetEmailsPaginatedApiResponse> GetEmailsPaginatedAsync(Option<List<Guid>> inboxId = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> unreadOnly = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> syncConnectors = default, Option<Guid> plusAddressId = default, Option<bool> favourited = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all.
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailsPaginatedApiResponse"/>&gt;</returns>
        Task<IGetEmailsPaginatedApiResponse> GetEmailsPaginatedOrDefaultAsync(Option<List<Guid>> inboxId = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> unreadOnly = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> syncConnectors = default, Option<Guid> plusAddressId = default, Option<bool> favourited = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get gravatar url for email address
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="size"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGravatarUrlForEmailAddressApiResponse"/>&gt;</returns>
        Task<IGetGravatarUrlForEmailAddressApiResponse> GetGravatarUrlForEmailAddressAsync(string emailAddress, Option<string> size = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get gravatar url for email address
        /// </remarks>
        /// <param name="emailAddress"></param>
        /// <param name="size"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGravatarUrlForEmailAddressApiResponse"/>&gt;</returns>
        Task<IGetGravatarUrlForEmailAddressApiResponse> GetGravatarUrlForEmailAddressOrDefaultAsync(string emailAddress, Option<string> size = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get latest email in all inboxes. Most recently received.
        /// </summary>
        /// <remarks>
        /// Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxIds">Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestEmailApiResponse"/>&gt;</returns>
        Task<IGetLatestEmailApiResponse> GetLatestEmailAsync(Option<List<Guid>> inboxIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get latest email in all inboxes. Most recently received.
        /// </summary>
        /// <remarks>
        /// Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </remarks>
        /// <param name="inboxIds">Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestEmailApiResponse"/>&gt;</returns>
        Task<IGetLatestEmailApiResponse> GetLatestEmailOrDefaultAsync(Option<List<Guid>> inboxIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.
        /// </summary>
        /// <remarks>
        /// Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestEmailInInbox1ApiResponse"/>&gt;</returns>
        Task<IGetLatestEmailInInbox1ApiResponse> GetLatestEmailInInbox1Async(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.
        /// </summary>
        /// <remarks>
        /// Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </remarks>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestEmailInInbox1ApiResponse"/>&gt;</returns>
        Task<IGetLatestEmailInInbox1ApiResponse> GetLatestEmailInInbox1OrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all organization emails. List team or shared test email accounts
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter search filter for emails. (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favorited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOrganizationEmailsPaginatedApiResponse"/>&gt;</returns>
        Task<IGetOrganizationEmailsPaginatedApiResponse> GetOrganizationEmailsPaginatedAsync(Option<List<Guid>> inboxId = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> unreadOnly = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> syncConnectors = default, Option<bool> favourited = default, Option<Guid> plusAddressId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all organization emails. List team or shared test email accounts
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter search filter for emails. (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favorited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOrganizationEmailsPaginatedApiResponse"/>&gt;</returns>
        Task<IGetOrganizationEmailsPaginatedApiResponse> GetOrganizationEmailsPaginatedOrDefaultAsync(Option<List<Guid>> inboxId = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> unreadOnly = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> syncConnectors = default, Option<bool> favourited = default, Option<Guid> plusAddressId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get raw email string. Returns unparsed raw SMTP message with headers and body.
        /// </summary>
        /// <remarks>
        /// Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRawEmailContentsApiResponse"/>&gt;</returns>
        Task<IGetRawEmailContentsApiResponse> GetRawEmailContentsAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get raw email string. Returns unparsed raw SMTP message with headers and body.
        /// </summary>
        /// <remarks>
        /// Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
        /// </remarks>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRawEmailContentsApiResponse"/>&gt;</returns>
        Task<IGetRawEmailContentsApiResponse> GetRawEmailContentsOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
        /// </summary>
        /// <remarks>
        /// Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRawEmailJsonApiResponse"/>&gt;</returns>
        Task<IGetRawEmailJsonApiResponse> GetRawEmailJsonAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
        /// </summary>
        /// <remarks>
        /// Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
        /// </remarks>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRawEmailJsonApiResponse"/>&gt;</returns>
        Task<IGetRawEmailJsonApiResponse> GetRawEmailJsonOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get unread email count
        /// </summary>
        /// <remarks>
        /// Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUnreadEmailCountApiResponse"/>&gt;</returns>
        Task<IGetUnreadEmailCountApiResponse> GetUnreadEmailCountAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get unread email count
        /// </summary>
        /// <remarks>
        /// Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
        /// </remarks>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUnreadEmailCountApiResponse"/>&gt;</returns>
        Task<IGetUnreadEmailCountApiResponse> GetUnreadEmailCountOrDefaultAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Mark all emails as read or unread
        /// </summary>
        /// <remarks>
        /// Marks all emails as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMarkAllAsReadApiResponse"/>&gt;</returns>
        Task<IMarkAllAsReadApiResponse> MarkAllAsReadAsync(Option<bool> read = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Mark all emails as read or unread
        /// </summary>
        /// <remarks>
        /// Marks all emails as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </remarks>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMarkAllAsReadApiResponse"/>&gt;</returns>
        Task<IMarkAllAsReadApiResponse> MarkAllAsReadOrDefaultAsync(Option<bool> read = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Mark an email as read or unread
        /// </summary>
        /// <remarks>
        /// Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMarkAsReadApiResponse"/>&gt;</returns>
        Task<IMarkAsReadApiResponse> MarkAsReadAsync(Guid emailId, Option<bool> read = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Mark an email as read or unread
        /// </summary>
        /// <remarks>
        /// Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </remarks>
        /// <param name="emailId"></param>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMarkAsReadApiResponse"/>&gt;</returns>
        Task<IMarkAsReadApiResponse> MarkAsReadOrDefaultAsync(Guid emailId, Option<bool> read = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reply to an email
        /// </summary>
        /// <remarks>
        /// Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails &#x60;to&#x60;, &#x60;cc&#x60;, and &#x60;bcc&#x60;.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of the email that should be replied to</param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplyToEmailApiResponse"/>&gt;</returns>
        Task<IReplyToEmailApiResponse> ReplyToEmailAsync(Guid emailId, ReplyToEmailOptions replyToEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reply to an email
        /// </summary>
        /// <remarks>
        /// Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails &#x60;to&#x60;, &#x60;cc&#x60;, and &#x60;bcc&#x60;.
        /// </remarks>
        /// <param name="emailId">ID of the email that should be replied to</param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplyToEmailApiResponse"/>&gt;</returns>
        Task<IReplyToEmailApiResponse> ReplyToEmailOrDefaultAsync(Guid emailId, ReplyToEmailOptions replyToEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all emails by search criteria. Return in paginated form.
        /// </summary>
        /// <remarks>
        /// Search emails by given criteria return matches in paginated format. Searches against email recipients, sender, subject, email address and ID. Does not search email body
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favourited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchEmailsApiResponse"/>&gt;</returns>
        Task<ISearchEmailsApiResponse> SearchEmailsAsync(SearchEmailsOptions searchEmailsOptions, Option<bool> syncConnectors = default, Option<bool> favourited = default, Option<Guid> plusAddressId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all emails by search criteria. Return in paginated form.
        /// </summary>
        /// <remarks>
        /// Search emails by given criteria return matches in paginated format. Searches against email recipients, sender, subject, email address and ID. Does not search email body
        /// </remarks>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favourited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchEmailsApiResponse"/>&gt;</returns>
        Task<ISearchEmailsApiResponse> SearchEmailsOrDefaultAsync(SearchEmailsOptions searchEmailsOptions, Option<bool> syncConnectors = default, Option<bool> favourited = default, Option<Guid> plusAddressId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send email
        /// </summary>
        /// <remarks>
        /// Alias for &#x60;InboxController.sendEmail&#x60; method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId">ID of the inbox you want to send the email from (optional)</param>
        /// <param name="useDomainPool">Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)</param>
        /// <param name="virtualSend">Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailSourceOptionalApiResponse"/>&gt;</returns>
        Task<ISendEmailSourceOptionalApiResponse> SendEmailSourceOptionalAsync(SendEmailOptions sendEmailOptions, Option<Guid> inboxId = default, Option<bool> useDomainPool = default, Option<bool> virtualSend = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send email
        /// </summary>
        /// <remarks>
        /// Alias for &#x60;InboxController.sendEmail&#x60; method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
        /// </remarks>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId">ID of the inbox you want to send the email from (optional)</param>
        /// <param name="useDomainPool">Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)</param>
        /// <param name="virtualSend">Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailSourceOptionalApiResponse"/>&gt;</returns>
        Task<ISendEmailSourceOptionalApiResponse> SendEmailSourceOptionalOrDefaultAsync(SendEmailOptions sendEmailOptions, Option<Guid> inboxId = default, Option<bool> useDomainPool = default, Option<bool> virtualSend = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set email favourited state
        /// </summary>
        /// <remarks>
        /// Set and return new favorite state for an email
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to set favourite state</param>
        /// <param name="favourited"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetEmailFavouritedApiResponse"/>&gt;</returns>
        Task<ISetEmailFavouritedApiResponse> SetEmailFavouritedAsync(Guid emailId, bool favourited, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set email favourited state
        /// </summary>
        /// <remarks>
        /// Set and return new favorite state for an email
        /// </remarks>
        /// <param name="emailId">ID of email to set favourite state</param>
        /// <param name="favourited"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetEmailFavouritedApiResponse"/>&gt;</returns>
        Task<ISetEmailFavouritedApiResponse> SetEmailFavouritedOrDefaultAsync(Guid emailId, bool favourited, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Validate email HTML contents
        /// </summary>
        /// <remarks>
        /// Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IValidateEmailApiResponse"/>&gt;</returns>
        Task<IValidateEmailApiResponse> ValidateEmailAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Validate email HTML contents
        /// </summary>
        /// <remarks>
        /// Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
        /// </remarks>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IValidateEmailApiResponse"/>&gt;</returns>
        Task<IValidateEmailApiResponse> ValidateEmailOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IApplyImapFlagOperationApiResponse"/>
    /// </summary>
    public interface IApplyImapFlagOperationApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailPreview>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICanSendApiResponse"/>
    /// </summary>
    public interface ICanSendApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.CanSendEmailResults>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICheckEmailBodyApiResponse"/>
    /// </summary>
    public interface ICheckEmailBodyApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.CheckEmailBodyResults>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICheckEmailBodyFeatureSupportApiResponse"/>
    /// </summary>
    public interface ICheckEmailBodyFeatureSupportApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.CheckEmailBodyFeatureSupportResults>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICheckEmailClientSupportApiResponse"/>
    /// </summary>
    public interface ICheckEmailClientSupportApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.CheckEmailClientSupportResults>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteAllEmailsApiResponse"/>
    /// </summary>
    public interface IDeleteAllEmailsApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteEmailApiResponse"/>
    /// </summary>
    public interface IDeleteEmailApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IDownloadAttachmentApiResponse"/>
    /// </summary>
    public interface IDownloadAttachmentApiResponse : mailslurp.Client.IApiResponse, IDefault<byte[]>
    {
        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IDownloadAttachmentBase64ApiResponse"/>
    /// </summary>
    public interface IDownloadAttachmentBase64ApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.DownloadAttachmentDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDownloadBodyApiResponse"/>
    /// </summary>
    public interface IDownloadBodyApiResponse : mailslurp.Client.IApiResponse, IOk<string>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDownloadBodyBytesApiResponse"/>
    /// </summary>
    public interface IDownloadBodyBytesApiResponse : mailslurp.Client.IApiResponse, IDefault<byte[]>
    {
        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IForwardEmailApiResponse"/>
    /// </summary>
    public interface IForwardEmailApiResponse : mailslurp.Client.IApiResponse, ICreated<mailslurp.Model.SentEmailDto>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IGetAttachmentMetaDataApiResponse"/>
    /// </summary>
    public interface IGetAttachmentMetaDataApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.AttachmentMetaData>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailApiResponse"/>
    /// </summary>
    public interface IGetEmailApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.Email>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailAttachmentsApiResponse"/>
    /// </summary>
    public interface IGetEmailAttachmentsApiResponse : mailslurp.Client.IApiResponse, IOk<List<AttachmentMetaData>>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailContentMatchApiResponse"/>
    /// </summary>
    public interface IGetEmailContentMatchApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailContentMatchResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailContentPartApiResponse"/>
    /// </summary>
    public interface IGetEmailContentPartApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailContentPartResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailContentPartContentApiResponse"/>
    /// </summary>
    public interface IGetEmailContentPartContentApiResponse : mailslurp.Client.IApiResponse, IOk<string>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailCountApiResponse"/>
    /// </summary>
    public interface IGetEmailCountApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.CountDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailHTMLApiResponse"/>
    /// </summary>
    public interface IGetEmailHTMLApiResponse : mailslurp.Client.IApiResponse, IOk<string>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailHTMLJsonApiResponse"/>
    /// </summary>
    public interface IGetEmailHTMLJsonApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailHtmlDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailHTMLQueryApiResponse"/>
    /// </summary>
    public interface IGetEmailHTMLQueryApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailTextLinesResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailLinksApiResponse"/>
    /// </summary>
    public interface IGetEmailLinksApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailLinksResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailPreviewURLsApiResponse"/>
    /// </summary>
    public interface IGetEmailPreviewURLsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailPreviewUrls>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailScreenshotAsBase64ApiResponse"/>
    /// </summary>
    public interface IGetEmailScreenshotAsBase64ApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailScreenshotResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailScreenshotAsBinaryApiResponse"/>
    /// </summary>
    public interface IGetEmailScreenshotAsBinaryApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailSummaryApiResponse"/>
    /// </summary>
    public interface IGetEmailSummaryApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailPreview>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailTextLinesApiResponse"/>
    /// </summary>
    public interface IGetEmailTextLinesApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailTextLinesResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailThreadApiResponse"/>
    /// </summary>
    public interface IGetEmailThreadApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailThreadDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailThreadItemsApiResponse"/>
    /// </summary>
    public interface IGetEmailThreadItemsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailThreadItemsDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailThreadsApiResponse"/>
    /// </summary>
    public interface IGetEmailThreadsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageEmailThreadProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailsOffsetPaginatedApiResponse"/>
    /// </summary>
    public interface IGetEmailsOffsetPaginatedApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageEmailProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmailsPaginatedApiResponse"/>
    /// </summary>
    public interface IGetEmailsPaginatedApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageEmailProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetGravatarUrlForEmailAddressApiResponse"/>
    /// </summary>
    public interface IGetGravatarUrlForEmailAddressApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.GravatarUrl>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetLatestEmailApiResponse"/>
    /// </summary>
    public interface IGetLatestEmailApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.Email>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetLatestEmailInInbox1ApiResponse"/>
    /// </summary>
    public interface IGetLatestEmailInInbox1ApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.Email>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetOrganizationEmailsPaginatedApiResponse"/>
    /// </summary>
    public interface IGetOrganizationEmailsPaginatedApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageEmailProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetRawEmailContentsApiResponse"/>
    /// </summary>
    public interface IGetRawEmailContentsApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetRawEmailJsonApiResponse"/>
    /// </summary>
    public interface IGetRawEmailJsonApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.RawEmailJson>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetUnreadEmailCountApiResponse"/>
    /// </summary>
    public interface IGetUnreadEmailCountApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.UnreadCount>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IMarkAllAsReadApiResponse"/>
    /// </summary>
    public interface IMarkAllAsReadApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IMarkAsReadApiResponse"/>
    /// </summary>
    public interface IMarkAsReadApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.EmailPreview>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IReplyToEmailApiResponse"/>
    /// </summary>
    public interface IReplyToEmailApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.SentEmailDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchEmailsApiResponse"/>
    /// </summary>
    public interface ISearchEmailsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageEmailProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISendEmailSourceOptionalApiResponse"/>
    /// </summary>
    public interface ISendEmailSourceOptionalApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ISetEmailFavouritedApiResponse"/>
    /// </summary>
    public interface ISetEmailFavouritedApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IValidateEmailApiResponse"/>
    /// </summary>
    public interface IValidateEmailApiResponse : mailslurp.Client.IApiResponse, ICreated<mailslurp.Model.ValidationDto>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class EmailControllerApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnApplyImapFlagOperation;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorApplyImapFlagOperation;

        internal void ExecuteOnApplyImapFlagOperation(EmailControllerApi.ApplyImapFlagOperationApiResponse apiResponse)
        {
            OnApplyImapFlagOperation?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApplyImapFlagOperation(Exception exception)
        {
            OnErrorApplyImapFlagOperation?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnCanSend;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorCanSend;

        internal void ExecuteOnCanSend(EmailControllerApi.CanSendApiResponse apiResponse)
        {
            OnCanSend?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCanSend(Exception exception)
        {
            OnErrorCanSend?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnCheckEmailBody;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorCheckEmailBody;

        internal void ExecuteOnCheckEmailBody(EmailControllerApi.CheckEmailBodyApiResponse apiResponse)
        {
            OnCheckEmailBody?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCheckEmailBody(Exception exception)
        {
            OnErrorCheckEmailBody?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnCheckEmailBodyFeatureSupport;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorCheckEmailBodyFeatureSupport;

        internal void ExecuteOnCheckEmailBodyFeatureSupport(EmailControllerApi.CheckEmailBodyFeatureSupportApiResponse apiResponse)
        {
            OnCheckEmailBodyFeatureSupport?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCheckEmailBodyFeatureSupport(Exception exception)
        {
            OnErrorCheckEmailBodyFeatureSupport?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnCheckEmailClientSupport;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorCheckEmailClientSupport;

        internal void ExecuteOnCheckEmailClientSupport(EmailControllerApi.CheckEmailClientSupportApiResponse apiResponse)
        {
            OnCheckEmailClientSupport?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCheckEmailClientSupport(Exception exception)
        {
            OnErrorCheckEmailClientSupport?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteAllEmails;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteAllEmails;

        internal void ExecuteOnDeleteAllEmails(EmailControllerApi.DeleteAllEmailsApiResponse apiResponse)
        {
            OnDeleteAllEmails?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteAllEmails(Exception exception)
        {
            OnErrorDeleteAllEmails?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteEmail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteEmail;

        internal void ExecuteOnDeleteEmail(EmailControllerApi.DeleteEmailApiResponse apiResponse)
        {
            OnDeleteEmail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteEmail(Exception exception)
        {
            OnErrorDeleteEmail?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDownloadAttachment;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDownloadAttachment;

        internal void ExecuteOnDownloadAttachment(EmailControllerApi.DownloadAttachmentApiResponse apiResponse)
        {
            OnDownloadAttachment?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDownloadAttachment(Exception exception)
        {
            OnErrorDownloadAttachment?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDownloadAttachmentBase64;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDownloadAttachmentBase64;

        internal void ExecuteOnDownloadAttachmentBase64(EmailControllerApi.DownloadAttachmentBase64ApiResponse apiResponse)
        {
            OnDownloadAttachmentBase64?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDownloadAttachmentBase64(Exception exception)
        {
            OnErrorDownloadAttachmentBase64?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDownloadBody;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDownloadBody;

        internal void ExecuteOnDownloadBody(EmailControllerApi.DownloadBodyApiResponse apiResponse)
        {
            OnDownloadBody?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDownloadBody(Exception exception)
        {
            OnErrorDownloadBody?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDownloadBodyBytes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDownloadBodyBytes;

        internal void ExecuteOnDownloadBodyBytes(EmailControllerApi.DownloadBodyBytesApiResponse apiResponse)
        {
            OnDownloadBodyBytes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDownloadBodyBytes(Exception exception)
        {
            OnErrorDownloadBodyBytes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnForwardEmail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorForwardEmail;

        internal void ExecuteOnForwardEmail(EmailControllerApi.ForwardEmailApiResponse apiResponse)
        {
            OnForwardEmail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorForwardEmail(Exception exception)
        {
            OnErrorForwardEmail?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetAttachmentMetaData;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetAttachmentMetaData;

        internal void ExecuteOnGetAttachmentMetaData(EmailControllerApi.GetAttachmentMetaDataApiResponse apiResponse)
        {
            OnGetAttachmentMetaData?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAttachmentMetaData(Exception exception)
        {
            OnErrorGetAttachmentMetaData?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmail;

        internal void ExecuteOnGetEmail(EmailControllerApi.GetEmailApiResponse apiResponse)
        {
            OnGetEmail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmail(Exception exception)
        {
            OnErrorGetEmail?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailAttachments;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailAttachments;

        internal void ExecuteOnGetEmailAttachments(EmailControllerApi.GetEmailAttachmentsApiResponse apiResponse)
        {
            OnGetEmailAttachments?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailAttachments(Exception exception)
        {
            OnErrorGetEmailAttachments?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailContentMatch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailContentMatch;

        internal void ExecuteOnGetEmailContentMatch(EmailControllerApi.GetEmailContentMatchApiResponse apiResponse)
        {
            OnGetEmailContentMatch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailContentMatch(Exception exception)
        {
            OnErrorGetEmailContentMatch?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailContentPart;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailContentPart;

        internal void ExecuteOnGetEmailContentPart(EmailControllerApi.GetEmailContentPartApiResponse apiResponse)
        {
            OnGetEmailContentPart?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailContentPart(Exception exception)
        {
            OnErrorGetEmailContentPart?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailContentPartContent;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailContentPartContent;

        internal void ExecuteOnGetEmailContentPartContent(EmailControllerApi.GetEmailContentPartContentApiResponse apiResponse)
        {
            OnGetEmailContentPartContent?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailContentPartContent(Exception exception)
        {
            OnErrorGetEmailContentPartContent?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailCount;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailCount;

        internal void ExecuteOnGetEmailCount(EmailControllerApi.GetEmailCountApiResponse apiResponse)
        {
            OnGetEmailCount?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailCount(Exception exception)
        {
            OnErrorGetEmailCount?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailHTML;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailHTML;

        internal void ExecuteOnGetEmailHTML(EmailControllerApi.GetEmailHTMLApiResponse apiResponse)
        {
            OnGetEmailHTML?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailHTML(Exception exception)
        {
            OnErrorGetEmailHTML?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailHTMLJson;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailHTMLJson;

        internal void ExecuteOnGetEmailHTMLJson(EmailControllerApi.GetEmailHTMLJsonApiResponse apiResponse)
        {
            OnGetEmailHTMLJson?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailHTMLJson(Exception exception)
        {
            OnErrorGetEmailHTMLJson?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailHTMLQuery;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailHTMLQuery;

        internal void ExecuteOnGetEmailHTMLQuery(EmailControllerApi.GetEmailHTMLQueryApiResponse apiResponse)
        {
            OnGetEmailHTMLQuery?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailHTMLQuery(Exception exception)
        {
            OnErrorGetEmailHTMLQuery?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailLinks;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailLinks;

        internal void ExecuteOnGetEmailLinks(EmailControllerApi.GetEmailLinksApiResponse apiResponse)
        {
            OnGetEmailLinks?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailLinks(Exception exception)
        {
            OnErrorGetEmailLinks?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailPreviewURLs;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailPreviewURLs;

        internal void ExecuteOnGetEmailPreviewURLs(EmailControllerApi.GetEmailPreviewURLsApiResponse apiResponse)
        {
            OnGetEmailPreviewURLs?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailPreviewURLs(Exception exception)
        {
            OnErrorGetEmailPreviewURLs?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailScreenshotAsBase64;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailScreenshotAsBase64;

        internal void ExecuteOnGetEmailScreenshotAsBase64(EmailControllerApi.GetEmailScreenshotAsBase64ApiResponse apiResponse)
        {
            OnGetEmailScreenshotAsBase64?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailScreenshotAsBase64(Exception exception)
        {
            OnErrorGetEmailScreenshotAsBase64?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailScreenshotAsBinary;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailScreenshotAsBinary;

        internal void ExecuteOnGetEmailScreenshotAsBinary(EmailControllerApi.GetEmailScreenshotAsBinaryApiResponse apiResponse)
        {
            OnGetEmailScreenshotAsBinary?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailScreenshotAsBinary(Exception exception)
        {
            OnErrorGetEmailScreenshotAsBinary?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailSummary;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailSummary;

        internal void ExecuteOnGetEmailSummary(EmailControllerApi.GetEmailSummaryApiResponse apiResponse)
        {
            OnGetEmailSummary?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailSummary(Exception exception)
        {
            OnErrorGetEmailSummary?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailTextLines;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailTextLines;

        internal void ExecuteOnGetEmailTextLines(EmailControllerApi.GetEmailTextLinesApiResponse apiResponse)
        {
            OnGetEmailTextLines?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailTextLines(Exception exception)
        {
            OnErrorGetEmailTextLines?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailThread;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailThread;

        internal void ExecuteOnGetEmailThread(EmailControllerApi.GetEmailThreadApiResponse apiResponse)
        {
            OnGetEmailThread?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailThread(Exception exception)
        {
            OnErrorGetEmailThread?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailThreadItems;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailThreadItems;

        internal void ExecuteOnGetEmailThreadItems(EmailControllerApi.GetEmailThreadItemsApiResponse apiResponse)
        {
            OnGetEmailThreadItems?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailThreadItems(Exception exception)
        {
            OnErrorGetEmailThreadItems?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailThreads;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailThreads;

        internal void ExecuteOnGetEmailThreads(EmailControllerApi.GetEmailThreadsApiResponse apiResponse)
        {
            OnGetEmailThreads?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailThreads(Exception exception)
        {
            OnErrorGetEmailThreads?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailsOffsetPaginated;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailsOffsetPaginated;

        internal void ExecuteOnGetEmailsOffsetPaginated(EmailControllerApi.GetEmailsOffsetPaginatedApiResponse apiResponse)
        {
            OnGetEmailsOffsetPaginated?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailsOffsetPaginated(Exception exception)
        {
            OnErrorGetEmailsOffsetPaginated?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetEmailsPaginated;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetEmailsPaginated;

        internal void ExecuteOnGetEmailsPaginated(EmailControllerApi.GetEmailsPaginatedApiResponse apiResponse)
        {
            OnGetEmailsPaginated?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmailsPaginated(Exception exception)
        {
            OnErrorGetEmailsPaginated?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetGravatarUrlForEmailAddress;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetGravatarUrlForEmailAddress;

        internal void ExecuteOnGetGravatarUrlForEmailAddress(EmailControllerApi.GetGravatarUrlForEmailAddressApiResponse apiResponse)
        {
            OnGetGravatarUrlForEmailAddress?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetGravatarUrlForEmailAddress(Exception exception)
        {
            OnErrorGetGravatarUrlForEmailAddress?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetLatestEmail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetLatestEmail;

        internal void ExecuteOnGetLatestEmail(EmailControllerApi.GetLatestEmailApiResponse apiResponse)
        {
            OnGetLatestEmail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetLatestEmail(Exception exception)
        {
            OnErrorGetLatestEmail?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetLatestEmailInInbox1;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetLatestEmailInInbox1;

        internal void ExecuteOnGetLatestEmailInInbox1(EmailControllerApi.GetLatestEmailInInbox1ApiResponse apiResponse)
        {
            OnGetLatestEmailInInbox1?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetLatestEmailInInbox1(Exception exception)
        {
            OnErrorGetLatestEmailInInbox1?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetOrganizationEmailsPaginated;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetOrganizationEmailsPaginated;

        internal void ExecuteOnGetOrganizationEmailsPaginated(EmailControllerApi.GetOrganizationEmailsPaginatedApiResponse apiResponse)
        {
            OnGetOrganizationEmailsPaginated?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetOrganizationEmailsPaginated(Exception exception)
        {
            OnErrorGetOrganizationEmailsPaginated?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetRawEmailContents;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetRawEmailContents;

        internal void ExecuteOnGetRawEmailContents(EmailControllerApi.GetRawEmailContentsApiResponse apiResponse)
        {
            OnGetRawEmailContents?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetRawEmailContents(Exception exception)
        {
            OnErrorGetRawEmailContents?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetRawEmailJson;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetRawEmailJson;

        internal void ExecuteOnGetRawEmailJson(EmailControllerApi.GetRawEmailJsonApiResponse apiResponse)
        {
            OnGetRawEmailJson?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetRawEmailJson(Exception exception)
        {
            OnErrorGetRawEmailJson?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetUnreadEmailCount;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetUnreadEmailCount;

        internal void ExecuteOnGetUnreadEmailCount(EmailControllerApi.GetUnreadEmailCountApiResponse apiResponse)
        {
            OnGetUnreadEmailCount?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetUnreadEmailCount(Exception exception)
        {
            OnErrorGetUnreadEmailCount?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnMarkAllAsRead;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorMarkAllAsRead;

        internal void ExecuteOnMarkAllAsRead(EmailControllerApi.MarkAllAsReadApiResponse apiResponse)
        {
            OnMarkAllAsRead?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorMarkAllAsRead(Exception exception)
        {
            OnErrorMarkAllAsRead?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnMarkAsRead;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorMarkAsRead;

        internal void ExecuteOnMarkAsRead(EmailControllerApi.MarkAsReadApiResponse apiResponse)
        {
            OnMarkAsRead?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorMarkAsRead(Exception exception)
        {
            OnErrorMarkAsRead?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnReplyToEmail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorReplyToEmail;

        internal void ExecuteOnReplyToEmail(EmailControllerApi.ReplyToEmailApiResponse apiResponse)
        {
            OnReplyToEmail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorReplyToEmail(Exception exception)
        {
            OnErrorReplyToEmail?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSearchEmails;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSearchEmails;

        internal void ExecuteOnSearchEmails(EmailControllerApi.SearchEmailsApiResponse apiResponse)
        {
            OnSearchEmails?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchEmails(Exception exception)
        {
            OnErrorSearchEmails?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSendEmailSourceOptional;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSendEmailSourceOptional;

        internal void ExecuteOnSendEmailSourceOptional(EmailControllerApi.SendEmailSourceOptionalApiResponse apiResponse)
        {
            OnSendEmailSourceOptional?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendEmailSourceOptional(Exception exception)
        {
            OnErrorSendEmailSourceOptional?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSetEmailFavourited;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSetEmailFavourited;

        internal void ExecuteOnSetEmailFavourited(EmailControllerApi.SetEmailFavouritedApiResponse apiResponse)
        {
            OnSetEmailFavourited?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSetEmailFavourited(Exception exception)
        {
            OnErrorSetEmailFavourited?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnValidateEmail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorValidateEmail;

        internal void ExecuteOnValidateEmail(EmailControllerApi.ValidateEmailApiResponse apiResponse)
        {
            OnValidateEmail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorValidateEmail(Exception exception)
        {
            OnErrorValidateEmail?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class EmailControllerApi : IEmailControllerApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<EmailControllerApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public EmailControllerApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="EmailControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public EmailControllerApi(ILogger<EmailControllerApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, EmailControllerApiEvents emailControllerApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<EmailControllerApi>();
            HttpClient = httpClient;
            Events = emailControllerApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatApplyImapFlagOperation(ref Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="imapFlagOperationOptions"></param>
        /// <returns></returns>
        private void ValidateApplyImapFlagOperation(ImapFlagOperationOptions imapFlagOperationOptions)
        {
            if (imapFlagOperationOptions == null)
                throw new ArgumentNullException(nameof(imapFlagOperationOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        private void AfterApplyImapFlagOperationDefaultImplementation(IApplyImapFlagOperationApiResponse apiResponseLocalVar, Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions)
        {
            bool suppressDefaultLog = false;
            AfterApplyImapFlagOperation(ref suppressDefaultLog, apiResponseLocalVar, emailId, imapFlagOperationOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        partial void AfterApplyImapFlagOperation(ref bool suppressDefaultLog, IApplyImapFlagOperationApiResponse apiResponseLocalVar, Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        private void OnErrorApplyImapFlagOperationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApplyImapFlagOperation(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, imapFlagOperationOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        partial void OnErrorApplyImapFlagOperation(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions);

        /// <summary>
        /// Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag. Apply RFC3501 section-2.3.2 IMAP flag operations on an email
        /// </summary>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApplyImapFlagOperationApiResponse"/>&gt;</returns>
        public async Task<IApplyImapFlagOperationApiResponse> ApplyImapFlagOperationOrDefaultAsync(Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApplyImapFlagOperationAsync(emailId, imapFlagOperationOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag. Apply RFC3501 section-2.3.2 IMAP flag operations on an email
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApplyImapFlagOperationApiResponse"/>&gt;</returns>
        public async Task<IApplyImapFlagOperationApiResponse> ApplyImapFlagOperationAsync(Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApplyImapFlagOperation(imapFlagOperationOptions);

                FormatApplyImapFlagOperation(ref emailId, imapFlagOperationOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/imap-flag-operation"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/imap-flag-operation");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    httpRequestMessageLocalVar.Content = (imapFlagOperationOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(imapFlagOperationOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ApplyImapFlagOperationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApplyImapFlagOperationApiResponse>();

                        ApplyImapFlagOperationApiResponse apiResponseLocalVar = new ApplyImapFlagOperationApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/imap-flag-operation", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterApplyImapFlagOperationDefaultImplementation(apiResponseLocalVar, emailId, imapFlagOperationOptions);

                        Events.ExecuteOnApplyImapFlagOperation(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApplyImapFlagOperationDefaultImplementation(e, "/emails/{emailId}/imap-flag-operation", uriBuilderLocalVar.Path, emailId, imapFlagOperationOptions);
                Events.ExecuteOnErrorApplyImapFlagOperation(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApplyImapFlagOperationApiResponse"/>
        /// </summary>
        public partial class ApplyImapFlagOperationApiResponse : mailslurp.Client.ApiResponse, IApplyImapFlagOperationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApplyImapFlagOperationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApplyImapFlagOperationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApplyImapFlagOperationApiResponse(ILogger<ApplyImapFlagOperationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailPreview Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailPreview>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailPreview result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCanSend(ref Guid inboxId, SendEmailOptions sendEmailOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sendEmailOptions"></param>
        /// <returns></returns>
        private void ValidateCanSend(SendEmailOptions sendEmailOptions)
        {
            if (sendEmailOptions == null)
                throw new ArgumentNullException(nameof(sendEmailOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        private void AfterCanSendDefaultImplementation(ICanSendApiResponse apiResponseLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions)
        {
            bool suppressDefaultLog = false;
            AfterCanSend(ref suppressDefaultLog, apiResponseLocalVar, inboxId, sendEmailOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        partial void AfterCanSend(ref bool suppressDefaultLog, ICanSendApiResponse apiResponseLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        private void OnErrorCanSendDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCanSend(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, sendEmailOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="sendEmailOptions"></param>
        partial void OnErrorCanSend(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, SendEmailOptions sendEmailOptions);

        /// <summary>
        /// Check if email can be sent and options are valid. Can user send email to given recipient or is the recipient blocked
        /// </summary>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICanSendApiResponse"/>&gt;</returns>
        public async Task<ICanSendApiResponse> CanSendOrDefaultAsync(Guid inboxId, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CanSendAsync(inboxId, sendEmailOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Check if email can be sent and options are valid. Can user send email to given recipient or is the recipient blocked
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICanSendApiResponse"/>&gt;</returns>
        public async Task<ICanSendApiResponse> CanSendAsync(Guid inboxId, SendEmailOptions sendEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCanSend(sendEmailOptions);

                FormatCanSend(ref inboxId, sendEmailOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/can-send"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/can-send");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (sendEmailOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendEmailOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<CanSendApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CanSendApiResponse>();

                        CanSendApiResponse apiResponseLocalVar = new CanSendApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/can-send", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCanSendDefaultImplementation(apiResponseLocalVar, inboxId, sendEmailOptions);

                        Events.ExecuteOnCanSend(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCanSendDefaultImplementation(e, "/emails/can-send", uriBuilderLocalVar.Path, inboxId, sendEmailOptions);
                Events.ExecuteOnErrorCanSend(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CanSendApiResponse"/>
        /// </summary>
        public partial class CanSendApiResponse : mailslurp.Client.ApiResponse, ICanSendApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CanSendApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CanSendApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CanSendApiResponse(ILogger<CanSendApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.CanSendEmailResults Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.CanSendEmailResults>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.CanSendEmailResults result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCheckEmailBody(ref Guid emailId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        private void AfterCheckEmailBodyDefaultImplementation(ICheckEmailBodyApiResponse apiResponseLocalVar, Guid emailId)
        {
            bool suppressDefaultLog = false;
            AfterCheckEmailBody(ref suppressDefaultLog, apiResponseLocalVar, emailId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        partial void AfterCheckEmailBody(ref bool suppressDefaultLog, ICheckEmailBodyApiResponse apiResponseLocalVar, Guid emailId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        private void OnErrorCheckEmailBodyDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCheckEmailBody(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        partial void OnErrorCheckEmailBody(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId);

        /// <summary>
        /// Detect broken links, spelling, and images in email content Find dead links, broken images, and spelling mistakes in email body. Will call included links via HTTP so do not invoke if your links are sensitive or stateful. Any resource that returns a 4xx or 5xx response or is not reachable via HEAD or GET HTTP operations will be considered unhealthy.
        /// </summary>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckEmailBodyApiResponse"/>&gt;</returns>
        public async Task<ICheckEmailBodyApiResponse> CheckEmailBodyOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CheckEmailBodyAsync(emailId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Detect broken links, spelling, and images in email content Find dead links, broken images, and spelling mistakes in email body. Will call included links via HTTP so do not invoke if your links are sensitive or stateful. Any resource that returns a 4xx or 5xx response or is not reachable via HEAD or GET HTTP operations will be considered unhealthy.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckEmailBodyApiResponse"/>&gt;</returns>
        public async Task<ICheckEmailBodyApiResponse> CheckEmailBodyAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatCheckEmailBody(ref emailId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/check-email-body"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/check-email-body");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<CheckEmailBodyApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CheckEmailBodyApiResponse>();

                        CheckEmailBodyApiResponse apiResponseLocalVar = new CheckEmailBodyApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/check-email-body", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCheckEmailBodyDefaultImplementation(apiResponseLocalVar, emailId);

                        Events.ExecuteOnCheckEmailBody(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCheckEmailBodyDefaultImplementation(e, "/emails/{emailId}/check-email-body", uriBuilderLocalVar.Path, emailId);
                Events.ExecuteOnErrorCheckEmailBody(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CheckEmailBodyApiResponse"/>
        /// </summary>
        public partial class CheckEmailBodyApiResponse : mailslurp.Client.ApiResponse, ICheckEmailBodyApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CheckEmailBodyApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CheckEmailBodyApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CheckEmailBodyApiResponse(ILogger<CheckEmailBodyApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.CheckEmailBodyResults Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.CheckEmailBodyResults>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.CheckEmailBodyResults result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCheckEmailBodyFeatureSupport(ref Guid emailId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        private void AfterCheckEmailBodyFeatureSupportDefaultImplementation(ICheckEmailBodyFeatureSupportApiResponse apiResponseLocalVar, Guid emailId)
        {
            bool suppressDefaultLog = false;
            AfterCheckEmailBodyFeatureSupport(ref suppressDefaultLog, apiResponseLocalVar, emailId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        partial void AfterCheckEmailBodyFeatureSupport(ref bool suppressDefaultLog, ICheckEmailBodyFeatureSupportApiResponse apiResponseLocalVar, Guid emailId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        private void OnErrorCheckEmailBodyFeatureSupportDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCheckEmailBodyFeatureSupport(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        partial void OnErrorCheckEmailBodyFeatureSupport(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId);

        /// <summary>
        /// Show which mail clients support the HTML and CSS features used in an email body. Detect HTML and CSS features inside an email body and return a report of email client support across different platforms and versions.
        /// </summary>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckEmailBodyFeatureSupportApiResponse"/>&gt;</returns>
        public async Task<ICheckEmailBodyFeatureSupportApiResponse> CheckEmailBodyFeatureSupportOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CheckEmailBodyFeatureSupportAsync(emailId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Show which mail clients support the HTML and CSS features used in an email body. Detect HTML and CSS features inside an email body and return a report of email client support across different platforms and versions.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckEmailBodyFeatureSupportApiResponse"/>&gt;</returns>
        public async Task<ICheckEmailBodyFeatureSupportApiResponse> CheckEmailBodyFeatureSupportAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatCheckEmailBodyFeatureSupport(ref emailId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/check-email-body-feature-support"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/check-email-body-feature-support");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<CheckEmailBodyFeatureSupportApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CheckEmailBodyFeatureSupportApiResponse>();

                        CheckEmailBodyFeatureSupportApiResponse apiResponseLocalVar = new CheckEmailBodyFeatureSupportApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/check-email-body-feature-support", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCheckEmailBodyFeatureSupportDefaultImplementation(apiResponseLocalVar, emailId);

                        Events.ExecuteOnCheckEmailBodyFeatureSupport(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCheckEmailBodyFeatureSupportDefaultImplementation(e, "/emails/{emailId}/check-email-body-feature-support", uriBuilderLocalVar.Path, emailId);
                Events.ExecuteOnErrorCheckEmailBodyFeatureSupport(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CheckEmailBodyFeatureSupportApiResponse"/>
        /// </summary>
        public partial class CheckEmailBodyFeatureSupportApiResponse : mailslurp.Client.ApiResponse, ICheckEmailBodyFeatureSupportApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CheckEmailBodyFeatureSupportApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CheckEmailBodyFeatureSupportApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CheckEmailBodyFeatureSupportApiResponse(ILogger<CheckEmailBodyFeatureSupportApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.CheckEmailBodyFeatureSupportResults Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.CheckEmailBodyFeatureSupportResults>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.CheckEmailBodyFeatureSupportResults result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCheckEmailClientSupport(CheckEmailClientSupportOptions checkEmailClientSupportOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <returns></returns>
        private void ValidateCheckEmailClientSupport(CheckEmailClientSupportOptions checkEmailClientSupportOptions)
        {
            if (checkEmailClientSupportOptions == null)
                throw new ArgumentNullException(nameof(checkEmailClientSupportOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="checkEmailClientSupportOptions"></param>
        private void AfterCheckEmailClientSupportDefaultImplementation(ICheckEmailClientSupportApiResponse apiResponseLocalVar, CheckEmailClientSupportOptions checkEmailClientSupportOptions)
        {
            bool suppressDefaultLog = false;
            AfterCheckEmailClientSupport(ref suppressDefaultLog, apiResponseLocalVar, checkEmailClientSupportOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="checkEmailClientSupportOptions"></param>
        partial void AfterCheckEmailClientSupport(ref bool suppressDefaultLog, ICheckEmailClientSupportApiResponse apiResponseLocalVar, CheckEmailClientSupportOptions checkEmailClientSupportOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="checkEmailClientSupportOptions"></param>
        private void OnErrorCheckEmailClientSupportDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CheckEmailClientSupportOptions checkEmailClientSupportOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCheckEmailClientSupport(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, checkEmailClientSupportOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="checkEmailClientSupportOptions"></param>
        partial void OnErrorCheckEmailClientSupport(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CheckEmailClientSupportOptions checkEmailClientSupportOptions);

        /// <summary>
        /// Show which email programs and devices support the features used in an email body. Evaluate the features used in an email body and return a report of email client support across different platforms and versions.
        /// </summary>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckEmailClientSupportApiResponse"/>&gt;</returns>
        public async Task<ICheckEmailClientSupportApiResponse> CheckEmailClientSupportOrDefaultAsync(CheckEmailClientSupportOptions checkEmailClientSupportOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CheckEmailClientSupportAsync(checkEmailClientSupportOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Show which email programs and devices support the features used in an email body. Evaluate the features used in an email body and return a report of email client support across different platforms and versions.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckEmailClientSupportApiResponse"/>&gt;</returns>
        public async Task<ICheckEmailClientSupportApiResponse> CheckEmailClientSupportAsync(CheckEmailClientSupportOptions checkEmailClientSupportOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCheckEmailClientSupport(checkEmailClientSupportOptions);

                FormatCheckEmailClientSupport(checkEmailClientSupportOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/check-email-client-support"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/check-email-client-support");

                    httpRequestMessageLocalVar.Content = (checkEmailClientSupportOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(checkEmailClientSupportOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<CheckEmailClientSupportApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CheckEmailClientSupportApiResponse>();

                        CheckEmailClientSupportApiResponse apiResponseLocalVar = new CheckEmailClientSupportApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/check-email-client-support", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCheckEmailClientSupportDefaultImplementation(apiResponseLocalVar, checkEmailClientSupportOptions);

                        Events.ExecuteOnCheckEmailClientSupport(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCheckEmailClientSupportDefaultImplementation(e, "/emails/check-email-client-support", uriBuilderLocalVar.Path, checkEmailClientSupportOptions);
                Events.ExecuteOnErrorCheckEmailClientSupport(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CheckEmailClientSupportApiResponse"/>
        /// </summary>
        public partial class CheckEmailClientSupportApiResponse : mailslurp.Client.ApiResponse, ICheckEmailClientSupportApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CheckEmailClientSupportApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CheckEmailClientSupportApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CheckEmailClientSupportApiResponse(ILogger<CheckEmailClientSupportApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.CheckEmailClientSupportResults Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.CheckEmailClientSupportResults>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.CheckEmailClientSupportResults result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterDeleteAllEmailsDefaultImplementation(IDeleteAllEmailsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterDeleteAllEmails(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterDeleteAllEmails(ref bool suppressDefaultLog, IDeleteAllEmailsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorDeleteAllEmailsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteAllEmails(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorDeleteAllEmails(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Delete all emails in all inboxes. Deletes all emails in your account. Be careful as emails cannot be recovered
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllEmailsApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllEmailsApiResponse> DeleteAllEmailsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteAllEmailsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete all emails in all inboxes. Deletes all emails in your account. Be careful as emails cannot be recovered
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllEmailsApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllEmailsApiResponse> DeleteAllEmailsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DeleteAllEmailsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteAllEmailsApiResponse>();

                        DeleteAllEmailsApiResponse apiResponseLocalVar = new DeleteAllEmailsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteAllEmailsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnDeleteAllEmails(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteAllEmailsDefaultImplementation(e, "/emails", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorDeleteAllEmails(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteAllEmailsApiResponse"/>
        /// </summary>
        public partial class DeleteAllEmailsApiResponse : mailslurp.Client.ApiResponse, IDeleteAllEmailsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteAllEmailsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteAllEmailsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteAllEmailsApiResponse(ILogger<DeleteAllEmailsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteEmail(ref Guid emailId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        private void AfterDeleteEmailDefaultImplementation(IDeleteEmailApiResponse apiResponseLocalVar, Guid emailId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteEmail(ref suppressDefaultLog, apiResponseLocalVar, emailId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        partial void AfterDeleteEmail(ref bool suppressDefaultLog, IDeleteEmailApiResponse apiResponseLocalVar, Guid emailId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        private void OnErrorDeleteEmailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteEmail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        partial void OnErrorDeleteEmail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId);

        /// <summary>
        /// Delete an email Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
        /// </summary>
        /// <param name="emailId">ID of email to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteEmailApiResponse"/>&gt;</returns>
        public async Task<IDeleteEmailApiResponse> DeleteEmailOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteEmailAsync(emailId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete an email Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteEmailApiResponse"/>&gt;</returns>
        public async Task<IDeleteEmailApiResponse> DeleteEmailAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteEmail(ref emailId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DeleteEmailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteEmailApiResponse>();

                        DeleteEmailApiResponse apiResponseLocalVar = new DeleteEmailApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteEmailDefaultImplementation(apiResponseLocalVar, emailId);

                        Events.ExecuteOnDeleteEmail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteEmailDefaultImplementation(e, "/emails/{emailId}", uriBuilderLocalVar.Path, emailId);
                Events.ExecuteOnErrorDeleteEmail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteEmailApiResponse"/>
        /// </summary>
        public partial class DeleteEmailApiResponse : mailslurp.Client.ApiResponse, IDeleteEmailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteEmailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteEmailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteEmailApiResponse(ILogger<DeleteEmailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDownloadAttachment(ref Guid emailId, ref string attachmentId, ref Option<string> apiKey);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="attachmentId"></param>
        /// <param name="apiKey"></param>
        /// <returns></returns>
        private void ValidateDownloadAttachment(string attachmentId, Option<string> apiKey)
        {
            if (attachmentId == null)
                throw new ArgumentNullException(nameof(attachmentId));

            if (apiKey.IsSet && apiKey.Value == null)
                throw new ArgumentNullException(nameof(apiKey));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="attachmentId"></param>
        /// <param name="apiKey"></param>
        private void AfterDownloadAttachmentDefaultImplementation(IDownloadAttachmentApiResponse apiResponseLocalVar, Guid emailId, string attachmentId, Option<string> apiKey)
        {
            bool suppressDefaultLog = false;
            AfterDownloadAttachment(ref suppressDefaultLog, apiResponseLocalVar, emailId, attachmentId, apiKey);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="attachmentId"></param>
        /// <param name="apiKey"></param>
        partial void AfterDownloadAttachment(ref bool suppressDefaultLog, IDownloadAttachmentApiResponse apiResponseLocalVar, Guid emailId, string attachmentId, Option<string> apiKey);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="attachmentId"></param>
        /// <param name="apiKey"></param>
        private void OnErrorDownloadAttachmentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, string attachmentId, Option<string> apiKey)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDownloadAttachment(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, attachmentId, apiKey);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="attachmentId"></param>
        /// <param name="apiKey"></param>
        partial void OnErrorDownloadAttachment(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, string attachmentId, Option<string> apiKey);

        /// <summary>
        /// Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string. Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </summary>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="apiKey">Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentApiResponse"/>&gt;</returns>
        public async Task<IDownloadAttachmentApiResponse> DownloadAttachmentOrDefaultAsync(Guid emailId, string attachmentId, Option<string> apiKey = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DownloadAttachmentAsync(emailId, attachmentId, apiKey, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string. Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="apiKey">Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentApiResponse"/>&gt;</returns>
        public async Task<IDownloadAttachmentApiResponse> DownloadAttachmentAsync(Guid emailId, string attachmentId, Option<string> apiKey = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDownloadAttachment(attachmentId, apiKey);

                FormatDownloadAttachment(ref emailId, ref attachmentId, ref apiKey);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/attachments/{attachmentId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/attachments/{attachmentId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BattachmentId%7D", Uri.EscapeDataString(attachmentId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (apiKey.IsSet)
                        parseQueryStringLocalVar["apiKey"] = ClientUtils.ParameterToString(apiKey.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/octet-stream"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DownloadAttachmentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DownloadAttachmentApiResponse>();

                        DownloadAttachmentApiResponse apiResponseLocalVar = new DownloadAttachmentApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/attachments/{attachmentId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDownloadAttachmentDefaultImplementation(apiResponseLocalVar, emailId, attachmentId, apiKey);

                        Events.ExecuteOnDownloadAttachment(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDownloadAttachmentDefaultImplementation(e, "/emails/{emailId}/attachments/{attachmentId}", uriBuilderLocalVar.Path, emailId, attachmentId, apiKey);
                Events.ExecuteOnErrorDownloadAttachment(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DownloadAttachmentApiResponse"/>
        /// </summary>
        public partial class DownloadAttachmentApiResponse : mailslurp.Client.ApiResponse, IDownloadAttachmentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DownloadAttachmentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DownloadAttachmentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DownloadAttachmentApiResponse(ILogger<DownloadAttachmentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => true;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public byte[] Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<byte[]>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault(out byte[] result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDownloadAttachmentBase64(ref Guid emailId, ref string attachmentId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="attachmentId"></param>
        /// <returns></returns>
        private void ValidateDownloadAttachmentBase64(string attachmentId)
        {
            if (attachmentId == null)
                throw new ArgumentNullException(nameof(attachmentId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="attachmentId"></param>
        private void AfterDownloadAttachmentBase64DefaultImplementation(IDownloadAttachmentBase64ApiResponse apiResponseLocalVar, Guid emailId, string attachmentId)
        {
            bool suppressDefaultLog = false;
            AfterDownloadAttachmentBase64(ref suppressDefaultLog, apiResponseLocalVar, emailId, attachmentId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="attachmentId"></param>
        partial void AfterDownloadAttachmentBase64(ref bool suppressDefaultLog, IDownloadAttachmentBase64ApiResponse apiResponseLocalVar, Guid emailId, string attachmentId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="attachmentId"></param>
        private void OnErrorDownloadAttachmentBase64DefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, string attachmentId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDownloadAttachmentBase64(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, attachmentId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="attachmentId"></param>
        partial void OnErrorDownloadAttachmentBase64(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, string attachmentId);

        /// <summary>
        /// Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;. Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </summary>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentBase64ApiResponse"/>&gt;</returns>
        public async Task<IDownloadAttachmentBase64ApiResponse> DownloadAttachmentBase64OrDefaultAsync(Guid emailId, string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DownloadAttachmentBase64Async(emailId, attachmentId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;. Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentBase64ApiResponse"/>&gt;</returns>
        public async Task<IDownloadAttachmentBase64ApiResponse> DownloadAttachmentBase64Async(Guid emailId, string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDownloadAttachmentBase64(attachmentId);

                FormatDownloadAttachmentBase64(ref emailId, ref attachmentId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/attachments/{attachmentId}/base64"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/attachments/{attachmentId}/base64");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BattachmentId%7D", Uri.EscapeDataString(attachmentId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DownloadAttachmentBase64ApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DownloadAttachmentBase64ApiResponse>();

                        DownloadAttachmentBase64ApiResponse apiResponseLocalVar = new DownloadAttachmentBase64ApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/attachments/{attachmentId}/base64", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDownloadAttachmentBase64DefaultImplementation(apiResponseLocalVar, emailId, attachmentId);

                        Events.ExecuteOnDownloadAttachmentBase64(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDownloadAttachmentBase64DefaultImplementation(e, "/emails/{emailId}/attachments/{attachmentId}/base64", uriBuilderLocalVar.Path, emailId, attachmentId);
                Events.ExecuteOnErrorDownloadAttachmentBase64(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DownloadAttachmentBase64ApiResponse"/>
        /// </summary>
        public partial class DownloadAttachmentBase64ApiResponse : mailslurp.Client.ApiResponse, IDownloadAttachmentBase64ApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DownloadAttachmentBase64ApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DownloadAttachmentBase64ApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DownloadAttachmentBase64ApiResponse(ILogger<DownloadAttachmentBase64ApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.DownloadAttachmentDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.DownloadAttachmentDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.DownloadAttachmentDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDownloadBody(ref Guid emailId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        private void AfterDownloadBodyDefaultImplementation(IDownloadBodyApiResponse apiResponseLocalVar, Guid emailId)
        {
            bool suppressDefaultLog = false;
            AfterDownloadBody(ref suppressDefaultLog, apiResponseLocalVar, emailId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        partial void AfterDownloadBody(ref bool suppressDefaultLog, IDownloadBodyApiResponse apiResponseLocalVar, Guid emailId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        private void OnErrorDownloadBodyDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDownloadBody(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        partial void OnErrorDownloadBody(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId);

        /// <summary>
        /// Get email body as string. Returned as &#x60;plain/text&#x60; with content type header. Returns the specified email body for a given email as a string
        /// </summary>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadBodyApiResponse"/>&gt;</returns>
        public async Task<IDownloadBodyApiResponse> DownloadBodyOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DownloadBodyAsync(emailId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email body as string. Returned as &#x60;plain/text&#x60; with content type header. Returns the specified email body for a given email as a string
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadBodyApiResponse"/>&gt;</returns>
        public async Task<IDownloadBodyApiResponse> DownloadBodyAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDownloadBody(ref emailId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/body"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/body");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/plain",
                        "text/html"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DownloadBodyApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DownloadBodyApiResponse>();

                        DownloadBodyApiResponse apiResponseLocalVar = new DownloadBodyApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/body", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDownloadBodyDefaultImplementation(apiResponseLocalVar, emailId);

                        Events.ExecuteOnDownloadBody(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDownloadBodyDefaultImplementation(e, "/emails/{emailId}/body", uriBuilderLocalVar.Path, emailId);
                Events.ExecuteOnErrorDownloadBody(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DownloadBodyApiResponse"/>
        /// </summary>
        public partial class DownloadBodyApiResponse : mailslurp.Client.ApiResponse, IDownloadBodyApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DownloadBodyApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DownloadBodyApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DownloadBodyApiResponse(ILogger<DownloadBodyApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public string Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<string>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out string result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDownloadBodyBytes(ref Guid emailId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        private void AfterDownloadBodyBytesDefaultImplementation(IDownloadBodyBytesApiResponse apiResponseLocalVar, Guid emailId)
        {
            bool suppressDefaultLog = false;
            AfterDownloadBodyBytes(ref suppressDefaultLog, apiResponseLocalVar, emailId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        partial void AfterDownloadBodyBytes(ref bool suppressDefaultLog, IDownloadBodyBytesApiResponse apiResponseLocalVar, Guid emailId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        private void OnErrorDownloadBodyBytesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDownloadBodyBytes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        partial void OnErrorDownloadBodyBytes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId);

        /// <summary>
        /// Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header. Returns the specified email body for a given email as a stream / array of bytes.
        /// </summary>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadBodyBytesApiResponse"/>&gt;</returns>
        public async Task<IDownloadBodyBytesApiResponse> DownloadBodyBytesOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DownloadBodyBytesAsync(emailId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header. Returns the specified email body for a given email as a stream / array of bytes.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadBodyBytesApiResponse"/>&gt;</returns>
        public async Task<IDownloadBodyBytesApiResponse> DownloadBodyBytesAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDownloadBodyBytes(ref emailId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/body-bytes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/body-bytes");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/octet-stream"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DownloadBodyBytesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DownloadBodyBytesApiResponse>();

                        DownloadBodyBytesApiResponse apiResponseLocalVar = new DownloadBodyBytesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/body-bytes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDownloadBodyBytesDefaultImplementation(apiResponseLocalVar, emailId);

                        Events.ExecuteOnDownloadBodyBytes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDownloadBodyBytesDefaultImplementation(e, "/emails/{emailId}/body-bytes", uriBuilderLocalVar.Path, emailId);
                Events.ExecuteOnErrorDownloadBodyBytes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DownloadBodyBytesApiResponse"/>
        /// </summary>
        public partial class DownloadBodyBytesApiResponse : mailslurp.Client.ApiResponse, IDownloadBodyBytesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DownloadBodyBytesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DownloadBodyBytesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DownloadBodyBytesApiResponse(ILogger<DownloadBodyBytesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => true;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public byte[] Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<byte[]>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault(out byte[] result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatForwardEmail(ref Guid emailId, ForwardEmailOptions forwardEmailOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="forwardEmailOptions"></param>
        /// <returns></returns>
        private void ValidateForwardEmail(ForwardEmailOptions forwardEmailOptions)
        {
            if (forwardEmailOptions == null)
                throw new ArgumentNullException(nameof(forwardEmailOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="forwardEmailOptions"></param>
        private void AfterForwardEmailDefaultImplementation(IForwardEmailApiResponse apiResponseLocalVar, Guid emailId, ForwardEmailOptions forwardEmailOptions)
        {
            bool suppressDefaultLog = false;
            AfterForwardEmail(ref suppressDefaultLog, apiResponseLocalVar, emailId, forwardEmailOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="forwardEmailOptions"></param>
        partial void AfterForwardEmail(ref bool suppressDefaultLog, IForwardEmailApiResponse apiResponseLocalVar, Guid emailId, ForwardEmailOptions forwardEmailOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="forwardEmailOptions"></param>
        private void OnErrorForwardEmailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, ForwardEmailOptions forwardEmailOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorForwardEmail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, forwardEmailOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="forwardEmailOptions"></param>
        partial void OnErrorForwardEmail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, ForwardEmailOptions forwardEmailOptions);

        /// <summary>
        /// Forward email to recipients Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the &#x60;from&#x60; option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
        /// </summary>
        /// <param name="emailId">ID of email</param>
        /// <param name="forwardEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IForwardEmailApiResponse"/>&gt;</returns>
        public async Task<IForwardEmailApiResponse> ForwardEmailOrDefaultAsync(Guid emailId, ForwardEmailOptions forwardEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ForwardEmailAsync(emailId, forwardEmailOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Forward email to recipients Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the &#x60;from&#x60; option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="forwardEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IForwardEmailApiResponse"/>&gt;</returns>
        public async Task<IForwardEmailApiResponse> ForwardEmailAsync(Guid emailId, ForwardEmailOptions forwardEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateForwardEmail(forwardEmailOptions);

                FormatForwardEmail(ref emailId, forwardEmailOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/forward"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/forward");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    httpRequestMessageLocalVar.Content = (forwardEmailOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(forwardEmailOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ForwardEmailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ForwardEmailApiResponse>();

                        ForwardEmailApiResponse apiResponseLocalVar = new ForwardEmailApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/forward", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterForwardEmailDefaultImplementation(apiResponseLocalVar, emailId, forwardEmailOptions);

                        Events.ExecuteOnForwardEmail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorForwardEmailDefaultImplementation(e, "/emails/{emailId}/forward", uriBuilderLocalVar.Path, emailId, forwardEmailOptions);
                Events.ExecuteOnErrorForwardEmail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ForwardEmailApiResponse"/>
        /// </summary>
        public partial class ForwardEmailApiResponse : mailslurp.Client.ApiResponse, IForwardEmailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ForwardEmailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ForwardEmailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ForwardEmailApiResponse(ILogger<ForwardEmailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.SentEmailDto Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.SentEmailDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out mailslurp.Model.SentEmailDto result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAttachmentMetaData(ref Guid emailId, ref string attachmentId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="attachmentId"></param>
        /// <returns></returns>
        private void ValidateGetAttachmentMetaData(string attachmentId)
        {
            if (attachmentId == null)
                throw new ArgumentNullException(nameof(attachmentId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="attachmentId"></param>
        private void AfterGetAttachmentMetaDataDefaultImplementation(IGetAttachmentMetaDataApiResponse apiResponseLocalVar, Guid emailId, string attachmentId)
        {
            bool suppressDefaultLog = false;
            AfterGetAttachmentMetaData(ref suppressDefaultLog, apiResponseLocalVar, emailId, attachmentId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="attachmentId"></param>
        partial void AfterGetAttachmentMetaData(ref bool suppressDefaultLog, IGetAttachmentMetaDataApiResponse apiResponseLocalVar, Guid emailId, string attachmentId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="attachmentId"></param>
        private void OnErrorGetAttachmentMetaDataDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, string attachmentId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAttachmentMetaData(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, attachmentId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="attachmentId"></param>
        partial void OnErrorGetAttachmentMetaData(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, string attachmentId);

        /// <summary>
        /// Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods. Returns the metadata such as name and content-type for a given attachment and email.
        /// </summary>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentMetaDataApiResponse"/>&gt;</returns>
        public async Task<IGetAttachmentMetaDataApiResponse> GetAttachmentMetaDataOrDefaultAsync(Guid emailId, string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAttachmentMetaDataAsync(emailId, attachmentId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods. Returns the metadata such as name and content-type for a given attachment and email.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentMetaDataApiResponse"/>&gt;</returns>
        public async Task<IGetAttachmentMetaDataApiResponse> GetAttachmentMetaDataAsync(Guid emailId, string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAttachmentMetaData(attachmentId);

                FormatGetAttachmentMetaData(ref emailId, ref attachmentId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/attachments/{attachmentId}/metadata"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/attachments/{attachmentId}/metadata");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BattachmentId%7D", Uri.EscapeDataString(attachmentId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetAttachmentMetaDataApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAttachmentMetaDataApiResponse>();

                        GetAttachmentMetaDataApiResponse apiResponseLocalVar = new GetAttachmentMetaDataApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/attachments/{attachmentId}/metadata", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAttachmentMetaDataDefaultImplementation(apiResponseLocalVar, emailId, attachmentId);

                        Events.ExecuteOnGetAttachmentMetaData(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAttachmentMetaDataDefaultImplementation(e, "/emails/{emailId}/attachments/{attachmentId}/metadata", uriBuilderLocalVar.Path, emailId, attachmentId);
                Events.ExecuteOnErrorGetAttachmentMetaData(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAttachmentMetaDataApiResponse"/>
        /// </summary>
        public partial class GetAttachmentMetaDataApiResponse : mailslurp.Client.ApiResponse, IGetAttachmentMetaDataApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAttachmentMetaDataApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAttachmentMetaDataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAttachmentMetaDataApiResponse(ILogger<GetAttachmentMetaDataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.AttachmentMetaData Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.AttachmentMetaData>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.AttachmentMetaData result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmail(ref Guid emailId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        private void AfterGetEmailDefaultImplementation(IGetEmailApiResponse apiResponseLocalVar, Guid emailId)
        {
            bool suppressDefaultLog = false;
            AfterGetEmail(ref suppressDefaultLog, apiResponseLocalVar, emailId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        partial void AfterGetEmail(ref bool suppressDefaultLog, IGetEmailApiResponse apiResponseLocalVar, Guid emailId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        private void OnErrorGetEmailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        partial void OnErrorGetEmail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId);

        /// <summary>
        /// Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController. Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
        /// </summary>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailApiResponse"/>&gt;</returns>
        public async Task<IGetEmailApiResponse> GetEmailOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailAsync(emailId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController. Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailApiResponse"/>&gt;</returns>
        public async Task<IGetEmailApiResponse> GetEmailAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetEmail(ref emailId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json;charset=UTF-8",
                        "application/xml;charset=UTF-8",
                        "application/json; charset=UTF-8",
                        "application/xml; charset=UTF-8"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailApiResponse>();

                        GetEmailApiResponse apiResponseLocalVar = new GetEmailApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailDefaultImplementation(apiResponseLocalVar, emailId);

                        Events.ExecuteOnGetEmail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailDefaultImplementation(e, "/emails/{emailId}", uriBuilderLocalVar.Path, emailId);
                Events.ExecuteOnErrorGetEmail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailApiResponse"/>
        /// </summary>
        public partial class GetEmailApiResponse : mailslurp.Client.ApiResponse, IGetEmailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailApiResponse(ILogger<GetEmailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.Email Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.Email>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.Email result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailAttachments(ref Guid emailId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        private void AfterGetEmailAttachmentsDefaultImplementation(IGetEmailAttachmentsApiResponse apiResponseLocalVar, Guid emailId)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailAttachments(ref suppressDefaultLog, apiResponseLocalVar, emailId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        partial void AfterGetEmailAttachments(ref bool suppressDefaultLog, IGetEmailAttachmentsApiResponse apiResponseLocalVar, Guid emailId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        private void OnErrorGetEmailAttachmentsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailAttachments(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        partial void OnErrorGetEmailAttachments(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId);

        /// <summary>
        /// Get all email attachment metadata. Metadata includes name and size of attachments. Returns an array of attachment metadata such as name and content-type for a given email if present.
        /// </summary>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailAttachmentsApiResponse"/>&gt;</returns>
        public async Task<IGetEmailAttachmentsApiResponse> GetEmailAttachmentsOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailAttachmentsAsync(emailId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all email attachment metadata. Metadata includes name and size of attachments. Returns an array of attachment metadata such as name and content-type for a given email if present.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailAttachmentsApiResponse"/>&gt;</returns>
        public async Task<IGetEmailAttachmentsApiResponse> GetEmailAttachmentsAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetEmailAttachments(ref emailId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/attachments"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/attachments");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailAttachmentsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailAttachmentsApiResponse>();

                        GetEmailAttachmentsApiResponse apiResponseLocalVar = new GetEmailAttachmentsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/attachments", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailAttachmentsDefaultImplementation(apiResponseLocalVar, emailId);

                        Events.ExecuteOnGetEmailAttachments(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailAttachmentsDefaultImplementation(e, "/emails/{emailId}/attachments", uriBuilderLocalVar.Path, emailId);
                Events.ExecuteOnErrorGetEmailAttachments(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailAttachmentsApiResponse"/>
        /// </summary>
        public partial class GetEmailAttachmentsApiResponse : mailslurp.Client.ApiResponse, IGetEmailAttachmentsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailAttachmentsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailAttachmentsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailAttachmentsApiResponse(ILogger<GetEmailAttachmentsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<AttachmentMetaData> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<AttachmentMetaData>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out List<AttachmentMetaData> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailContentMatch(ref Guid emailId, ContentMatchOptions contentMatchOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="contentMatchOptions"></param>
        /// <returns></returns>
        private void ValidateGetEmailContentMatch(ContentMatchOptions contentMatchOptions)
        {
            if (contentMatchOptions == null)
                throw new ArgumentNullException(nameof(contentMatchOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="contentMatchOptions"></param>
        private void AfterGetEmailContentMatchDefaultImplementation(IGetEmailContentMatchApiResponse apiResponseLocalVar, Guid emailId, ContentMatchOptions contentMatchOptions)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailContentMatch(ref suppressDefaultLog, apiResponseLocalVar, emailId, contentMatchOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="contentMatchOptions"></param>
        partial void AfterGetEmailContentMatch(ref bool suppressDefaultLog, IGetEmailContentMatchApiResponse apiResponseLocalVar, Guid emailId, ContentMatchOptions contentMatchOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="contentMatchOptions"></param>
        private void OnErrorGetEmailContentMatchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, ContentMatchOptions contentMatchOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailContentMatch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, contentMatchOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="contentMatchOptions"></param>
        partial void OnErrorGetEmailContentMatch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, ContentMatchOptions contentMatchOptions);

        /// <summary>
        /// Get email content regex pattern match results. Runs regex against email body and returns match groups. Return the matches for a given Java style regex pattern. Do not include the typical &#x60;/&#x60; at start or end of regex in some languages. Given an example &#x60;your code is: 12345&#x60; the pattern to extract match looks like &#x60;code is: (\\d{6})&#x60;. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: &#x60;[&#39;code is: 123456&#39;, &#39;123456&#39;]&#x60; See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
        /// </summary>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentMatchOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailContentMatchApiResponse"/>&gt;</returns>
        public async Task<IGetEmailContentMatchApiResponse> GetEmailContentMatchOrDefaultAsync(Guid emailId, ContentMatchOptions contentMatchOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailContentMatchAsync(emailId, contentMatchOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email content regex pattern match results. Runs regex against email body and returns match groups. Return the matches for a given Java style regex pattern. Do not include the typical &#x60;/&#x60; at start or end of regex in some languages. Given an example &#x60;your code is: 12345&#x60; the pattern to extract match looks like &#x60;code is: (\\d{6})&#x60;. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: &#x60;[&#39;code is: 123456&#39;, &#39;123456&#39;]&#x60; See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentMatchOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailContentMatchApiResponse"/>&gt;</returns>
        public async Task<IGetEmailContentMatchApiResponse> GetEmailContentMatchAsync(Guid emailId, ContentMatchOptions contentMatchOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailContentMatch(contentMatchOptions);

                FormatGetEmailContentMatch(ref emailId, contentMatchOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/contentMatch"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/contentMatch");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    httpRequestMessageLocalVar.Content = (contentMatchOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(contentMatchOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailContentMatchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailContentMatchApiResponse>();

                        GetEmailContentMatchApiResponse apiResponseLocalVar = new GetEmailContentMatchApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/contentMatch", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailContentMatchDefaultImplementation(apiResponseLocalVar, emailId, contentMatchOptions);

                        Events.ExecuteOnGetEmailContentMatch(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailContentMatchDefaultImplementation(e, "/emails/{emailId}/contentMatch", uriBuilderLocalVar.Path, emailId, contentMatchOptions);
                Events.ExecuteOnErrorGetEmailContentMatch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailContentMatchApiResponse"/>
        /// </summary>
        public partial class GetEmailContentMatchApiResponse : mailslurp.Client.ApiResponse, IGetEmailContentMatchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailContentMatchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailContentMatchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailContentMatchApiResponse(ILogger<GetEmailContentMatchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailContentMatchResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailContentMatchResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailContentMatchResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailContentPart(ref Guid emailId, ref string contentType, ref Option<bool> strict, ref Option<int> index);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="contentType"></param>
        /// <returns></returns>
        private void ValidateGetEmailContentPart(string contentType)
        {
            if (contentType == null)
                throw new ArgumentNullException(nameof(contentType));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="contentType"></param>
        /// <param name="strict"></param>
        /// <param name="index"></param>
        private void AfterGetEmailContentPartDefaultImplementation(IGetEmailContentPartApiResponse apiResponseLocalVar, Guid emailId, string contentType, Option<bool> strict, Option<int> index)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailContentPart(ref suppressDefaultLog, apiResponseLocalVar, emailId, contentType, strict, index);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="contentType"></param>
        /// <param name="strict"></param>
        /// <param name="index"></param>
        partial void AfterGetEmailContentPart(ref bool suppressDefaultLog, IGetEmailContentPartApiResponse apiResponseLocalVar, Guid emailId, string contentType, Option<bool> strict, Option<int> index);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="contentType"></param>
        /// <param name="strict"></param>
        /// <param name="index"></param>
        private void OnErrorGetEmailContentPartDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, string contentType, Option<bool> strict, Option<int> index)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailContentPart(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, contentType, strict, index);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="contentType"></param>
        /// <param name="strict"></param>
        /// <param name="index"></param>
        partial void OnErrorGetEmailContentPart(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, string contentType, Option<bool> strict, Option<int> index);

        /// <summary>
        /// Get email content part by content type Get email body content parts from a multipart email message for a given content type
        /// </summary>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailContentPartApiResponse"/>&gt;</returns>
        public async Task<IGetEmailContentPartApiResponse> GetEmailContentPartOrDefaultAsync(Guid emailId, string contentType, Option<bool> strict = default, Option<int> index = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailContentPartAsync(emailId, contentType, strict, index, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email content part by content type Get email body content parts from a multipart email message for a given content type
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailContentPartApiResponse"/>&gt;</returns>
        public async Task<IGetEmailContentPartApiResponse> GetEmailContentPartAsync(Guid emailId, string contentType, Option<bool> strict = default, Option<int> index = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailContentPart(contentType);

                FormatGetEmailContentPart(ref emailId, ref contentType, ref strict, ref index);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/contentPart"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/contentPart");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["contentType"] = ClientUtils.ParameterToString(contentType);

                    if (strict.IsSet)
                        parseQueryStringLocalVar["strict"] = ClientUtils.ParameterToString(strict.Value);

                    if (index.IsSet)
                        parseQueryStringLocalVar["index"] = ClientUtils.ParameterToString(index.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json;charset=UTF-8",
                        "application/xml;charset=UTF-8",
                        "application/json; charset=UTF-8",
                        "application/xml; charset=UTF-8"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailContentPartApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailContentPartApiResponse>();

                        GetEmailContentPartApiResponse apiResponseLocalVar = new GetEmailContentPartApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/contentPart", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailContentPartDefaultImplementation(apiResponseLocalVar, emailId, contentType, strict, index);

                        Events.ExecuteOnGetEmailContentPart(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailContentPartDefaultImplementation(e, "/emails/{emailId}/contentPart", uriBuilderLocalVar.Path, emailId, contentType, strict, index);
                Events.ExecuteOnErrorGetEmailContentPart(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailContentPartApiResponse"/>
        /// </summary>
        public partial class GetEmailContentPartApiResponse : mailslurp.Client.ApiResponse, IGetEmailContentPartApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailContentPartApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailContentPartApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailContentPartApiResponse(ILogger<GetEmailContentPartApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailContentPartResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailContentPartResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailContentPartResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailContentPartContent(ref Guid emailId, ref string contentType, ref Option<bool> strict, ref Option<int> index);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="contentType"></param>
        /// <returns></returns>
        private void ValidateGetEmailContentPartContent(string contentType)
        {
            if (contentType == null)
                throw new ArgumentNullException(nameof(contentType));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="contentType"></param>
        /// <param name="strict"></param>
        /// <param name="index"></param>
        private void AfterGetEmailContentPartContentDefaultImplementation(IGetEmailContentPartContentApiResponse apiResponseLocalVar, Guid emailId, string contentType, Option<bool> strict, Option<int> index)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailContentPartContent(ref suppressDefaultLog, apiResponseLocalVar, emailId, contentType, strict, index);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="contentType"></param>
        /// <param name="strict"></param>
        /// <param name="index"></param>
        partial void AfterGetEmailContentPartContent(ref bool suppressDefaultLog, IGetEmailContentPartContentApiResponse apiResponseLocalVar, Guid emailId, string contentType, Option<bool> strict, Option<int> index);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="contentType"></param>
        /// <param name="strict"></param>
        /// <param name="index"></param>
        private void OnErrorGetEmailContentPartContentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, string contentType, Option<bool> strict, Option<int> index)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailContentPartContent(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, contentType, strict, index);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="contentType"></param>
        /// <param name="strict"></param>
        /// <param name="index"></param>
        partial void OnErrorGetEmailContentPartContent(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, string contentType, Option<bool> strict, Option<int> index);

        /// <summary>
        /// Get email content part by content type raw response Get email body content parts from a multipart email message for a given content type and return as response
        /// </summary>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple. Starts from 0 and applies to the result list after selecting for your content type. Content type parts are sorted by order found in original MIME message. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailContentPartContentApiResponse"/>&gt;</returns>
        public async Task<IGetEmailContentPartContentApiResponse> GetEmailContentPartContentOrDefaultAsync(Guid emailId, string contentType, Option<bool> strict = default, Option<int> index = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailContentPartContentAsync(emailId, contentType, strict, index, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email content part by content type raw response Get email body content parts from a multipart email message for a given content type and return as response
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple. Starts from 0 and applies to the result list after selecting for your content type. Content type parts are sorted by order found in original MIME message. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailContentPartContentApiResponse"/>&gt;</returns>
        public async Task<IGetEmailContentPartContentApiResponse> GetEmailContentPartContentAsync(Guid emailId, string contentType, Option<bool> strict = default, Option<int> index = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailContentPartContent(contentType);

                FormatGetEmailContentPartContent(ref emailId, ref contentType, ref strict, ref index);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/contentPart/raw"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/contentPart/raw");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["contentType"] = ClientUtils.ParameterToString(contentType);

                    if (strict.IsSet)
                        parseQueryStringLocalVar["strict"] = ClientUtils.ParameterToString(strict.Value);

                    if (index.IsSet)
                        parseQueryStringLocalVar["index"] = ClientUtils.ParameterToString(index.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailContentPartContentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailContentPartContentApiResponse>();

                        GetEmailContentPartContentApiResponse apiResponseLocalVar = new GetEmailContentPartContentApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/contentPart/raw", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailContentPartContentDefaultImplementation(apiResponseLocalVar, emailId, contentType, strict, index);

                        Events.ExecuteOnGetEmailContentPartContent(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailContentPartContentDefaultImplementation(e, "/emails/{emailId}/contentPart/raw", uriBuilderLocalVar.Path, emailId, contentType, strict, index);
                Events.ExecuteOnErrorGetEmailContentPartContent(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailContentPartContentApiResponse"/>
        /// </summary>
        public partial class GetEmailContentPartContentApiResponse : mailslurp.Client.ApiResponse, IGetEmailContentPartContentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailContentPartContentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailContentPartContentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailContentPartContentApiResponse(ILogger<GetEmailContentPartContentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public string Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<string>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out string result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailCount(ref Option<Guid> inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterGetEmailCountDefaultImplementation(IGetEmailCountApiResponse apiResponseLocalVar, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailCount(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetEmailCount(ref bool suppressDefaultLog, IGetEmailCountApiResponse apiResponseLocalVar, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetEmailCountDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailCount(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetEmailCount(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId);

        /// <summary>
        /// Get email count 
        /// </summary>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailCountApiResponse"/>&gt;</returns>
        public async Task<IGetEmailCountApiResponse> GetEmailCountOrDefaultAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailCountAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email count 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailCountApiResponse"/>&gt;</returns>
        public async Task<IGetEmailCountApiResponse> GetEmailCountAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetEmailCount(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/emails/count"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/emails/count");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailCountApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailCountApiResponse>();

                        GetEmailCountApiResponse apiResponseLocalVar = new GetEmailCountApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/emails/count", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailCountDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnGetEmailCount(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailCountDefaultImplementation(e, "/emails/emails/count", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorGetEmailCount(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailCountApiResponse"/>
        /// </summary>
        public partial class GetEmailCountApiResponse : mailslurp.Client.ApiResponse, IGetEmailCountApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailCountApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailCountApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailCountApiResponse(ILogger<GetEmailCountApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.CountDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.CountDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.CountDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailHTML(ref Guid emailId, ref Option<bool> replaceCidImages);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"></param>
        private void AfterGetEmailHTMLDefaultImplementation(IGetEmailHTMLApiResponse apiResponseLocalVar, Guid emailId, Option<bool> replaceCidImages)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailHTML(ref suppressDefaultLog, apiResponseLocalVar, emailId, replaceCidImages);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"></param>
        partial void AfterGetEmailHTML(ref bool suppressDefaultLog, IGetEmailHTMLApiResponse apiResponseLocalVar, Guid emailId, Option<bool> replaceCidImages);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"></param>
        private void OnErrorGetEmailHTMLDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<bool> replaceCidImages)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailHTML(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, replaceCidImages);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"></param>
        partial void OnErrorGetEmailHTML(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<bool> replaceCidImages);

        /// <summary>
        /// Get email content as HTML. For displaying emails in browser context. Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: &#x60;?apiKey&#x3D;xxx&#x60;. Returns content-type &#x60;text/html;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON. For JSON response see the &#x60;getEmailHTMLJson&#x60; method.
        /// </summary>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailHTMLApiResponse"/>&gt;</returns>
        public async Task<IGetEmailHTMLApiResponse> GetEmailHTMLOrDefaultAsync(Guid emailId, Option<bool> replaceCidImages = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailHTMLAsync(emailId, replaceCidImages, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email content as HTML. For displaying emails in browser context. Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: &#x60;?apiKey&#x3D;xxx&#x60;. Returns content-type &#x60;text/html;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON. For JSON response see the &#x60;getEmailHTMLJson&#x60; method.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailHTMLApiResponse"/>&gt;</returns>
        public async Task<IGetEmailHTMLApiResponse> GetEmailHTMLAsync(Guid emailId, Option<bool> replaceCidImages = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetEmailHTML(ref emailId, ref replaceCidImages);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/html"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/html");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (replaceCidImages.IsSet)
                        parseQueryStringLocalVar["replaceCidImages"] = ClientUtils.ParameterToString(replaceCidImages.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/html;charset=utf-8",
                        "text/html"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailHTMLApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailHTMLApiResponse>();

                        GetEmailHTMLApiResponse apiResponseLocalVar = new GetEmailHTMLApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/html", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailHTMLDefaultImplementation(apiResponseLocalVar, emailId, replaceCidImages);

                        Events.ExecuteOnGetEmailHTML(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailHTMLDefaultImplementation(e, "/emails/{emailId}/html", uriBuilderLocalVar.Path, emailId, replaceCidImages);
                Events.ExecuteOnErrorGetEmailHTML(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailHTMLApiResponse"/>
        /// </summary>
        public partial class GetEmailHTMLApiResponse : mailslurp.Client.ApiResponse, IGetEmailHTMLApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailHTMLApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailHTMLApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailHTMLApiResponse(ILogger<GetEmailHTMLApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public string Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<string>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out string result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailHTMLJson(ref Guid emailId, ref Option<bool> replaceCidImages);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"></param>
        private void AfterGetEmailHTMLJsonDefaultImplementation(IGetEmailHTMLJsonApiResponse apiResponseLocalVar, Guid emailId, Option<bool> replaceCidImages)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailHTMLJson(ref suppressDefaultLog, apiResponseLocalVar, emailId, replaceCidImages);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"></param>
        partial void AfterGetEmailHTMLJson(ref bool suppressDefaultLog, IGetEmailHTMLJsonApiResponse apiResponseLocalVar, Guid emailId, Option<bool> replaceCidImages);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"></param>
        private void OnErrorGetEmailHTMLJsonDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<bool> replaceCidImages)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailHTMLJson(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, replaceCidImages);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"></param>
        partial void OnErrorGetEmailHTMLJson(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<bool> replaceCidImages);

        /// <summary>
        /// Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content Retrieve email content as HTML response. Decodes quoted-printable entities and converts charset to UTF-8. Returns content-type &#x60;application/json;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON.
        /// </summary>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailHTMLJsonApiResponse"/>&gt;</returns>
        public async Task<IGetEmailHTMLJsonApiResponse> GetEmailHTMLJsonOrDefaultAsync(Guid emailId, Option<bool> replaceCidImages = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailHTMLJsonAsync(emailId, replaceCidImages, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content Retrieve email content as HTML response. Decodes quoted-printable entities and converts charset to UTF-8. Returns content-type &#x60;application/json;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailHTMLJsonApiResponse"/>&gt;</returns>
        public async Task<IGetEmailHTMLJsonApiResponse> GetEmailHTMLJsonAsync(Guid emailId, Option<bool> replaceCidImages = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetEmailHTMLJson(ref emailId, ref replaceCidImages);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/html/json"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/html/json");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (replaceCidImages.IsSet)
                        parseQueryStringLocalVar["replaceCidImages"] = ClientUtils.ParameterToString(replaceCidImages.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailHTMLJsonApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailHTMLJsonApiResponse>();

                        GetEmailHTMLJsonApiResponse apiResponseLocalVar = new GetEmailHTMLJsonApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/html/json", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailHTMLJsonDefaultImplementation(apiResponseLocalVar, emailId, replaceCidImages);

                        Events.ExecuteOnGetEmailHTMLJson(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailHTMLJsonDefaultImplementation(e, "/emails/{emailId}/html/json", uriBuilderLocalVar.Path, emailId, replaceCidImages);
                Events.ExecuteOnErrorGetEmailHTMLJson(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailHTMLJsonApiResponse"/>
        /// </summary>
        public partial class GetEmailHTMLJsonApiResponse : mailslurp.Client.ApiResponse, IGetEmailHTMLJsonApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailHTMLJsonApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailHTMLJsonApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailHTMLJsonApiResponse(ILogger<GetEmailHTMLJsonApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailHtmlDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailHtmlDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailHtmlDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailHTMLQuery(ref Guid emailId, ref string htmlSelector);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="htmlSelector"></param>
        /// <returns></returns>
        private void ValidateGetEmailHTMLQuery(string htmlSelector)
        {
            if (htmlSelector == null)
                throw new ArgumentNullException(nameof(htmlSelector));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="htmlSelector"></param>
        private void AfterGetEmailHTMLQueryDefaultImplementation(IGetEmailHTMLQueryApiResponse apiResponseLocalVar, Guid emailId, string htmlSelector)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailHTMLQuery(ref suppressDefaultLog, apiResponseLocalVar, emailId, htmlSelector);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="htmlSelector"></param>
        partial void AfterGetEmailHTMLQuery(ref bool suppressDefaultLog, IGetEmailHTMLQueryApiResponse apiResponseLocalVar, Guid emailId, string htmlSelector);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="htmlSelector"></param>
        private void OnErrorGetEmailHTMLQueryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, string htmlSelector)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailHTMLQuery(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, htmlSelector);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="htmlSelector"></param>
        partial void OnErrorGetEmailHTMLQuery(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, string htmlSelector);

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
        /// </summary>
        /// <param name="emailId">ID of email to perform HTML query on</param>
        /// <param name="htmlSelector">HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailHTMLQueryApiResponse"/>&gt;</returns>
        public async Task<IGetEmailHTMLQueryApiResponse> GetEmailHTMLQueryOrDefaultAsync(Guid emailId, string htmlSelector, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailHTMLQueryAsync(emailId, htmlSelector, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to perform HTML query on</param>
        /// <param name="htmlSelector">HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailHTMLQueryApiResponse"/>&gt;</returns>
        public async Task<IGetEmailHTMLQueryApiResponse> GetEmailHTMLQueryAsync(Guid emailId, string htmlSelector, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailHTMLQuery(htmlSelector);

                FormatGetEmailHTMLQuery(ref emailId, ref htmlSelector);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/htmlQuery"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/htmlQuery");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["htmlSelector"] = ClientUtils.ParameterToString(htmlSelector);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailHTMLQueryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailHTMLQueryApiResponse>();

                        GetEmailHTMLQueryApiResponse apiResponseLocalVar = new GetEmailHTMLQueryApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/htmlQuery", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailHTMLQueryDefaultImplementation(apiResponseLocalVar, emailId, htmlSelector);

                        Events.ExecuteOnGetEmailHTMLQuery(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailHTMLQueryDefaultImplementation(e, "/emails/{emailId}/htmlQuery", uriBuilderLocalVar.Path, emailId, htmlSelector);
                Events.ExecuteOnErrorGetEmailHTMLQuery(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailHTMLQueryApiResponse"/>
        /// </summary>
        public partial class GetEmailHTMLQueryApiResponse : mailslurp.Client.ApiResponse, IGetEmailHTMLQueryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailHTMLQueryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailHTMLQueryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailHTMLQueryApiResponse(ILogger<GetEmailHTMLQueryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailTextLinesResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailTextLinesResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailTextLinesResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailLinks(ref Guid emailId, ref Option<string> selector);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="selector"></param>
        /// <returns></returns>
        private void ValidateGetEmailLinks(Option<string> selector)
        {
            if (selector.IsSet && selector.Value == null)
                throw new ArgumentNullException(nameof(selector));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="selector"></param>
        private void AfterGetEmailLinksDefaultImplementation(IGetEmailLinksApiResponse apiResponseLocalVar, Guid emailId, Option<string> selector)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailLinks(ref suppressDefaultLog, apiResponseLocalVar, emailId, selector);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="selector"></param>
        partial void AfterGetEmailLinks(ref bool suppressDefaultLog, IGetEmailLinksApiResponse apiResponseLocalVar, Guid emailId, Option<string> selector);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="selector"></param>
        private void OnErrorGetEmailLinksDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<string> selector)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailLinks(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, selector);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="selector"></param>
        partial void OnErrorGetEmailLinks(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<string> selector);

        /// <summary>
        /// Parse and return list of links found in an email (only works for HTML content) HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes
        /// </summary>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="selector">Optional HTML query selector for links (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailLinksApiResponse"/>&gt;</returns>
        public async Task<IGetEmailLinksApiResponse> GetEmailLinksOrDefaultAsync(Guid emailId, Option<string> selector = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailLinksAsync(emailId, selector, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Parse and return list of links found in an email (only works for HTML content) HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="selector">Optional HTML query selector for links (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailLinksApiResponse"/>&gt;</returns>
        public async Task<IGetEmailLinksApiResponse> GetEmailLinksAsync(Guid emailId, Option<string> selector = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailLinks(selector);

                FormatGetEmailLinks(ref emailId, ref selector);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/links"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/links");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (selector.IsSet)
                        parseQueryStringLocalVar["selector"] = ClientUtils.ParameterToString(selector.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailLinksApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailLinksApiResponse>();

                        GetEmailLinksApiResponse apiResponseLocalVar = new GetEmailLinksApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/links", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailLinksDefaultImplementation(apiResponseLocalVar, emailId, selector);

                        Events.ExecuteOnGetEmailLinks(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailLinksDefaultImplementation(e, "/emails/{emailId}/links", uriBuilderLocalVar.Path, emailId, selector);
                Events.ExecuteOnErrorGetEmailLinks(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailLinksApiResponse"/>
        /// </summary>
        public partial class GetEmailLinksApiResponse : mailslurp.Client.ApiResponse, IGetEmailLinksApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailLinksApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailLinksApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailLinksApiResponse(ILogger<GetEmailLinksApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailLinksResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailLinksResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailLinksResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailPreviewURLs(ref Guid emailId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        private void AfterGetEmailPreviewURLsDefaultImplementation(IGetEmailPreviewURLsApiResponse apiResponseLocalVar, Guid emailId)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailPreviewURLs(ref suppressDefaultLog, apiResponseLocalVar, emailId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        partial void AfterGetEmailPreviewURLs(ref bool suppressDefaultLog, IGetEmailPreviewURLsApiResponse apiResponseLocalVar, Guid emailId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        private void OnErrorGetEmailPreviewURLsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailPreviewURLs(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        partial void OnErrorGetEmailPreviewURLs(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId);

        /// <summary>
        /// Get email URLs for viewing in browser or downloading Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.
        /// </summary>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailPreviewURLsApiResponse"/>&gt;</returns>
        public async Task<IGetEmailPreviewURLsApiResponse> GetEmailPreviewURLsOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailPreviewURLsAsync(emailId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email URLs for viewing in browser or downloading Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailPreviewURLsApiResponse"/>&gt;</returns>
        public async Task<IGetEmailPreviewURLsApiResponse> GetEmailPreviewURLsAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetEmailPreviewURLs(ref emailId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/urls"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/urls");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailPreviewURLsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailPreviewURLsApiResponse>();

                        GetEmailPreviewURLsApiResponse apiResponseLocalVar = new GetEmailPreviewURLsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/urls", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailPreviewURLsDefaultImplementation(apiResponseLocalVar, emailId);

                        Events.ExecuteOnGetEmailPreviewURLs(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailPreviewURLsDefaultImplementation(e, "/emails/{emailId}/urls", uriBuilderLocalVar.Path, emailId);
                Events.ExecuteOnErrorGetEmailPreviewURLs(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailPreviewURLsApiResponse"/>
        /// </summary>
        public partial class GetEmailPreviewURLsApiResponse : mailslurp.Client.ApiResponse, IGetEmailPreviewURLsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailPreviewURLsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailPreviewURLsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailPreviewURLsApiResponse(ILogger<GetEmailPreviewURLsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailPreviewUrls Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailPreviewUrls>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailPreviewUrls result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailScreenshotAsBase64(ref Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <returns></returns>
        private void ValidateGetEmailScreenshotAsBase64(GetEmailScreenshotOptions getEmailScreenshotOptions)
        {
            if (getEmailScreenshotOptions == null)
                throw new ArgumentNullException(nameof(getEmailScreenshotOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        private void AfterGetEmailScreenshotAsBase64DefaultImplementation(IGetEmailScreenshotAsBase64ApiResponse apiResponseLocalVar, Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailScreenshotAsBase64(ref suppressDefaultLog, apiResponseLocalVar, emailId, getEmailScreenshotOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        partial void AfterGetEmailScreenshotAsBase64(ref bool suppressDefaultLog, IGetEmailScreenshotAsBase64ApiResponse apiResponseLocalVar, Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        private void OnErrorGetEmailScreenshotAsBase64DefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailScreenshotAsBase64(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, getEmailScreenshotOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        partial void OnErrorGetEmailScreenshotAsBase64(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions);

        /// <summary>
        /// Take a screenshot of an email in a browser and return base64 encoded string Capture image of email screenshot and return as base64 encoded string. Useful for embedding in HTML. Be careful as this may contain sensitive information.
        /// </summary>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailScreenshotAsBase64ApiResponse"/>&gt;</returns>
        public async Task<IGetEmailScreenshotAsBase64ApiResponse> GetEmailScreenshotAsBase64OrDefaultAsync(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailScreenshotAsBase64Async(emailId, getEmailScreenshotOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Take a screenshot of an email in a browser and return base64 encoded string Capture image of email screenshot and return as base64 encoded string. Useful for embedding in HTML. Be careful as this may contain sensitive information.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailScreenshotAsBase64ApiResponse"/>&gt;</returns>
        public async Task<IGetEmailScreenshotAsBase64ApiResponse> GetEmailScreenshotAsBase64Async(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailScreenshotAsBase64(getEmailScreenshotOptions);

                FormatGetEmailScreenshotAsBase64(ref emailId, getEmailScreenshotOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/screenshot/base64"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/screenshot/base64");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    httpRequestMessageLocalVar.Content = (getEmailScreenshotOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(getEmailScreenshotOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailScreenshotAsBase64ApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailScreenshotAsBase64ApiResponse>();

                        GetEmailScreenshotAsBase64ApiResponse apiResponseLocalVar = new GetEmailScreenshotAsBase64ApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/screenshot/base64", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailScreenshotAsBase64DefaultImplementation(apiResponseLocalVar, emailId, getEmailScreenshotOptions);

                        Events.ExecuteOnGetEmailScreenshotAsBase64(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailScreenshotAsBase64DefaultImplementation(e, "/emails/{emailId}/screenshot/base64", uriBuilderLocalVar.Path, emailId, getEmailScreenshotOptions);
                Events.ExecuteOnErrorGetEmailScreenshotAsBase64(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailScreenshotAsBase64ApiResponse"/>
        /// </summary>
        public partial class GetEmailScreenshotAsBase64ApiResponse : mailslurp.Client.ApiResponse, IGetEmailScreenshotAsBase64ApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailScreenshotAsBase64ApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailScreenshotAsBase64ApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailScreenshotAsBase64ApiResponse(ILogger<GetEmailScreenshotAsBase64ApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailScreenshotResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailScreenshotResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailScreenshotResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailScreenshotAsBinary(ref Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <returns></returns>
        private void ValidateGetEmailScreenshotAsBinary(GetEmailScreenshotOptions getEmailScreenshotOptions)
        {
            if (getEmailScreenshotOptions == null)
                throw new ArgumentNullException(nameof(getEmailScreenshotOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        private void AfterGetEmailScreenshotAsBinaryDefaultImplementation(IGetEmailScreenshotAsBinaryApiResponse apiResponseLocalVar, Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailScreenshotAsBinary(ref suppressDefaultLog, apiResponseLocalVar, emailId, getEmailScreenshotOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        partial void AfterGetEmailScreenshotAsBinary(ref bool suppressDefaultLog, IGetEmailScreenshotAsBinaryApiResponse apiResponseLocalVar, Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        private void OnErrorGetEmailScreenshotAsBinaryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailScreenshotAsBinary(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, getEmailScreenshotOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        partial void OnErrorGetEmailScreenshotAsBinary(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions);

        /// <summary>
        /// Take a screenshot of an email in a browser Returns binary octet-stream of screenshot of the given email
        /// </summary>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailScreenshotAsBinaryApiResponse"/>&gt;</returns>
        public async Task<IGetEmailScreenshotAsBinaryApiResponse> GetEmailScreenshotAsBinaryOrDefaultAsync(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailScreenshotAsBinaryAsync(emailId, getEmailScreenshotOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Take a screenshot of an email in a browser Returns binary octet-stream of screenshot of the given email
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailScreenshotAsBinaryApiResponse"/>&gt;</returns>
        public async Task<IGetEmailScreenshotAsBinaryApiResponse> GetEmailScreenshotAsBinaryAsync(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailScreenshotAsBinary(getEmailScreenshotOptions);

                FormatGetEmailScreenshotAsBinary(ref emailId, getEmailScreenshotOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/screenshot/binary"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/screenshot/binary");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    httpRequestMessageLocalVar.Content = (getEmailScreenshotOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(getEmailScreenshotOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailScreenshotAsBinaryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailScreenshotAsBinaryApiResponse>();

                        GetEmailScreenshotAsBinaryApiResponse apiResponseLocalVar = new GetEmailScreenshotAsBinaryApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/screenshot/binary", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailScreenshotAsBinaryDefaultImplementation(apiResponseLocalVar, emailId, getEmailScreenshotOptions);

                        Events.ExecuteOnGetEmailScreenshotAsBinary(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailScreenshotAsBinaryDefaultImplementation(e, "/emails/{emailId}/screenshot/binary", uriBuilderLocalVar.Path, emailId, getEmailScreenshotOptions);
                Events.ExecuteOnErrorGetEmailScreenshotAsBinary(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailScreenshotAsBinaryApiResponse"/>
        /// </summary>
        public partial class GetEmailScreenshotAsBinaryApiResponse : mailslurp.Client.ApiResponse, IGetEmailScreenshotAsBinaryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailScreenshotAsBinaryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailScreenshotAsBinaryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailScreenshotAsBinaryApiResponse(ILogger<GetEmailScreenshotAsBinaryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailSummary(ref Guid emailId, ref Option<bool> decode);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="decode"></param>
        private void AfterGetEmailSummaryDefaultImplementation(IGetEmailSummaryApiResponse apiResponseLocalVar, Guid emailId, Option<bool> decode)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailSummary(ref suppressDefaultLog, apiResponseLocalVar, emailId, decode);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="decode"></param>
        partial void AfterGetEmailSummary(ref bool suppressDefaultLog, IGetEmailSummaryApiResponse apiResponseLocalVar, Guid emailId, Option<bool> decode);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="decode"></param>
        private void OnErrorGetEmailSummaryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<bool> decode)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailSummary(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, decode);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="decode"></param>
        partial void OnErrorGetEmailSummary(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<bool> decode);

        /// <summary>
        /// Get email data including headers but not body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController. Returns a email summary object with headers. To retrieve the body see getEmail and to get raw unparsed email use the getRawEmail endpoints
        /// </summary>
        /// <param name="emailId"></param>
        /// <param name="decode"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailSummaryApiResponse"/>&gt;</returns>
        public async Task<IGetEmailSummaryApiResponse> GetEmailSummaryOrDefaultAsync(Guid emailId, Option<bool> decode = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailSummaryAsync(emailId, decode, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email data including headers but not body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController. Returns a email summary object with headers. To retrieve the body see getEmail and to get raw unparsed email use the getRawEmail endpoints
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="decode"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailSummaryApiResponse"/>&gt;</returns>
        public async Task<IGetEmailSummaryApiResponse> GetEmailSummaryAsync(Guid emailId, Option<bool> decode = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetEmailSummary(ref emailId, ref decode);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/summary"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/summary");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (decode.IsSet)
                        parseQueryStringLocalVar["decode"] = ClientUtils.ParameterToString(decode.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailSummaryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailSummaryApiResponse>();

                        GetEmailSummaryApiResponse apiResponseLocalVar = new GetEmailSummaryApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/summary", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailSummaryDefaultImplementation(apiResponseLocalVar, emailId, decode);

                        Events.ExecuteOnGetEmailSummary(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailSummaryDefaultImplementation(e, "/emails/{emailId}/summary", uriBuilderLocalVar.Path, emailId, decode);
                Events.ExecuteOnErrorGetEmailSummary(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailSummaryApiResponse"/>
        /// </summary>
        public partial class GetEmailSummaryApiResponse : mailslurp.Client.ApiResponse, IGetEmailSummaryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailSummaryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailSummaryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailSummaryApiResponse(ILogger<GetEmailSummaryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailPreview Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailPreview>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailPreview result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailTextLines(ref Guid emailId, ref Option<bool> decodeHtmlEntities, ref Option<string> lineSeparator);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="lineSeparator"></param>
        /// <returns></returns>
        private void ValidateGetEmailTextLines(Option<string> lineSeparator)
        {
            if (lineSeparator.IsSet && lineSeparator.Value == null)
                throw new ArgumentNullException(nameof(lineSeparator));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="decodeHtmlEntities"></param>
        /// <param name="lineSeparator"></param>
        private void AfterGetEmailTextLinesDefaultImplementation(IGetEmailTextLinesApiResponse apiResponseLocalVar, Guid emailId, Option<bool> decodeHtmlEntities, Option<string> lineSeparator)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailTextLines(ref suppressDefaultLog, apiResponseLocalVar, emailId, decodeHtmlEntities, lineSeparator);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="decodeHtmlEntities"></param>
        /// <param name="lineSeparator"></param>
        partial void AfterGetEmailTextLines(ref bool suppressDefaultLog, IGetEmailTextLinesApiResponse apiResponseLocalVar, Guid emailId, Option<bool> decodeHtmlEntities, Option<string> lineSeparator);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="decodeHtmlEntities"></param>
        /// <param name="lineSeparator"></param>
        private void OnErrorGetEmailTextLinesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<bool> decodeHtmlEntities, Option<string> lineSeparator)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailTextLines(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, decodeHtmlEntities, lineSeparator);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="decodeHtmlEntities"></param>
        /// <param name="lineSeparator"></param>
        partial void OnErrorGetEmailTextLines(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<bool> decodeHtmlEntities, Option<string> lineSeparator);

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
        /// </summary>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="decodeHtmlEntities">Decode HTML entities (optional)</param>
        /// <param name="lineSeparator">Line separator character (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailTextLinesApiResponse"/>&gt;</returns>
        public async Task<IGetEmailTextLinesApiResponse> GetEmailTextLinesOrDefaultAsync(Guid emailId, Option<bool> decodeHtmlEntities = default, Option<string> lineSeparator = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailTextLinesAsync(emailId, decodeHtmlEntities, lineSeparator, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="decodeHtmlEntities">Decode HTML entities (optional)</param>
        /// <param name="lineSeparator">Line separator character (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailTextLinesApiResponse"/>&gt;</returns>
        public async Task<IGetEmailTextLinesApiResponse> GetEmailTextLinesAsync(Guid emailId, Option<bool> decodeHtmlEntities = default, Option<string> lineSeparator = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailTextLines(lineSeparator);

                FormatGetEmailTextLines(ref emailId, ref decodeHtmlEntities, ref lineSeparator);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/textLines"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/textLines");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (decodeHtmlEntities.IsSet)
                        parseQueryStringLocalVar["decodeHtmlEntities"] = ClientUtils.ParameterToString(decodeHtmlEntities.Value);

                    if (lineSeparator.IsSet)
                        parseQueryStringLocalVar["lineSeparator"] = ClientUtils.ParameterToString(lineSeparator.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailTextLinesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailTextLinesApiResponse>();

                        GetEmailTextLinesApiResponse apiResponseLocalVar = new GetEmailTextLinesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/textLines", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailTextLinesDefaultImplementation(apiResponseLocalVar, emailId, decodeHtmlEntities, lineSeparator);

                        Events.ExecuteOnGetEmailTextLines(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailTextLinesDefaultImplementation(e, "/emails/{emailId}/textLines", uriBuilderLocalVar.Path, emailId, decodeHtmlEntities, lineSeparator);
                Events.ExecuteOnErrorGetEmailTextLines(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailTextLinesApiResponse"/>
        /// </summary>
        public partial class GetEmailTextLinesApiResponse : mailslurp.Client.ApiResponse, IGetEmailTextLinesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailTextLinesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailTextLinesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailTextLinesApiResponse(ILogger<GetEmailTextLinesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailTextLinesResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailTextLinesResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailTextLinesResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailThread(ref Guid threadId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        private void AfterGetEmailThreadDefaultImplementation(IGetEmailThreadApiResponse apiResponseLocalVar, Guid threadId)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailThread(ref suppressDefaultLog, apiResponseLocalVar, threadId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        partial void AfterGetEmailThread(ref bool suppressDefaultLog, IGetEmailThreadApiResponse apiResponseLocalVar, Guid threadId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        private void OnErrorGetEmailThreadDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid threadId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailThread(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        partial void OnErrorGetEmailThread(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid threadId);

        /// <summary>
        /// Return email thread information. Use items endpoints to get messages for thread. Return email message thread summary from Message-ID, In-Reply-To, and References header. Get messages using items endpoint
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailThreadApiResponse"/>&gt;</returns>
        public async Task<IGetEmailThreadApiResponse> GetEmailThreadOrDefaultAsync(Guid threadId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailThreadAsync(threadId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Return email thread information. Use items endpoints to get messages for thread. Return email message thread summary from Message-ID, In-Reply-To, and References header. Get messages using items endpoint
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailThreadApiResponse"/>&gt;</returns>
        public async Task<IGetEmailThreadApiResponse> GetEmailThreadAsync(Guid threadId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetEmailThread(ref threadId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/threads/{threadId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/threads/{threadId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BthreadId%7D", Uri.EscapeDataString(threadId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailThreadApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailThreadApiResponse>();

                        GetEmailThreadApiResponse apiResponseLocalVar = new GetEmailThreadApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/threads/{threadId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailThreadDefaultImplementation(apiResponseLocalVar, threadId);

                        Events.ExecuteOnGetEmailThread(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailThreadDefaultImplementation(e, "/emails/threads/{threadId}", uriBuilderLocalVar.Path, threadId);
                Events.ExecuteOnErrorGetEmailThread(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailThreadApiResponse"/>
        /// </summary>
        public partial class GetEmailThreadApiResponse : mailslurp.Client.ApiResponse, IGetEmailThreadApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailThreadApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailThreadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailThreadApiResponse(ILogger<GetEmailThreadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailThreadDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailThreadDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailThreadDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailThreadItems(ref Guid threadId, ref Option<string> sort);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateGetEmailThreadItems(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="sort"></param>
        private void AfterGetEmailThreadItemsDefaultImplementation(IGetEmailThreadItemsApiResponse apiResponseLocalVar, Guid threadId, Option<string> sort)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailThreadItems(ref suppressDefaultLog, apiResponseLocalVar, threadId, sort);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="sort"></param>
        partial void AfterGetEmailThreadItems(ref bool suppressDefaultLog, IGetEmailThreadItemsApiResponse apiResponseLocalVar, Guid threadId, Option<string> sort);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="sort"></param>
        private void OnErrorGetEmailThreadItemsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid threadId, Option<string> sort)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailThreadItems(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, sort);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="sort"></param>
        partial void OnErrorGetEmailThreadItems(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid threadId, Option<string> sort);

        /// <summary>
        /// Return email thread items. Return email thread messages based on Message-ID, In-Reply-To, and References header
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailThreadItemsApiResponse"/>&gt;</returns>
        public async Task<IGetEmailThreadItemsApiResponse> GetEmailThreadItemsOrDefaultAsync(Guid threadId, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailThreadItemsAsync(threadId, sort, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Return email thread items. Return email thread messages based on Message-ID, In-Reply-To, and References header
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailThreadItemsApiResponse"/>&gt;</returns>
        public async Task<IGetEmailThreadItemsApiResponse> GetEmailThreadItemsAsync(Guid threadId, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailThreadItems(sort);

                FormatGetEmailThreadItems(ref threadId, ref sort);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/threads/{threadId}/items"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/threads/{threadId}/items");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BthreadId%7D", Uri.EscapeDataString(threadId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailThreadItemsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailThreadItemsApiResponse>();

                        GetEmailThreadItemsApiResponse apiResponseLocalVar = new GetEmailThreadItemsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/threads/{threadId}/items", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailThreadItemsDefaultImplementation(apiResponseLocalVar, threadId, sort);

                        Events.ExecuteOnGetEmailThreadItems(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailThreadItemsDefaultImplementation(e, "/emails/threads/{threadId}/items", uriBuilderLocalVar.Path, threadId, sort);
                Events.ExecuteOnErrorGetEmailThreadItems(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailThreadItemsApiResponse"/>
        /// </summary>
        public partial class GetEmailThreadItemsApiResponse : mailslurp.Client.ApiResponse, IGetEmailThreadItemsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailThreadItemsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailThreadItemsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailThreadItemsApiResponse(ILogger<GetEmailThreadItemsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailThreadItemsDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailThreadItemsDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailThreadItemsDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailThreads(ref Option<Guid> htmlSelector, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<string> searchFilter, ref Option<DateTime> since, ref Option<DateTime> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <returns></returns>
        private void ValidateGetEmailThreads(Option<string> sort, Option<string> searchFilter)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (searchFilter.IsSet && searchFilter.Value == null)
                throw new ArgumentNullException(nameof(searchFilter));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="htmlSelector"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void AfterGetEmailThreadsDefaultImplementation(IGetEmailThreadsApiResponse apiResponseLocalVar, Option<Guid> htmlSelector, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailThreads(ref suppressDefaultLog, apiResponseLocalVar, htmlSelector, page, size, sort, searchFilter, since, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="htmlSelector"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void AfterGetEmailThreads(ref bool suppressDefaultLog, IGetEmailThreadsApiResponse apiResponseLocalVar, Option<Guid> htmlSelector, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="htmlSelector"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        private void OnErrorGetEmailThreadsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> htmlSelector, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailThreads(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, htmlSelector, page, size, sort, searchFilter, since, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="htmlSelector"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        partial void OnErrorGetEmailThreads(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> htmlSelector, Option<int> page, Option<int> size, Option<string> sort, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before);

        /// <summary>
        /// Return email threads in paginated form Return email message chains built from Message-ID, In-Reply-To, and References header.
        /// </summary>
        /// <param name="htmlSelector">Optional inbox filter (optional)</param>
        /// <param name="page">Optional page index in email thread pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email thread pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter search filter for email threads. (optional)</param>
        /// <param name="since">Optional filter email threads created since time (optional)</param>
        /// <param name="before">Optional filter emails threads created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailThreadsApiResponse"/>&gt;</returns>
        public async Task<IGetEmailThreadsApiResponse> GetEmailThreadsOrDefaultAsync(Option<Guid> htmlSelector = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailThreadsAsync(htmlSelector, page, size, sort, searchFilter, since, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Return email threads in paginated form Return email message chains built from Message-ID, In-Reply-To, and References header.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="htmlSelector">Optional inbox filter (optional)</param>
        /// <param name="page">Optional page index in email thread pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email thread pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter search filter for email threads. (optional)</param>
        /// <param name="since">Optional filter email threads created since time (optional)</param>
        /// <param name="before">Optional filter emails threads created before given date time (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailThreadsApiResponse"/>&gt;</returns>
        public async Task<IGetEmailThreadsApiResponse> GetEmailThreadsAsync(Option<Guid> htmlSelector = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailThreads(sort, searchFilter);

                FormatGetEmailThreads(ref htmlSelector, ref page, ref size, ref sort, ref searchFilter, ref since, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/threads"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/threads");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (htmlSelector.IsSet)
                        parseQueryStringLocalVar["htmlSelector"] = ClientUtils.ParameterToString(htmlSelector.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (searchFilter.IsSet)
                        parseQueryStringLocalVar["searchFilter"] = ClientUtils.ParameterToString(searchFilter.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailThreadsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailThreadsApiResponse>();

                        GetEmailThreadsApiResponse apiResponseLocalVar = new GetEmailThreadsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/threads", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailThreadsDefaultImplementation(apiResponseLocalVar, htmlSelector, page, size, sort, searchFilter, since, before);

                        Events.ExecuteOnGetEmailThreads(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailThreadsDefaultImplementation(e, "/emails/threads", uriBuilderLocalVar.Path, htmlSelector, page, size, sort, searchFilter, since, before);
                Events.ExecuteOnErrorGetEmailThreads(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailThreadsApiResponse"/>
        /// </summary>
        public partial class GetEmailThreadsApiResponse : mailslurp.Client.ApiResponse, IGetEmailThreadsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailThreadsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailThreadsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailThreadsApiResponse(ILogger<GetEmailThreadsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageEmailThreadProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageEmailThreadProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageEmailThreadProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailsOffsetPaginated(Option<List<Guid>> inboxId, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<bool> unreadOnly, ref Option<string> searchFilter, ref Option<DateTime> since, ref Option<DateTime> before, ref Option<bool> favourited, ref Option<bool> syncConnectors, ref Option<Guid> plusAddressId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <returns></returns>
        private void ValidateGetEmailsOffsetPaginated(Option<List<Guid>> inboxId, Option<string> sort, Option<string> searchFilter)
        {
            if (inboxId.IsSet && inboxId.Value == null)
                throw new ArgumentNullException(nameof(inboxId));

            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (searchFilter.IsSet && searchFilter.Value == null)
                throw new ArgumentNullException(nameof(searchFilter));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="favourited"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="plusAddressId"></param>
        private void AfterGetEmailsOffsetPaginatedDefaultImplementation(IGetEmailsOffsetPaginatedApiResponse apiResponseLocalVar, Option<List<Guid>> inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<bool> unreadOnly, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before, Option<bool> favourited, Option<bool> syncConnectors, Option<Guid> plusAddressId)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailsOffsetPaginated(ref suppressDefaultLog, apiResponseLocalVar, inboxId, page, size, sort, unreadOnly, searchFilter, since, before, favourited, syncConnectors, plusAddressId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="favourited"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="plusAddressId"></param>
        partial void AfterGetEmailsOffsetPaginated(ref bool suppressDefaultLog, IGetEmailsOffsetPaginatedApiResponse apiResponseLocalVar, Option<List<Guid>> inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<bool> unreadOnly, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before, Option<bool> favourited, Option<bool> syncConnectors, Option<Guid> plusAddressId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="favourited"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="plusAddressId"></param>
        private void OnErrorGetEmailsOffsetPaginatedDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<List<Guid>> inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<bool> unreadOnly, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before, Option<bool> favourited, Option<bool> syncConnectors, Option<Guid> plusAddressId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailsOffsetPaginated(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, page, size, sort, unreadOnly, searchFilter, since, before, favourited, syncConnectors, plusAddressId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="favourited"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="plusAddressId"></param>
        partial void OnErrorGetEmailsOffsetPaginated(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<List<Guid>> inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<bool> unreadOnly, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before, Option<bool> favourited, Option<bool> syncConnectors, Option<Guid> plusAddressId);

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all. By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailsOffsetPaginatedApiResponse"/>&gt;</returns>
        public async Task<IGetEmailsOffsetPaginatedApiResponse> GetEmailsOffsetPaginatedOrDefaultAsync(Option<List<Guid>> inboxId = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> unreadOnly = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> favourited = default, Option<bool> syncConnectors = default, Option<Guid> plusAddressId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailsOffsetPaginatedAsync(inboxId, page, size, sort, unreadOnly, searchFilter, since, before, favourited, syncConnectors, plusAddressId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all. By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailsOffsetPaginatedApiResponse"/>&gt;</returns>
        public async Task<IGetEmailsOffsetPaginatedApiResponse> GetEmailsOffsetPaginatedAsync(Option<List<Guid>> inboxId = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> unreadOnly = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> favourited = default, Option<bool> syncConnectors = default, Option<Guid> plusAddressId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailsOffsetPaginated(inboxId, sort, searchFilter);

                FormatGetEmailsOffsetPaginated(inboxId, ref page, ref size, ref sort, ref unreadOnly, ref searchFilter, ref since, ref before, ref favourited, ref syncConnectors, ref plusAddressId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/offset-paginated"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/offset-paginated");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (unreadOnly.IsSet)
                        parseQueryStringLocalVar["unreadOnly"] = ClientUtils.ParameterToString(unreadOnly.Value);

                    if (searchFilter.IsSet)
                        parseQueryStringLocalVar["searchFilter"] = ClientUtils.ParameterToString(searchFilter.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (favourited.IsSet)
                        parseQueryStringLocalVar["favourited"] = ClientUtils.ParameterToString(favourited.Value);

                    if (syncConnectors.IsSet)
                        parseQueryStringLocalVar["syncConnectors"] = ClientUtils.ParameterToString(syncConnectors.Value);

                    if (plusAddressId.IsSet)
                        parseQueryStringLocalVar["plusAddressId"] = ClientUtils.ParameterToString(plusAddressId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailsOffsetPaginatedApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailsOffsetPaginatedApiResponse>();

                        GetEmailsOffsetPaginatedApiResponse apiResponseLocalVar = new GetEmailsOffsetPaginatedApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/offset-paginated", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailsOffsetPaginatedDefaultImplementation(apiResponseLocalVar, inboxId, page, size, sort, unreadOnly, searchFilter, since, before, favourited, syncConnectors, plusAddressId);

                        Events.ExecuteOnGetEmailsOffsetPaginated(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailsOffsetPaginatedDefaultImplementation(e, "/emails/offset-paginated", uriBuilderLocalVar.Path, inboxId, page, size, sort, unreadOnly, searchFilter, since, before, favourited, syncConnectors, plusAddressId);
                Events.ExecuteOnErrorGetEmailsOffsetPaginated(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailsOffsetPaginatedApiResponse"/>
        /// </summary>
        public partial class GetEmailsOffsetPaginatedApiResponse : mailslurp.Client.ApiResponse, IGetEmailsOffsetPaginatedApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailsOffsetPaginatedApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailsOffsetPaginatedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailsOffsetPaginatedApiResponse(ILogger<GetEmailsOffsetPaginatedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageEmailProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageEmailProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageEmailProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmailsPaginated(Option<List<Guid>> inboxId, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<bool> unreadOnly, ref Option<string> searchFilter, ref Option<DateTime> since, ref Option<DateTime> before, ref Option<bool> syncConnectors, ref Option<Guid> plusAddressId, ref Option<bool> favourited);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <returns></returns>
        private void ValidateGetEmailsPaginated(Option<List<Guid>> inboxId, Option<string> sort, Option<string> searchFilter)
        {
            if (inboxId.IsSet && inboxId.Value == null)
                throw new ArgumentNullException(nameof(inboxId));

            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (searchFilter.IsSet && searchFilter.Value == null)
                throw new ArgumentNullException(nameof(searchFilter));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="favourited"></param>
        private void AfterGetEmailsPaginatedDefaultImplementation(IGetEmailsPaginatedApiResponse apiResponseLocalVar, Option<List<Guid>> inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<bool> unreadOnly, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before, Option<bool> syncConnectors, Option<Guid> plusAddressId, Option<bool> favourited)
        {
            bool suppressDefaultLog = false;
            AfterGetEmailsPaginated(ref suppressDefaultLog, apiResponseLocalVar, inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, plusAddressId, favourited);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="favourited"></param>
        partial void AfterGetEmailsPaginated(ref bool suppressDefaultLog, IGetEmailsPaginatedApiResponse apiResponseLocalVar, Option<List<Guid>> inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<bool> unreadOnly, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before, Option<bool> syncConnectors, Option<Guid> plusAddressId, Option<bool> favourited);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="favourited"></param>
        private void OnErrorGetEmailsPaginatedDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<List<Guid>> inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<bool> unreadOnly, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before, Option<bool> syncConnectors, Option<Guid> plusAddressId, Option<bool> favourited)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmailsPaginated(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, plusAddressId, favourited);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="plusAddressId"></param>
        /// <param name="favourited"></param>
        partial void OnErrorGetEmailsPaginated(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<List<Guid>> inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<bool> unreadOnly, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before, Option<bool> syncConnectors, Option<Guid> plusAddressId, Option<bool> favourited);

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all. By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailsPaginatedApiResponse"/>&gt;</returns>
        public async Task<IGetEmailsPaginatedApiResponse> GetEmailsPaginatedOrDefaultAsync(Option<List<Guid>> inboxId = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> unreadOnly = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> syncConnectors = default, Option<Guid> plusAddressId = default, Option<bool> favourited = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmailsPaginatedAsync(inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, plusAddressId, favourited, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all. By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmailsPaginatedApiResponse"/>&gt;</returns>
        public async Task<IGetEmailsPaginatedApiResponse> GetEmailsPaginatedAsync(Option<List<Guid>> inboxId = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> unreadOnly = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> syncConnectors = default, Option<Guid> plusAddressId = default, Option<bool> favourited = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmailsPaginated(inboxId, sort, searchFilter);

                FormatGetEmailsPaginated(inboxId, ref page, ref size, ref sort, ref unreadOnly, ref searchFilter, ref since, ref before, ref syncConnectors, ref plusAddressId, ref favourited);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (unreadOnly.IsSet)
                        parseQueryStringLocalVar["unreadOnly"] = ClientUtils.ParameterToString(unreadOnly.Value);

                    if (searchFilter.IsSet)
                        parseQueryStringLocalVar["searchFilter"] = ClientUtils.ParameterToString(searchFilter.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (syncConnectors.IsSet)
                        parseQueryStringLocalVar["syncConnectors"] = ClientUtils.ParameterToString(syncConnectors.Value);

                    if (plusAddressId.IsSet)
                        parseQueryStringLocalVar["plusAddressId"] = ClientUtils.ParameterToString(plusAddressId.Value);

                    if (favourited.IsSet)
                        parseQueryStringLocalVar["favourited"] = ClientUtils.ParameterToString(favourited.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetEmailsPaginatedApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmailsPaginatedApiResponse>();

                        GetEmailsPaginatedApiResponse apiResponseLocalVar = new GetEmailsPaginatedApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmailsPaginatedDefaultImplementation(apiResponseLocalVar, inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, plusAddressId, favourited);

                        Events.ExecuteOnGetEmailsPaginated(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmailsPaginatedDefaultImplementation(e, "/emails", uriBuilderLocalVar.Path, inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, plusAddressId, favourited);
                Events.ExecuteOnErrorGetEmailsPaginated(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmailsPaginatedApiResponse"/>
        /// </summary>
        public partial class GetEmailsPaginatedApiResponse : mailslurp.Client.ApiResponse, IGetEmailsPaginatedApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmailsPaginatedApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmailsPaginatedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmailsPaginatedApiResponse(ILogger<GetEmailsPaginatedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageEmailProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageEmailProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageEmailProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetGravatarUrlForEmailAddress(ref string emailAddress, ref Option<string> size);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="emailAddress"></param>
        /// <param name="size"></param>
        /// <returns></returns>
        private void ValidateGetGravatarUrlForEmailAddress(string emailAddress, Option<string> size)
        {
            if (emailAddress == null)
                throw new ArgumentNullException(nameof(emailAddress));

            if (size.IsSet && size.Value == null)
                throw new ArgumentNullException(nameof(size));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailAddress"></param>
        /// <param name="size"></param>
        private void AfterGetGravatarUrlForEmailAddressDefaultImplementation(IGetGravatarUrlForEmailAddressApiResponse apiResponseLocalVar, string emailAddress, Option<string> size)
        {
            bool suppressDefaultLog = false;
            AfterGetGravatarUrlForEmailAddress(ref suppressDefaultLog, apiResponseLocalVar, emailAddress, size);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailAddress"></param>
        /// <param name="size"></param>
        partial void AfterGetGravatarUrlForEmailAddress(ref bool suppressDefaultLog, IGetGravatarUrlForEmailAddressApiResponse apiResponseLocalVar, string emailAddress, Option<string> size);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailAddress"></param>
        /// <param name="size"></param>
        private void OnErrorGetGravatarUrlForEmailAddressDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string emailAddress, Option<string> size)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetGravatarUrlForEmailAddress(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailAddress, size);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailAddress"></param>
        /// <param name="size"></param>
        partial void OnErrorGetGravatarUrlForEmailAddress(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string emailAddress, Option<string> size);

        /// <summary>
        ///  Get gravatar url for email address
        /// </summary>
        /// <param name="emailAddress"></param>
        /// <param name="size"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGravatarUrlForEmailAddressApiResponse"/>&gt;</returns>
        public async Task<IGetGravatarUrlForEmailAddressApiResponse> GetGravatarUrlForEmailAddressOrDefaultAsync(string emailAddress, Option<string> size = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetGravatarUrlForEmailAddressAsync(emailAddress, size, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Get gravatar url for email address
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="size"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGravatarUrlForEmailAddressApiResponse"/>&gt;</returns>
        public async Task<IGetGravatarUrlForEmailAddressApiResponse> GetGravatarUrlForEmailAddressAsync(string emailAddress, Option<string> size = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetGravatarUrlForEmailAddress(emailAddress, size);

                FormatGetGravatarUrlForEmailAddress(ref emailAddress, ref size);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/gravatarFor"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/gravatarFor");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["emailAddress"] = ClientUtils.ParameterToString(emailAddress);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetGravatarUrlForEmailAddressApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetGravatarUrlForEmailAddressApiResponse>();

                        GetGravatarUrlForEmailAddressApiResponse apiResponseLocalVar = new GetGravatarUrlForEmailAddressApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/gravatarFor", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetGravatarUrlForEmailAddressDefaultImplementation(apiResponseLocalVar, emailAddress, size);

                        Events.ExecuteOnGetGravatarUrlForEmailAddress(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetGravatarUrlForEmailAddressDefaultImplementation(e, "/emails/gravatarFor", uriBuilderLocalVar.Path, emailAddress, size);
                Events.ExecuteOnErrorGetGravatarUrlForEmailAddress(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetGravatarUrlForEmailAddressApiResponse"/>
        /// </summary>
        public partial class GetGravatarUrlForEmailAddressApiResponse : mailslurp.Client.ApiResponse, IGetGravatarUrlForEmailAddressApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetGravatarUrlForEmailAddressApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetGravatarUrlForEmailAddressApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetGravatarUrlForEmailAddressApiResponse(ILogger<GetGravatarUrlForEmailAddressApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.GravatarUrl Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.GravatarUrl>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.GravatarUrl result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetLatestEmail(Option<List<Guid>> inboxIds);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="inboxIds"></param>
        /// <returns></returns>
        private void ValidateGetLatestEmail(Option<List<Guid>> inboxIds)
        {
            if (inboxIds.IsSet && inboxIds.Value == null)
                throw new ArgumentNullException(nameof(inboxIds));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxIds"></param>
        private void AfterGetLatestEmailDefaultImplementation(IGetLatestEmailApiResponse apiResponseLocalVar, Option<List<Guid>> inboxIds)
        {
            bool suppressDefaultLog = false;
            AfterGetLatestEmail(ref suppressDefaultLog, apiResponseLocalVar, inboxIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxIds"></param>
        partial void AfterGetLatestEmail(ref bool suppressDefaultLog, IGetLatestEmailApiResponse apiResponseLocalVar, Option<List<Guid>> inboxIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxIds"></param>
        private void OnErrorGetLatestEmailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<List<Guid>> inboxIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetLatestEmail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxIds"></param>
        partial void OnErrorGetLatestEmail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<List<Guid>> inboxIds);

        /// <summary>
        /// Get latest email in all inboxes. Most recently received. Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </summary>
        /// <param name="inboxIds">Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestEmailApiResponse"/>&gt;</returns>
        public async Task<IGetLatestEmailApiResponse> GetLatestEmailOrDefaultAsync(Option<List<Guid>> inboxIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetLatestEmailAsync(inboxIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get latest email in all inboxes. Most recently received. Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxIds">Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestEmailApiResponse"/>&gt;</returns>
        public async Task<IGetLatestEmailApiResponse> GetLatestEmailAsync(Option<List<Guid>> inboxIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetLatestEmail(inboxIds);

                FormatGetLatestEmail(inboxIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/latest"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/latest");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxIds.IsSet)
                        parseQueryStringLocalVar["inboxIds"] = ClientUtils.ParameterToString(inboxIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetLatestEmailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetLatestEmailApiResponse>();

                        GetLatestEmailApiResponse apiResponseLocalVar = new GetLatestEmailApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/latest", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetLatestEmailDefaultImplementation(apiResponseLocalVar, inboxIds);

                        Events.ExecuteOnGetLatestEmail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetLatestEmailDefaultImplementation(e, "/emails/latest", uriBuilderLocalVar.Path, inboxIds);
                Events.ExecuteOnErrorGetLatestEmail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetLatestEmailApiResponse"/>
        /// </summary>
        public partial class GetLatestEmailApiResponse : mailslurp.Client.ApiResponse, IGetLatestEmailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetLatestEmailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetLatestEmailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLatestEmailApiResponse(ILogger<GetLatestEmailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.Email Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.Email>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.Email result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetLatestEmailInInbox1(ref Guid inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterGetLatestEmailInInbox1DefaultImplementation(IGetLatestEmailInInbox1ApiResponse apiResponseLocalVar, Guid inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetLatestEmailInInbox1(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetLatestEmailInInbox1(ref bool suppressDefaultLog, IGetLatestEmailInInbox1ApiResponse apiResponseLocalVar, Guid inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetLatestEmailInInbox1DefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetLatestEmailInInbox1(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetLatestEmailInInbox1(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId);

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet. Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </summary>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestEmailInInbox1ApiResponse"/>&gt;</returns>
        public async Task<IGetLatestEmailInInbox1ApiResponse> GetLatestEmailInInbox1OrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetLatestEmailInInbox1Async(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet. Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLatestEmailInInbox1ApiResponse"/>&gt;</returns>
        public async Task<IGetLatestEmailInInbox1ApiResponse> GetLatestEmailInInbox1Async(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetLatestEmailInInbox1(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/latestIn"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/latestIn");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetLatestEmailInInbox1ApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetLatestEmailInInbox1ApiResponse>();

                        GetLatestEmailInInbox1ApiResponse apiResponseLocalVar = new GetLatestEmailInInbox1ApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/latestIn", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetLatestEmailInInbox1DefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnGetLatestEmailInInbox1(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetLatestEmailInInbox1DefaultImplementation(e, "/emails/latestIn", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorGetLatestEmailInInbox1(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetLatestEmailInInbox1ApiResponse"/>
        /// </summary>
        public partial class GetLatestEmailInInbox1ApiResponse : mailslurp.Client.ApiResponse, IGetLatestEmailInInbox1ApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetLatestEmailInInbox1ApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetLatestEmailInInbox1ApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLatestEmailInInbox1ApiResponse(ILogger<GetLatestEmailInInbox1ApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.Email Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.Email>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.Email result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetOrganizationEmailsPaginated(Option<List<Guid>> inboxId, ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<bool> unreadOnly, ref Option<string> searchFilter, ref Option<DateTime> since, ref Option<DateTime> before, ref Option<bool> syncConnectors, ref Option<bool> favourited, ref Option<Guid> plusAddressId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="inboxId"></param>
        /// <param name="sort"></param>
        /// <param name="searchFilter"></param>
        /// <returns></returns>
        private void ValidateGetOrganizationEmailsPaginated(Option<List<Guid>> inboxId, Option<string> sort, Option<string> searchFilter)
        {
            if (inboxId.IsSet && inboxId.Value == null)
                throw new ArgumentNullException(nameof(inboxId));

            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (searchFilter.IsSet && searchFilter.Value == null)
                throw new ArgumentNullException(nameof(searchFilter));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="favourited"></param>
        /// <param name="plusAddressId"></param>
        private void AfterGetOrganizationEmailsPaginatedDefaultImplementation(IGetOrganizationEmailsPaginatedApiResponse apiResponseLocalVar, Option<List<Guid>> inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<bool> unreadOnly, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before, Option<bool> syncConnectors, Option<bool> favourited, Option<Guid> plusAddressId)
        {
            bool suppressDefaultLog = false;
            AfterGetOrganizationEmailsPaginated(ref suppressDefaultLog, apiResponseLocalVar, inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, favourited, plusAddressId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="favourited"></param>
        /// <param name="plusAddressId"></param>
        partial void AfterGetOrganizationEmailsPaginated(ref bool suppressDefaultLog, IGetOrganizationEmailsPaginatedApiResponse apiResponseLocalVar, Option<List<Guid>> inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<bool> unreadOnly, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before, Option<bool> syncConnectors, Option<bool> favourited, Option<Guid> plusAddressId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="favourited"></param>
        /// <param name="plusAddressId"></param>
        private void OnErrorGetOrganizationEmailsPaginatedDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<List<Guid>> inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<bool> unreadOnly, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before, Option<bool> syncConnectors, Option<bool> favourited, Option<Guid> plusAddressId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetOrganizationEmailsPaginated(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, favourited, plusAddressId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="searchFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="favourited"></param>
        /// <param name="plusAddressId"></param>
        partial void OnErrorGetOrganizationEmailsPaginated(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<List<Guid>> inboxId, Option<int> page, Option<int> size, Option<string> sort, Option<bool> unreadOnly, Option<string> searchFilter, Option<DateTime> since, Option<DateTime> before, Option<bool> syncConnectors, Option<bool> favourited, Option<Guid> plusAddressId);

        /// <summary>
        /// Get all organization emails. List team or shared test email accounts By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter search filter for emails. (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favorited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOrganizationEmailsPaginatedApiResponse"/>&gt;</returns>
        public async Task<IGetOrganizationEmailsPaginatedApiResponse> GetOrganizationEmailsPaginatedOrDefaultAsync(Option<List<Guid>> inboxId = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> unreadOnly = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> syncConnectors = default, Option<bool> favourited = default, Option<Guid> plusAddressId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetOrganizationEmailsPaginatedAsync(inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, favourited, plusAddressId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all organization emails. List team or shared test email accounts By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter search filter for emails. (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favorited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOrganizationEmailsPaginatedApiResponse"/>&gt;</returns>
        public async Task<IGetOrganizationEmailsPaginatedApiResponse> GetOrganizationEmailsPaginatedAsync(Option<List<Guid>> inboxId = default, Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<bool> unreadOnly = default, Option<string> searchFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<bool> syncConnectors = default, Option<bool> favourited = default, Option<Guid> plusAddressId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetOrganizationEmailsPaginated(inboxId, sort, searchFilter);

                FormatGetOrganizationEmailsPaginated(inboxId, ref page, ref size, ref sort, ref unreadOnly, ref searchFilter, ref since, ref before, ref syncConnectors, ref favourited, ref plusAddressId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/organization"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/organization");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (unreadOnly.IsSet)
                        parseQueryStringLocalVar["unreadOnly"] = ClientUtils.ParameterToString(unreadOnly.Value);

                    if (searchFilter.IsSet)
                        parseQueryStringLocalVar["searchFilter"] = ClientUtils.ParameterToString(searchFilter.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (syncConnectors.IsSet)
                        parseQueryStringLocalVar["syncConnectors"] = ClientUtils.ParameterToString(syncConnectors.Value);

                    if (favourited.IsSet)
                        parseQueryStringLocalVar["favourited"] = ClientUtils.ParameterToString(favourited.Value);

                    if (plusAddressId.IsSet)
                        parseQueryStringLocalVar["plusAddressId"] = ClientUtils.ParameterToString(plusAddressId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetOrganizationEmailsPaginatedApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetOrganizationEmailsPaginatedApiResponse>();

                        GetOrganizationEmailsPaginatedApiResponse apiResponseLocalVar = new GetOrganizationEmailsPaginatedApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/organization", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetOrganizationEmailsPaginatedDefaultImplementation(apiResponseLocalVar, inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, favourited, plusAddressId);

                        Events.ExecuteOnGetOrganizationEmailsPaginated(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetOrganizationEmailsPaginatedDefaultImplementation(e, "/emails/organization", uriBuilderLocalVar.Path, inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, favourited, plusAddressId);
                Events.ExecuteOnErrorGetOrganizationEmailsPaginated(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetOrganizationEmailsPaginatedApiResponse"/>
        /// </summary>
        public partial class GetOrganizationEmailsPaginatedApiResponse : mailslurp.Client.ApiResponse, IGetOrganizationEmailsPaginatedApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetOrganizationEmailsPaginatedApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetOrganizationEmailsPaginatedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetOrganizationEmailsPaginatedApiResponse(ILogger<GetOrganizationEmailsPaginatedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageEmailProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageEmailProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageEmailProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetRawEmailContents(ref Guid emailId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        private void AfterGetRawEmailContentsDefaultImplementation(IGetRawEmailContentsApiResponse apiResponseLocalVar, Guid emailId)
        {
            bool suppressDefaultLog = false;
            AfterGetRawEmailContents(ref suppressDefaultLog, apiResponseLocalVar, emailId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        partial void AfterGetRawEmailContents(ref bool suppressDefaultLog, IGetRawEmailContentsApiResponse apiResponseLocalVar, Guid emailId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        private void OnErrorGetRawEmailContentsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetRawEmailContents(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        partial void OnErrorGetRawEmailContents(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId);

        /// <summary>
        /// Get raw email string. Returns unparsed raw SMTP message with headers and body. Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
        /// </summary>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRawEmailContentsApiResponse"/>&gt;</returns>
        public async Task<IGetRawEmailContentsApiResponse> GetRawEmailContentsOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetRawEmailContentsAsync(emailId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get raw email string. Returns unparsed raw SMTP message with headers and body. Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRawEmailContentsApiResponse"/>&gt;</returns>
        public async Task<IGetRawEmailContentsApiResponse> GetRawEmailContentsAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetRawEmailContents(ref emailId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/raw"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/raw");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetRawEmailContentsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetRawEmailContentsApiResponse>();

                        GetRawEmailContentsApiResponse apiResponseLocalVar = new GetRawEmailContentsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/raw", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetRawEmailContentsDefaultImplementation(apiResponseLocalVar, emailId);

                        Events.ExecuteOnGetRawEmailContents(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetRawEmailContentsDefaultImplementation(e, "/emails/{emailId}/raw", uriBuilderLocalVar.Path, emailId);
                Events.ExecuteOnErrorGetRawEmailContents(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetRawEmailContentsApiResponse"/>
        /// </summary>
        public partial class GetRawEmailContentsApiResponse : mailslurp.Client.ApiResponse, IGetRawEmailContentsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetRawEmailContentsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetRawEmailContentsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetRawEmailContentsApiResponse(ILogger<GetRawEmailContentsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetRawEmailJson(ref Guid emailId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        private void AfterGetRawEmailJsonDefaultImplementation(IGetRawEmailJsonApiResponse apiResponseLocalVar, Guid emailId)
        {
            bool suppressDefaultLog = false;
            AfterGetRawEmailJson(ref suppressDefaultLog, apiResponseLocalVar, emailId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        partial void AfterGetRawEmailJson(ref bool suppressDefaultLog, IGetRawEmailJsonApiResponse apiResponseLocalVar, Guid emailId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        private void OnErrorGetRawEmailJsonDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetRawEmailJson(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        partial void OnErrorGetRawEmailJson(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId);

        /// <summary>
        /// Get raw email in JSON. Unparsed SMTP message in JSON wrapper format. Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
        /// </summary>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRawEmailJsonApiResponse"/>&gt;</returns>
        public async Task<IGetRawEmailJsonApiResponse> GetRawEmailJsonOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetRawEmailJsonAsync(emailId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get raw email in JSON. Unparsed SMTP message in JSON wrapper format. Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRawEmailJsonApiResponse"/>&gt;</returns>
        public async Task<IGetRawEmailJsonApiResponse> GetRawEmailJsonAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetRawEmailJson(ref emailId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/raw/json"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/raw/json");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetRawEmailJsonApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetRawEmailJsonApiResponse>();

                        GetRawEmailJsonApiResponse apiResponseLocalVar = new GetRawEmailJsonApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/raw/json", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetRawEmailJsonDefaultImplementation(apiResponseLocalVar, emailId);

                        Events.ExecuteOnGetRawEmailJson(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetRawEmailJsonDefaultImplementation(e, "/emails/{emailId}/raw/json", uriBuilderLocalVar.Path, emailId);
                Events.ExecuteOnErrorGetRawEmailJson(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetRawEmailJsonApiResponse"/>
        /// </summary>
        public partial class GetRawEmailJsonApiResponse : mailslurp.Client.ApiResponse, IGetRawEmailJsonApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetRawEmailJsonApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetRawEmailJsonApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetRawEmailJsonApiResponse(ILogger<GetRawEmailJsonApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.RawEmailJson Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.RawEmailJson>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.RawEmailJson result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetUnreadEmailCount(ref Option<Guid> inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterGetUnreadEmailCountDefaultImplementation(IGetUnreadEmailCountApiResponse apiResponseLocalVar, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetUnreadEmailCount(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetUnreadEmailCount(ref bool suppressDefaultLog, IGetUnreadEmailCountApiResponse apiResponseLocalVar, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetUnreadEmailCountDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetUnreadEmailCount(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetUnreadEmailCount(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId);

        /// <summary>
        /// Get unread email count Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
        /// </summary>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUnreadEmailCountApiResponse"/>&gt;</returns>
        public async Task<IGetUnreadEmailCountApiResponse> GetUnreadEmailCountOrDefaultAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetUnreadEmailCountAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get unread email count Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUnreadEmailCountApiResponse"/>&gt;</returns>
        public async Task<IGetUnreadEmailCountApiResponse> GetUnreadEmailCountAsync(Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetUnreadEmailCount(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/unreadCount"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/unreadCount");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetUnreadEmailCountApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetUnreadEmailCountApiResponse>();

                        GetUnreadEmailCountApiResponse apiResponseLocalVar = new GetUnreadEmailCountApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/unreadCount", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetUnreadEmailCountDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnGetUnreadEmailCount(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetUnreadEmailCountDefaultImplementation(e, "/emails/unreadCount", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorGetUnreadEmailCount(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetUnreadEmailCountApiResponse"/>
        /// </summary>
        public partial class GetUnreadEmailCountApiResponse : mailslurp.Client.ApiResponse, IGetUnreadEmailCountApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetUnreadEmailCountApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetUnreadEmailCountApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetUnreadEmailCountApiResponse(ILogger<GetUnreadEmailCountApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.UnreadCount Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.UnreadCount>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.UnreadCount result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatMarkAllAsRead(ref Option<bool> read, ref Option<Guid> inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="read"></param>
        /// <param name="inboxId"></param>
        private void AfterMarkAllAsReadDefaultImplementation(IMarkAllAsReadApiResponse apiResponseLocalVar, Option<bool> read, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterMarkAllAsRead(ref suppressDefaultLog, apiResponseLocalVar, read, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="read"></param>
        /// <param name="inboxId"></param>
        partial void AfterMarkAllAsRead(ref bool suppressDefaultLog, IMarkAllAsReadApiResponse apiResponseLocalVar, Option<bool> read, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="read"></param>
        /// <param name="inboxId"></param>
        private void OnErrorMarkAllAsReadDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool> read, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorMarkAllAsRead(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, read, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="read"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorMarkAllAsRead(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool> read, Option<Guid> inboxId);

        /// <summary>
        /// Mark all emails as read or unread Marks all emails as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </summary>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMarkAllAsReadApiResponse"/>&gt;</returns>
        public async Task<IMarkAllAsReadApiResponse> MarkAllAsReadOrDefaultAsync(Option<bool> read = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await MarkAllAsReadAsync(read, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Mark all emails as read or unread Marks all emails as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMarkAllAsReadApiResponse"/>&gt;</returns>
        public async Task<IMarkAllAsReadApiResponse> MarkAllAsReadAsync(Option<bool> read = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatMarkAllAsRead(ref read, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/read"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/read");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (read.IsSet)
                        parseQueryStringLocalVar["read"] = ClientUtils.ParameterToString(read.Value);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("PATCH");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<MarkAllAsReadApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<MarkAllAsReadApiResponse>();

                        MarkAllAsReadApiResponse apiResponseLocalVar = new MarkAllAsReadApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/read", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterMarkAllAsReadDefaultImplementation(apiResponseLocalVar, read, inboxId);

                        Events.ExecuteOnMarkAllAsRead(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorMarkAllAsReadDefaultImplementation(e, "/emails/read", uriBuilderLocalVar.Path, read, inboxId);
                Events.ExecuteOnErrorMarkAllAsRead(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="MarkAllAsReadApiResponse"/>
        /// </summary>
        public partial class MarkAllAsReadApiResponse : mailslurp.Client.ApiResponse, IMarkAllAsReadApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<MarkAllAsReadApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="MarkAllAsReadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MarkAllAsReadApiResponse(ILogger<MarkAllAsReadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatMarkAsRead(ref Guid emailId, ref Option<bool> read);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="read"></param>
        private void AfterMarkAsReadDefaultImplementation(IMarkAsReadApiResponse apiResponseLocalVar, Guid emailId, Option<bool> read)
        {
            bool suppressDefaultLog = false;
            AfterMarkAsRead(ref suppressDefaultLog, apiResponseLocalVar, emailId, read);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="read"></param>
        partial void AfterMarkAsRead(ref bool suppressDefaultLog, IMarkAsReadApiResponse apiResponseLocalVar, Guid emailId, Option<bool> read);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="read"></param>
        private void OnErrorMarkAsReadDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<bool> read)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorMarkAsRead(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, read);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="read"></param>
        partial void OnErrorMarkAsRead(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<bool> read);

        /// <summary>
        /// Mark an email as read or unread Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </summary>
        /// <param name="emailId"></param>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMarkAsReadApiResponse"/>&gt;</returns>
        public async Task<IMarkAsReadApiResponse> MarkAsReadOrDefaultAsync(Guid emailId, Option<bool> read = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await MarkAsReadAsync(emailId, read, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Mark an email as read or unread Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMarkAsReadApiResponse"/>&gt;</returns>
        public async Task<IMarkAsReadApiResponse> MarkAsReadAsync(Guid emailId, Option<bool> read = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatMarkAsRead(ref emailId, ref read);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/read"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/read");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (read.IsSet)
                        parseQueryStringLocalVar["read"] = ClientUtils.ParameterToString(read.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("PATCH");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<MarkAsReadApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<MarkAsReadApiResponse>();

                        MarkAsReadApiResponse apiResponseLocalVar = new MarkAsReadApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/read", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterMarkAsReadDefaultImplementation(apiResponseLocalVar, emailId, read);

                        Events.ExecuteOnMarkAsRead(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorMarkAsReadDefaultImplementation(e, "/emails/{emailId}/read", uriBuilderLocalVar.Path, emailId, read);
                Events.ExecuteOnErrorMarkAsRead(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="MarkAsReadApiResponse"/>
        /// </summary>
        public partial class MarkAsReadApiResponse : mailslurp.Client.ApiResponse, IMarkAsReadApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<MarkAsReadApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="MarkAsReadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MarkAsReadApiResponse(ILogger<MarkAsReadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.EmailPreview Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.EmailPreview>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.EmailPreview result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatReplyToEmail(ref Guid emailId, ReplyToEmailOptions replyToEmailOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="replyToEmailOptions"></param>
        /// <returns></returns>
        private void ValidateReplyToEmail(ReplyToEmailOptions replyToEmailOptions)
        {
            if (replyToEmailOptions == null)
                throw new ArgumentNullException(nameof(replyToEmailOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="replyToEmailOptions"></param>
        private void AfterReplyToEmailDefaultImplementation(IReplyToEmailApiResponse apiResponseLocalVar, Guid emailId, ReplyToEmailOptions replyToEmailOptions)
        {
            bool suppressDefaultLog = false;
            AfterReplyToEmail(ref suppressDefaultLog, apiResponseLocalVar, emailId, replyToEmailOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="replyToEmailOptions"></param>
        partial void AfterReplyToEmail(ref bool suppressDefaultLog, IReplyToEmailApiResponse apiResponseLocalVar, Guid emailId, ReplyToEmailOptions replyToEmailOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="replyToEmailOptions"></param>
        private void OnErrorReplyToEmailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, ReplyToEmailOptions replyToEmailOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorReplyToEmail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, replyToEmailOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="replyToEmailOptions"></param>
        partial void OnErrorReplyToEmail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, ReplyToEmailOptions replyToEmailOptions);

        /// <summary>
        /// Reply to an email Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails &#x60;to&#x60;, &#x60;cc&#x60;, and &#x60;bcc&#x60;.
        /// </summary>
        /// <param name="emailId">ID of the email that should be replied to</param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplyToEmailApiResponse"/>&gt;</returns>
        public async Task<IReplyToEmailApiResponse> ReplyToEmailOrDefaultAsync(Guid emailId, ReplyToEmailOptions replyToEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ReplyToEmailAsync(emailId, replyToEmailOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Reply to an email Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails &#x60;to&#x60;, &#x60;cc&#x60;, and &#x60;bcc&#x60;.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of the email that should be replied to</param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplyToEmailApiResponse"/>&gt;</returns>
        public async Task<IReplyToEmailApiResponse> ReplyToEmailAsync(Guid emailId, ReplyToEmailOptions replyToEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateReplyToEmail(replyToEmailOptions);

                FormatReplyToEmail(ref emailId, replyToEmailOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    httpRequestMessageLocalVar.Content = (replyToEmailOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(replyToEmailOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("PUT");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ReplyToEmailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ReplyToEmailApiResponse>();

                        ReplyToEmailApiResponse apiResponseLocalVar = new ReplyToEmailApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterReplyToEmailDefaultImplementation(apiResponseLocalVar, emailId, replyToEmailOptions);

                        Events.ExecuteOnReplyToEmail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorReplyToEmailDefaultImplementation(e, "/emails/{emailId}", uriBuilderLocalVar.Path, emailId, replyToEmailOptions);
                Events.ExecuteOnErrorReplyToEmail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ReplyToEmailApiResponse"/>
        /// </summary>
        public partial class ReplyToEmailApiResponse : mailslurp.Client.ApiResponse, IReplyToEmailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ReplyToEmailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ReplyToEmailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ReplyToEmailApiResponse(ILogger<ReplyToEmailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.SentEmailDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.SentEmailDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.SentEmailDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchEmails(SearchEmailsOptions searchEmailsOptions, ref Option<bool> syncConnectors, ref Option<bool> favourited, ref Option<Guid> plusAddressId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="searchEmailsOptions"></param>
        /// <returns></returns>
        private void ValidateSearchEmails(SearchEmailsOptions searchEmailsOptions)
        {
            if (searchEmailsOptions == null)
                throw new ArgumentNullException(nameof(searchEmailsOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="favourited"></param>
        /// <param name="plusAddressId"></param>
        private void AfterSearchEmailsDefaultImplementation(ISearchEmailsApiResponse apiResponseLocalVar, SearchEmailsOptions searchEmailsOptions, Option<bool> syncConnectors, Option<bool> favourited, Option<Guid> plusAddressId)
        {
            bool suppressDefaultLog = false;
            AfterSearchEmails(ref suppressDefaultLog, apiResponseLocalVar, searchEmailsOptions, syncConnectors, favourited, plusAddressId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="favourited"></param>
        /// <param name="plusAddressId"></param>
        partial void AfterSearchEmails(ref bool suppressDefaultLog, ISearchEmailsApiResponse apiResponseLocalVar, SearchEmailsOptions searchEmailsOptions, Option<bool> syncConnectors, Option<bool> favourited, Option<Guid> plusAddressId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="favourited"></param>
        /// <param name="plusAddressId"></param>
        private void OnErrorSearchEmailsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SearchEmailsOptions searchEmailsOptions, Option<bool> syncConnectors, Option<bool> favourited, Option<Guid> plusAddressId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchEmails(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, searchEmailsOptions, syncConnectors, favourited, plusAddressId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors"></param>
        /// <param name="favourited"></param>
        /// <param name="plusAddressId"></param>
        partial void OnErrorSearchEmails(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SearchEmailsOptions searchEmailsOptions, Option<bool> syncConnectors, Option<bool> favourited, Option<Guid> plusAddressId);

        /// <summary>
        /// Get all emails by search criteria. Return in paginated form. Search emails by given criteria return matches in paginated format. Searches against email recipients, sender, subject, email address and ID. Does not search email body
        /// </summary>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favourited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchEmailsApiResponse"/>&gt;</returns>
        public async Task<ISearchEmailsApiResponse> SearchEmailsOrDefaultAsync(SearchEmailsOptions searchEmailsOptions, Option<bool> syncConnectors = default, Option<bool> favourited = default, Option<Guid> plusAddressId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchEmailsAsync(searchEmailsOptions, syncConnectors, favourited, plusAddressId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all emails by search criteria. Return in paginated form. Search emails by given criteria return matches in paginated format. Searches against email recipients, sender, subject, email address and ID. Does not search email body
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favourited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchEmailsApiResponse"/>&gt;</returns>
        public async Task<ISearchEmailsApiResponse> SearchEmailsAsync(SearchEmailsOptions searchEmailsOptions, Option<bool> syncConnectors = default, Option<bool> favourited = default, Option<Guid> plusAddressId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchEmails(searchEmailsOptions);

                FormatSearchEmails(searchEmailsOptions, ref syncConnectors, ref favourited, ref plusAddressId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (syncConnectors.IsSet)
                        parseQueryStringLocalVar["syncConnectors"] = ClientUtils.ParameterToString(syncConnectors.Value);

                    if (favourited.IsSet)
                        parseQueryStringLocalVar["favourited"] = ClientUtils.ParameterToString(favourited.Value);

                    if (plusAddressId.IsSet)
                        parseQueryStringLocalVar["plusAddressId"] = ClientUtils.ParameterToString(plusAddressId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (searchEmailsOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(searchEmailsOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SearchEmailsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchEmailsApiResponse>();

                        SearchEmailsApiResponse apiResponseLocalVar = new SearchEmailsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/search", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSearchEmailsDefaultImplementation(apiResponseLocalVar, searchEmailsOptions, syncConnectors, favourited, plusAddressId);

                        Events.ExecuteOnSearchEmails(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchEmailsDefaultImplementation(e, "/emails/search", uriBuilderLocalVar.Path, searchEmailsOptions, syncConnectors, favourited, plusAddressId);
                Events.ExecuteOnErrorSearchEmails(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchEmailsApiResponse"/>
        /// </summary>
        public partial class SearchEmailsApiResponse : mailslurp.Client.ApiResponse, ISearchEmailsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchEmailsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchEmailsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchEmailsApiResponse(ILogger<SearchEmailsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageEmailProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageEmailProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageEmailProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendEmailSourceOptional(SendEmailOptions sendEmailOptions, ref Option<Guid> inboxId, ref Option<bool> useDomainPool, ref Option<bool> virtualSend);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sendEmailOptions"></param>
        /// <returns></returns>
        private void ValidateSendEmailSourceOptional(SendEmailOptions sendEmailOptions)
        {
            if (sendEmailOptions == null)
                throw new ArgumentNullException(nameof(sendEmailOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="virtualSend"></param>
        private void AfterSendEmailSourceOptionalDefaultImplementation(ISendEmailSourceOptionalApiResponse apiResponseLocalVar, SendEmailOptions sendEmailOptions, Option<Guid> inboxId, Option<bool> useDomainPool, Option<bool> virtualSend)
        {
            bool suppressDefaultLog = false;
            AfterSendEmailSourceOptional(ref suppressDefaultLog, apiResponseLocalVar, sendEmailOptions, inboxId, useDomainPool, virtualSend);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="virtualSend"></param>
        partial void AfterSendEmailSourceOptional(ref bool suppressDefaultLog, ISendEmailSourceOptionalApiResponse apiResponseLocalVar, SendEmailOptions sendEmailOptions, Option<Guid> inboxId, Option<bool> useDomainPool, Option<bool> virtualSend);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="virtualSend"></param>
        private void OnErrorSendEmailSourceOptionalDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SendEmailOptions sendEmailOptions, Option<Guid> inboxId, Option<bool> useDomainPool, Option<bool> virtualSend)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendEmailSourceOptional(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, sendEmailOptions, inboxId, useDomainPool, virtualSend);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="virtualSend"></param>
        partial void OnErrorSendEmailSourceOptional(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SendEmailOptions sendEmailOptions, Option<Guid> inboxId, Option<bool> useDomainPool, Option<bool> virtualSend);

        /// <summary>
        /// Send email Alias for &#x60;InboxController.sendEmail&#x60; method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
        /// </summary>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId">ID of the inbox you want to send the email from (optional)</param>
        /// <param name="useDomainPool">Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)</param>
        /// <param name="virtualSend">Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailSourceOptionalApiResponse"/>&gt;</returns>
        public async Task<ISendEmailSourceOptionalApiResponse> SendEmailSourceOptionalOrDefaultAsync(SendEmailOptions sendEmailOptions, Option<Guid> inboxId = default, Option<bool> useDomainPool = default, Option<bool> virtualSend = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendEmailSourceOptionalAsync(sendEmailOptions, inboxId, useDomainPool, virtualSend, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send email Alias for &#x60;InboxController.sendEmail&#x60; method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId">ID of the inbox you want to send the email from (optional)</param>
        /// <param name="useDomainPool">Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)</param>
        /// <param name="virtualSend">Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailSourceOptionalApiResponse"/>&gt;</returns>
        public async Task<ISendEmailSourceOptionalApiResponse> SendEmailSourceOptionalAsync(SendEmailOptions sendEmailOptions, Option<Guid> inboxId = default, Option<bool> useDomainPool = default, Option<bool> virtualSend = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendEmailSourceOptional(sendEmailOptions);

                FormatSendEmailSourceOptional(sendEmailOptions, ref inboxId, ref useDomainPool, ref virtualSend);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    if (useDomainPool.IsSet)
                        parseQueryStringLocalVar["useDomainPool"] = ClientUtils.ParameterToString(useDomainPool.Value);

                    if (virtualSend.IsSet)
                        parseQueryStringLocalVar["virtualSend"] = ClientUtils.ParameterToString(virtualSend.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (sendEmailOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendEmailOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SendEmailSourceOptionalApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendEmailSourceOptionalApiResponse>();

                        SendEmailSourceOptionalApiResponse apiResponseLocalVar = new SendEmailSourceOptionalApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendEmailSourceOptionalDefaultImplementation(apiResponseLocalVar, sendEmailOptions, inboxId, useDomainPool, virtualSend);

                        Events.ExecuteOnSendEmailSourceOptional(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendEmailSourceOptionalDefaultImplementation(e, "/emails", uriBuilderLocalVar.Path, sendEmailOptions, inboxId, useDomainPool, virtualSend);
                Events.ExecuteOnErrorSendEmailSourceOptional(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendEmailSourceOptionalApiResponse"/>
        /// </summary>
        public partial class SendEmailSourceOptionalApiResponse : mailslurp.Client.ApiResponse, ISendEmailSourceOptionalApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendEmailSourceOptionalApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendEmailSourceOptionalApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendEmailSourceOptionalApiResponse(ILogger<SendEmailSourceOptionalApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSetEmailFavourited(ref Guid emailId, ref bool favourited);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="favourited"></param>
        private void AfterSetEmailFavouritedDefaultImplementation(ISetEmailFavouritedApiResponse apiResponseLocalVar, Guid emailId, bool favourited)
        {
            bool suppressDefaultLog = false;
            AfterSetEmailFavourited(ref suppressDefaultLog, apiResponseLocalVar, emailId, favourited);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="favourited"></param>
        partial void AfterSetEmailFavourited(ref bool suppressDefaultLog, ISetEmailFavouritedApiResponse apiResponseLocalVar, Guid emailId, bool favourited);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="favourited"></param>
        private void OnErrorSetEmailFavouritedDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, bool favourited)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSetEmailFavourited(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, favourited);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="favourited"></param>
        partial void OnErrorSetEmailFavourited(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, bool favourited);

        /// <summary>
        /// Set email favourited state Set and return new favorite state for an email
        /// </summary>
        /// <param name="emailId">ID of email to set favourite state</param>
        /// <param name="favourited"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetEmailFavouritedApiResponse"/>&gt;</returns>
        public async Task<ISetEmailFavouritedApiResponse> SetEmailFavouritedOrDefaultAsync(Guid emailId, bool favourited, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SetEmailFavouritedAsync(emailId, favourited, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Set email favourited state Set and return new favorite state for an email
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to set favourite state</param>
        /// <param name="favourited"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetEmailFavouritedApiResponse"/>&gt;</returns>
        public async Task<ISetEmailFavouritedApiResponse> SetEmailFavouritedAsync(Guid emailId, bool favourited, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatSetEmailFavourited(ref emailId, ref favourited);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/favourite"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/favourite");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["favourited"] = ClientUtils.ParameterToString(favourited);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("PUT");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SetEmailFavouritedApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SetEmailFavouritedApiResponse>();

                        SetEmailFavouritedApiResponse apiResponseLocalVar = new SetEmailFavouritedApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/favourite", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSetEmailFavouritedDefaultImplementation(apiResponseLocalVar, emailId, favourited);

                        Events.ExecuteOnSetEmailFavourited(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSetEmailFavouritedDefaultImplementation(e, "/emails/{emailId}/favourite", uriBuilderLocalVar.Path, emailId, favourited);
                Events.ExecuteOnErrorSetEmailFavourited(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SetEmailFavouritedApiResponse"/>
        /// </summary>
        public partial class SetEmailFavouritedApiResponse : mailslurp.Client.ApiResponse, ISetEmailFavouritedApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SetEmailFavouritedApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SetEmailFavouritedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SetEmailFavouritedApiResponse(ILogger<SetEmailFavouritedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatValidateEmail(ref Guid emailId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        private void AfterValidateEmailDefaultImplementation(IValidateEmailApiResponse apiResponseLocalVar, Guid emailId)
        {
            bool suppressDefaultLog = false;
            AfterValidateEmail(ref suppressDefaultLog, apiResponseLocalVar, emailId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        partial void AfterValidateEmail(ref bool suppressDefaultLog, IValidateEmailApiResponse apiResponseLocalVar, Guid emailId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        private void OnErrorValidateEmailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorValidateEmail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        partial void OnErrorValidateEmail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId);

        /// <summary>
        /// Validate email HTML contents Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
        /// </summary>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IValidateEmailApiResponse"/>&gt;</returns>
        public async Task<IValidateEmailApiResponse> ValidateEmailOrDefaultAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ValidateEmailAsync(emailId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Validate email HTML contents Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IValidateEmailApiResponse"/>&gt;</returns>
        public async Task<IValidateEmailApiResponse> ValidateEmailAsync(Guid emailId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatValidateEmail(ref emailId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emails/{emailId}/validate"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emails/{emailId}/validate");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BemailId%7D", Uri.EscapeDataString(emailId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ValidateEmailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ValidateEmailApiResponse>();

                        ValidateEmailApiResponse apiResponseLocalVar = new ValidateEmailApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emails/{emailId}/validate", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterValidateEmailDefaultImplementation(apiResponseLocalVar, emailId);

                        Events.ExecuteOnValidateEmail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorValidateEmailDefaultImplementation(e, "/emails/{emailId}/validate", uriBuilderLocalVar.Path, emailId);
                Events.ExecuteOnErrorValidateEmail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ValidateEmailApiResponse"/>
        /// </summary>
        public partial class ValidateEmailApiResponse : mailslurp.Client.ApiResponse, IValidateEmailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ValidateEmailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ValidateEmailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ValidateEmailApiResponse(ILogger<ValidateEmailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ValidationDto Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ValidationDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out mailslurp.Model.ValidationDto result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
