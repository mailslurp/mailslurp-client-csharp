/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEmailControllerApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag.
        /// </summary>
        /// <remarks>
        /// Apply RFC3501 section-2.3.2 IMAP flag operations on an email
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailPreview</returns>
        EmailPreview ApplyImapFlagOperation(Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions, int operationIndex = 0);

        /// <summary>
        /// Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag.
        /// </summary>
        /// <remarks>
        /// Apply RFC3501 section-2.3.2 IMAP flag operations on an email
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailPreview</returns>
        ApiResponse<EmailPreview> ApplyImapFlagOperationWithHttpInfo(Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions, int operationIndex = 0);
        /// <summary>
        /// Check if email can be sent and options are valid.
        /// </summary>
        /// <remarks>
        /// Can user send email to given recipient or is the recipient blocked
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CanSendEmailResults</returns>
        CanSendEmailResults CanSend(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0);

        /// <summary>
        /// Check if email can be sent and options are valid.
        /// </summary>
        /// <remarks>
        /// Can user send email to given recipient or is the recipient blocked
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CanSendEmailResults</returns>
        ApiResponse<CanSendEmailResults> CanSendWithHttpInfo(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0);
        /// <summary>
        /// Detect broken links, spelling, and images in email content
        /// </summary>
        /// <remarks>
        /// Find dead links, broken images, and spelling mistakes in email body. Will call included links via HTTP so do not invoke if your links are sensitive or stateful. Any resource that returns a 4xx or 5xx response or is not reachable via HEAD or GET HTTP operations will be considered unhealthy.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CheckEmailBodyResults</returns>
        CheckEmailBodyResults CheckEmailBody(Guid emailId, int operationIndex = 0);

        /// <summary>
        /// Detect broken links, spelling, and images in email content
        /// </summary>
        /// <remarks>
        /// Find dead links, broken images, and spelling mistakes in email body. Will call included links via HTTP so do not invoke if your links are sensitive or stateful. Any resource that returns a 4xx or 5xx response or is not reachable via HEAD or GET HTTP operations will be considered unhealthy.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CheckEmailBodyResults</returns>
        ApiResponse<CheckEmailBodyResults> CheckEmailBodyWithHttpInfo(Guid emailId, int operationIndex = 0);
        /// <summary>
        /// Show which mail clients support the HTML and CSS features used in an email body.
        /// </summary>
        /// <remarks>
        /// Detect HTML and CSS features inside an email body and return a report of email client support across different platforms and versions.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CheckEmailBodyFeatureSupportResults</returns>
        CheckEmailBodyFeatureSupportResults CheckEmailBodyFeatureSupport(Guid emailId, int operationIndex = 0);

        /// <summary>
        /// Show which mail clients support the HTML and CSS features used in an email body.
        /// </summary>
        /// <remarks>
        /// Detect HTML and CSS features inside an email body and return a report of email client support across different platforms and versions.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CheckEmailBodyFeatureSupportResults</returns>
        ApiResponse<CheckEmailBodyFeatureSupportResults> CheckEmailBodyFeatureSupportWithHttpInfo(Guid emailId, int operationIndex = 0);
        /// <summary>
        /// Show which email programs and devices support the features used in an email body.
        /// </summary>
        /// <remarks>
        /// Evaluate the features used in an email body and return a report of email client support across different platforms and versions.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CheckEmailClientSupportResults</returns>
        CheckEmailClientSupportResults CheckEmailClientSupport(CheckEmailClientSupportOptions checkEmailClientSupportOptions, int operationIndex = 0);

        /// <summary>
        /// Show which email programs and devices support the features used in an email body.
        /// </summary>
        /// <remarks>
        /// Evaluate the features used in an email body and return a report of email client support across different platforms and versions.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CheckEmailClientSupportResults</returns>
        ApiResponse<CheckEmailClientSupportResults> CheckEmailClientSupportWithHttpInfo(CheckEmailClientSupportOptions checkEmailClientSupportOptions, int operationIndex = 0);
        /// <summary>
        /// Delete all emails in all inboxes.
        /// </summary>
        /// <remarks>
        /// Deletes all emails in your account. Be careful as emails cannot be recovered
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteAllEmails(int operationIndex = 0);

        /// <summary>
        /// Delete all emails in all inboxes.
        /// </summary>
        /// <remarks>
        /// Deletes all emails in your account. Be careful as emails cannot be recovered
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAllEmailsWithHttpInfo(int operationIndex = 0);
        /// <summary>
        /// Delete an email
        /// </summary>
        /// <remarks>
        /// Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteEmail(Guid emailId, int operationIndex = 0);

        /// <summary>
        /// Delete an email
        /// </summary>
        /// <remarks>
        /// Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteEmailWithHttpInfo(Guid emailId, int operationIndex = 0);
        /// <summary>
        /// Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="apiKey">Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>byte[]</returns>
        byte[] DownloadAttachment(Guid emailId, string attachmentId, string apiKey = default, int operationIndex = 0);

        /// <summary>
        /// Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="apiKey">Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of byte[]</returns>
        ApiResponse<byte[]> DownloadAttachmentWithHttpInfo(Guid emailId, string attachmentId, string apiKey = default, int operationIndex = 0);
        /// <summary>
        /// Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DownloadAttachmentDto</returns>
        DownloadAttachmentDto DownloadAttachmentBase64(Guid emailId, string attachmentId, int operationIndex = 0);

        /// <summary>
        /// Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DownloadAttachmentDto</returns>
        ApiResponse<DownloadAttachmentDto> DownloadAttachmentBase64WithHttpInfo(Guid emailId, string attachmentId, int operationIndex = 0);
        /// <summary>
        /// Get email body as string. Returned as &#x60;plain/text&#x60; with content type header.
        /// </summary>
        /// <remarks>
        /// Returns the specified email body for a given email as a string
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        string DownloadBody(Guid emailId, int operationIndex = 0);

        /// <summary>
        /// Get email body as string. Returned as &#x60;plain/text&#x60; with content type header.
        /// </summary>
        /// <remarks>
        /// Returns the specified email body for a given email as a string
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> DownloadBodyWithHttpInfo(Guid emailId, int operationIndex = 0);
        /// <summary>
        /// Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header.
        /// </summary>
        /// <remarks>
        /// Returns the specified email body for a given email as a stream / array of bytes.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>byte[]</returns>
        byte[] DownloadBodyBytes(Guid emailId, int operationIndex = 0);

        /// <summary>
        /// Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header.
        /// </summary>
        /// <remarks>
        /// Returns the specified email body for a given email as a stream / array of bytes.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of byte[]</returns>
        ApiResponse<byte[]> DownloadBodyBytesWithHttpInfo(Guid emailId, int operationIndex = 0);
        /// <summary>
        /// Forward email to recipients
        /// </summary>
        /// <remarks>
        /// Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the &#x60;from&#x60; option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="forwardEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SentEmailDto</returns>
        SentEmailDto ForwardEmail(Guid emailId, ForwardEmailOptions forwardEmailOptions, int operationIndex = 0);

        /// <summary>
        /// Forward email to recipients
        /// </summary>
        /// <remarks>
        /// Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the &#x60;from&#x60; option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="forwardEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SentEmailDto</returns>
        ApiResponse<SentEmailDto> ForwardEmailWithHttpInfo(Guid emailId, ForwardEmailOptions forwardEmailOptions, int operationIndex = 0);
        /// <summary>
        /// Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods.
        /// </summary>
        /// <remarks>
        /// Returns the metadata such as name and content-type for a given attachment and email.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>AttachmentMetaData</returns>
        AttachmentMetaData GetAttachmentMetaData(Guid emailId, string attachmentId, int operationIndex = 0);

        /// <summary>
        /// Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods.
        /// </summary>
        /// <remarks>
        /// Returns the metadata such as name and content-type for a given attachment and email.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of AttachmentMetaData</returns>
        ApiResponse<AttachmentMetaData> GetAttachmentMetaDataWithHttpInfo(Guid emailId, string attachmentId, int operationIndex = 0);
        /// <summary>
        /// Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
        /// </summary>
        /// <remarks>
        /// Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        Email GetEmail(Guid emailId, int operationIndex = 0);

        /// <summary>
        /// Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
        /// </summary>
        /// <remarks>
        /// Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        ApiResponse<Email> GetEmailWithHttpInfo(Guid emailId, int operationIndex = 0);
        /// <summary>
        /// Get all email attachment metadata. Metadata includes name and size of attachments.
        /// </summary>
        /// <remarks>
        /// Returns an array of attachment metadata such as name and content-type for a given email if present.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;AttachmentMetaData&gt;</returns>
        List<AttachmentMetaData> GetEmailAttachments(Guid emailId, int operationIndex = 0);

        /// <summary>
        /// Get all email attachment metadata. Metadata includes name and size of attachments.
        /// </summary>
        /// <remarks>
        /// Returns an array of attachment metadata such as name and content-type for a given email if present.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;AttachmentMetaData&gt;</returns>
        ApiResponse<List<AttachmentMetaData>> GetEmailAttachmentsWithHttpInfo(Guid emailId, int operationIndex = 0);
        /// <summary>
        /// Get email content regex pattern match results. Runs regex against email body and returns match groups.
        /// </summary>
        /// <remarks>
        /// Return the matches for a given Java style regex pattern. Do not include the typical &#x60;/&#x60; at start or end of regex in some languages. Given an example &#x60;your code is: 12345&#x60; the pattern to extract match looks like &#x60;code is: (\\d{6})&#x60;. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: &#x60;[&#39;code is: 123456&#39;, &#39;123456&#39;]&#x60; See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentMatchOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailContentMatchResult</returns>
        EmailContentMatchResult GetEmailContentMatch(Guid emailId, ContentMatchOptions contentMatchOptions, int operationIndex = 0);

        /// <summary>
        /// Get email content regex pattern match results. Runs regex against email body and returns match groups.
        /// </summary>
        /// <remarks>
        /// Return the matches for a given Java style regex pattern. Do not include the typical &#x60;/&#x60; at start or end of regex in some languages. Given an example &#x60;your code is: 12345&#x60; the pattern to extract match looks like &#x60;code is: (\\d{6})&#x60;. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: &#x60;[&#39;code is: 123456&#39;, &#39;123456&#39;]&#x60; See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentMatchOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailContentMatchResult</returns>
        ApiResponse<EmailContentMatchResult> GetEmailContentMatchWithHttpInfo(Guid emailId, ContentMatchOptions contentMatchOptions, int operationIndex = 0);
        /// <summary>
        /// Get email content part by content type
        /// </summary>
        /// <remarks>
        /// Get email body content parts from a multipart email message for a given content type
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailContentPartResult</returns>
        EmailContentPartResult GetEmailContentPart(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0);

        /// <summary>
        /// Get email content part by content type
        /// </summary>
        /// <remarks>
        /// Get email body content parts from a multipart email message for a given content type
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailContentPartResult</returns>
        ApiResponse<EmailContentPartResult> GetEmailContentPartWithHttpInfo(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0);
        /// <summary>
        /// Get email content part by content type raw response
        /// </summary>
        /// <remarks>
        /// Get email body content parts from a multipart email message for a given content type and return as response
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple. Starts from 0 and applies to the result list after selecting for your content type. Content type parts are sorted by order found in original MIME message. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        string GetEmailContentPartContent(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0);

        /// <summary>
        /// Get email content part by content type raw response
        /// </summary>
        /// <remarks>
        /// Get email body content parts from a multipart email message for a given content type and return as response
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple. Starts from 0 and applies to the result list after selecting for your content type. Content type parts are sorted by order found in original MIME message. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> GetEmailContentPartContentWithHttpInfo(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0);
        /// <summary>
        /// Get email count
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CountDto</returns>
        CountDto GetEmailCount(Guid? inboxId = default, int operationIndex = 0);

        /// <summary>
        /// Get email count
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CountDto</returns>
        ApiResponse<CountDto> GetEmailCountWithHttpInfo(Guid? inboxId = default, int operationIndex = 0);
        /// <summary>
        /// Get email content as HTML. For displaying emails in browser context.
        /// </summary>
        /// <remarks>
        /// Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: &#x60;?apiKey&#x3D;xxx&#x60;. Returns content-type &#x60;text/html;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON. For JSON response see the &#x60;getEmailHTMLJson&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        string GetEmailHTML(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0);

        /// <summary>
        /// Get email content as HTML. For displaying emails in browser context.
        /// </summary>
        /// <remarks>
        /// Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: &#x60;?apiKey&#x3D;xxx&#x60;. Returns content-type &#x60;text/html;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON. For JSON response see the &#x60;getEmailHTMLJson&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> GetEmailHTMLWithHttpInfo(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0);
        /// <summary>
        /// Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content
        /// </summary>
        /// <remarks>
        /// Retrieve email content as HTML response. Decodes quoted-printable entities and converts charset to UTF-8. Returns content-type &#x60;application/json;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailHtmlDto</returns>
        EmailHtmlDto GetEmailHTMLJson(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0);

        /// <summary>
        /// Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content
        /// </summary>
        /// <remarks>
        /// Retrieve email content as HTML response. Decodes quoted-printable entities and converts charset to UTF-8. Returns content-type &#x60;application/json;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailHtmlDto</returns>
        ApiResponse<EmailHtmlDto> GetEmailHTMLJsonWithHttpInfo(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0);
        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters
        /// </summary>
        /// <remarks>
        /// Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to perform HTML query on</param>
        /// <param name="htmlSelector">HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailTextLinesResult</returns>
        EmailTextLinesResult GetEmailHTMLQuery(Guid emailId, string htmlSelector, int operationIndex = 0);

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters
        /// </summary>
        /// <remarks>
        /// Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to perform HTML query on</param>
        /// <param name="htmlSelector">HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailTextLinesResult</returns>
        ApiResponse<EmailTextLinesResult> GetEmailHTMLQueryWithHttpInfo(Guid emailId, string htmlSelector, int operationIndex = 0);
        /// <summary>
        /// Parse and return list of links found in an email (only works for HTML content)
        /// </summary>
        /// <remarks>
        /// HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="selector">Optional HTML query selector for links (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailLinksResult</returns>
        EmailLinksResult GetEmailLinks(Guid emailId, string selector = default, int operationIndex = 0);

        /// <summary>
        /// Parse and return list of links found in an email (only works for HTML content)
        /// </summary>
        /// <remarks>
        /// HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="selector">Optional HTML query selector for links (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailLinksResult</returns>
        ApiResponse<EmailLinksResult> GetEmailLinksWithHttpInfo(Guid emailId, string selector = default, int operationIndex = 0);
        /// <summary>
        /// Get email URLs for viewing in browser or downloading
        /// </summary>
        /// <remarks>
        /// Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailPreviewUrls</returns>
        EmailPreviewUrls GetEmailPreviewURLs(Guid emailId, int operationIndex = 0);

        /// <summary>
        /// Get email URLs for viewing in browser or downloading
        /// </summary>
        /// <remarks>
        /// Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailPreviewUrls</returns>
        ApiResponse<EmailPreviewUrls> GetEmailPreviewURLsWithHttpInfo(Guid emailId, int operationIndex = 0);
        /// <summary>
        /// Take a screenshot of an email in a browser and return base64 encoded string
        /// </summary>
        /// <remarks>
        /// Capture image of email screenshot and return as base64 encoded string. Useful for embedding in HTML. Be careful as this may contain sensitive information.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailScreenshotResult</returns>
        EmailScreenshotResult GetEmailScreenshotAsBase64(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0);

        /// <summary>
        /// Take a screenshot of an email in a browser and return base64 encoded string
        /// </summary>
        /// <remarks>
        /// Capture image of email screenshot and return as base64 encoded string. Useful for embedding in HTML. Be careful as this may contain sensitive information.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailScreenshotResult</returns>
        ApiResponse<EmailScreenshotResult> GetEmailScreenshotAsBase64WithHttpInfo(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0);
        /// <summary>
        /// Take a screenshot of an email in a browser
        /// </summary>
        /// <remarks>
        /// Returns binary octet-stream of screenshot of the given email
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void GetEmailScreenshotAsBinary(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0);

        /// <summary>
        /// Take a screenshot of an email in a browser
        /// </summary>
        /// <remarks>
        /// Returns binary octet-stream of screenshot of the given email
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GetEmailScreenshotAsBinaryWithHttpInfo(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0);
        /// <summary>
        /// Get email data including headers but not body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
        /// </summary>
        /// <remarks>
        /// Returns a email summary object with headers. To retrieve the body see getEmail and to get raw unparsed email use the getRawEmail endpoints
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="decode"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailPreview</returns>
        EmailPreview GetEmailSummary(Guid emailId, bool? decode = default, int operationIndex = 0);

        /// <summary>
        /// Get email data including headers but not body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
        /// </summary>
        /// <remarks>
        /// Returns a email summary object with headers. To retrieve the body see getEmail and to get raw unparsed email use the getRawEmail endpoints
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="decode"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailPreview</returns>
        ApiResponse<EmailPreview> GetEmailSummaryWithHttpInfo(Guid emailId, bool? decode = default, int operationIndex = 0);
        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters
        /// </summary>
        /// <remarks>
        /// Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="decodeHtmlEntities">Decode HTML entities (optional)</param>
        /// <param name="lineSeparator">Line separator character (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailTextLinesResult</returns>
        EmailTextLinesResult GetEmailTextLines(Guid emailId, bool? decodeHtmlEntities = default, string lineSeparator = default, int operationIndex = 0);

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters
        /// </summary>
        /// <remarks>
        /// Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="decodeHtmlEntities">Decode HTML entities (optional)</param>
        /// <param name="lineSeparator">Line separator character (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailTextLinesResult</returns>
        ApiResponse<EmailTextLinesResult> GetEmailTextLinesWithHttpInfo(Guid emailId, bool? decodeHtmlEntities = default, string lineSeparator = default, int operationIndex = 0);
        /// <summary>
        /// Return email thread information. Use items endpoints to get messages for thread.
        /// </summary>
        /// <remarks>
        /// Return email message thread summary from Message-ID, In-Reply-To, and References header. Get messages using items endpoint
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailThreadDto</returns>
        EmailThreadDto GetEmailThread(Guid threadId, int operationIndex = 0);

        /// <summary>
        /// Return email thread information. Use items endpoints to get messages for thread.
        /// </summary>
        /// <remarks>
        /// Return email message thread summary from Message-ID, In-Reply-To, and References header. Get messages using items endpoint
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailThreadDto</returns>
        ApiResponse<EmailThreadDto> GetEmailThreadWithHttpInfo(Guid threadId, int operationIndex = 0);
        /// <summary>
        /// Return email thread items.
        /// </summary>
        /// <remarks>
        /// Return email thread messages based on Message-ID, In-Reply-To, and References header
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailThreadItemsDto</returns>
        EmailThreadItemsDto GetEmailThreadItems(Guid threadId, string sort = default, int operationIndex = 0);

        /// <summary>
        /// Return email thread items.
        /// </summary>
        /// <remarks>
        /// Return email thread messages based on Message-ID, In-Reply-To, and References header
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailThreadItemsDto</returns>
        ApiResponse<EmailThreadItemsDto> GetEmailThreadItemsWithHttpInfo(Guid threadId, string sort = default, int operationIndex = 0);
        /// <summary>
        /// Return email threads in paginated form
        /// </summary>
        /// <remarks>
        /// Return email message chains built from Message-ID, In-Reply-To, and References header.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="htmlSelector">Optional inbox filter (optional)</param>
        /// <param name="page">Optional page index in email thread pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email thread pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter search filter for email threads. (optional)</param>
        /// <param name="since">Optional filter email threads created since time (optional)</param>
        /// <param name="before">Optional filter emails threads created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageEmailThreadProjection</returns>
        PageEmailThreadProjection GetEmailThreads(Guid? htmlSelector = default, int? page = default, int? size = default, string sort = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, int operationIndex = 0);

        /// <summary>
        /// Return email threads in paginated form
        /// </summary>
        /// <remarks>
        /// Return email message chains built from Message-ID, In-Reply-To, and References header.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="htmlSelector">Optional inbox filter (optional)</param>
        /// <param name="page">Optional page index in email thread pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email thread pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter search filter for email threads. (optional)</param>
        /// <param name="since">Optional filter email threads created since time (optional)</param>
        /// <param name="before">Optional filter emails threads created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageEmailThreadProjection</returns>
        ApiResponse<PageEmailThreadProjection> GetEmailThreadsWithHttpInfo(Guid? htmlSelector = default, int? page = default, int? size = default, string sort = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, int operationIndex = 0);
        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all.
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageEmailProjection</returns>
        PageEmailProjection GetEmailsOffsetPaginated(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? favourited = default, bool? syncConnectors = default, Guid? plusAddressId = default, int operationIndex = 0);

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all.
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageEmailProjection</returns>
        ApiResponse<PageEmailProjection> GetEmailsOffsetPaginatedWithHttpInfo(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? favourited = default, bool? syncConnectors = default, Guid? plusAddressId = default, int operationIndex = 0);
        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all.
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageEmailProjection</returns>
        PageEmailProjection GetEmailsPaginated(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, Guid? plusAddressId = default, bool? favourited = default, int operationIndex = 0);

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all.
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageEmailProjection</returns>
        ApiResponse<PageEmailProjection> GetEmailsPaginatedWithHttpInfo(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, Guid? plusAddressId = default, bool? favourited = default, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get gravatar url for email address
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="size"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GravatarUrl</returns>
        GravatarUrl GetGravatarUrlForEmailAddress(string emailAddress, string size = default, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get gravatar url for email address
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="size"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GravatarUrl</returns>
        ApiResponse<GravatarUrl> GetGravatarUrlForEmailAddressWithHttpInfo(string emailAddress, string size = default, int operationIndex = 0);
        /// <summary>
        /// Get latest email in all inboxes. Most recently received.
        /// </summary>
        /// <remarks>
        /// Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxIds">Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        Email GetLatestEmail(List<Guid> inboxIds = default, int operationIndex = 0);

        /// <summary>
        /// Get latest email in all inboxes. Most recently received.
        /// </summary>
        /// <remarks>
        /// Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxIds">Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        ApiResponse<Email> GetLatestEmailWithHttpInfo(List<Guid> inboxIds = default, int operationIndex = 0);
        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.
        /// </summary>
        /// <remarks>
        /// Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        Email GetLatestEmailInInbox1(Guid inboxId, int operationIndex = 0);

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.
        /// </summary>
        /// <remarks>
        /// Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        ApiResponse<Email> GetLatestEmailInInbox1WithHttpInfo(Guid inboxId, int operationIndex = 0);
        /// <summary>
        /// Get all organization emails. List team or shared test email accounts
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter search filter for emails. (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favorited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageEmailProjection</returns>
        PageEmailProjection GetOrganizationEmailsPaginated(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0);

        /// <summary>
        /// Get all organization emails. List team or shared test email accounts
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter search filter for emails. (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favorited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageEmailProjection</returns>
        ApiResponse<PageEmailProjection> GetOrganizationEmailsPaginatedWithHttpInfo(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0);
        /// <summary>
        /// Get raw email string. Returns unparsed raw SMTP message with headers and body.
        /// </summary>
        /// <remarks>
        /// Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void GetRawEmailContents(Guid emailId, int operationIndex = 0);

        /// <summary>
        /// Get raw email string. Returns unparsed raw SMTP message with headers and body.
        /// </summary>
        /// <remarks>
        /// Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GetRawEmailContentsWithHttpInfo(Guid emailId, int operationIndex = 0);
        /// <summary>
        /// Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
        /// </summary>
        /// <remarks>
        /// Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RawEmailJson</returns>
        RawEmailJson GetRawEmailJson(Guid emailId, int operationIndex = 0);

        /// <summary>
        /// Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
        /// </summary>
        /// <remarks>
        /// Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RawEmailJson</returns>
        ApiResponse<RawEmailJson> GetRawEmailJsonWithHttpInfo(Guid emailId, int operationIndex = 0);
        /// <summary>
        /// Get unread email count
        /// </summary>
        /// <remarks>
        /// Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>UnreadCount</returns>
        UnreadCount GetUnreadEmailCount(Guid? inboxId = default, int operationIndex = 0);

        /// <summary>
        /// Get unread email count
        /// </summary>
        /// <remarks>
        /// Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of UnreadCount</returns>
        ApiResponse<UnreadCount> GetUnreadEmailCountWithHttpInfo(Guid? inboxId = default, int operationIndex = 0);
        /// <summary>
        /// Mark all emails as read or unread
        /// </summary>
        /// <remarks>
        /// Marks all emails as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void MarkAllAsRead(bool? read = default, Guid? inboxId = default, int operationIndex = 0);

        /// <summary>
        /// Mark all emails as read or unread
        /// </summary>
        /// <remarks>
        /// Marks all emails as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> MarkAllAsReadWithHttpInfo(bool? read = default, Guid? inboxId = default, int operationIndex = 0);
        /// <summary>
        /// Mark an email as read or unread
        /// </summary>
        /// <remarks>
        /// Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailPreview</returns>
        EmailPreview MarkAsRead(Guid emailId, bool? read = default, int operationIndex = 0);

        /// <summary>
        /// Mark an email as read or unread
        /// </summary>
        /// <remarks>
        /// Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailPreview</returns>
        ApiResponse<EmailPreview> MarkAsReadWithHttpInfo(Guid emailId, bool? read = default, int operationIndex = 0);
        /// <summary>
        /// Reply to an email
        /// </summary>
        /// <remarks>
        /// Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails &#x60;to&#x60;, &#x60;cc&#x60;, and &#x60;bcc&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of the email that should be replied to</param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SentEmailDto</returns>
        SentEmailDto ReplyToEmail(Guid emailId, ReplyToEmailOptions replyToEmailOptions, int operationIndex = 0);

        /// <summary>
        /// Reply to an email
        /// </summary>
        /// <remarks>
        /// Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails &#x60;to&#x60;, &#x60;cc&#x60;, and &#x60;bcc&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of the email that should be replied to</param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SentEmailDto</returns>
        ApiResponse<SentEmailDto> ReplyToEmailWithHttpInfo(Guid emailId, ReplyToEmailOptions replyToEmailOptions, int operationIndex = 0);
        /// <summary>
        /// Get all emails by search criteria. Return in paginated form.
        /// </summary>
        /// <remarks>
        /// Search emails by given criteria return matches in paginated format. Searches against email recipients, sender, subject, email address and ID. Does not search email body
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favourited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageEmailProjection</returns>
        PageEmailProjection SearchEmails(SearchEmailsOptions searchEmailsOptions, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0);

        /// <summary>
        /// Get all emails by search criteria. Return in paginated form.
        /// </summary>
        /// <remarks>
        /// Search emails by given criteria return matches in paginated format. Searches against email recipients, sender, subject, email address and ID. Does not search email body
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favourited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageEmailProjection</returns>
        ApiResponse<PageEmailProjection> SearchEmailsWithHttpInfo(SearchEmailsOptions searchEmailsOptions, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0);
        /// <summary>
        /// Send email
        /// </summary>
        /// <remarks>
        /// Alias for &#x60;InboxController.sendEmail&#x60; method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId">ID of the inbox you want to send the email from (optional)</param>
        /// <param name="useDomainPool">Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)</param>
        /// <param name="virtualSend">Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void SendEmailSourceOptional(SendEmailOptions sendEmailOptions, Guid? inboxId = default, bool? useDomainPool = default, bool? virtualSend = default, int operationIndex = 0);

        /// <summary>
        /// Send email
        /// </summary>
        /// <remarks>
        /// Alias for &#x60;InboxController.sendEmail&#x60; method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId">ID of the inbox you want to send the email from (optional)</param>
        /// <param name="useDomainPool">Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)</param>
        /// <param name="virtualSend">Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SendEmailSourceOptionalWithHttpInfo(SendEmailOptions sendEmailOptions, Guid? inboxId = default, bool? useDomainPool = default, bool? virtualSend = default, int operationIndex = 0);
        /// <summary>
        /// Set email favourited state
        /// </summary>
        /// <remarks>
        /// Set and return new favorite state for an email
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to set favourite state</param>
        /// <param name="favourited"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void SetEmailFavourited(Guid emailId, bool favourited, int operationIndex = 0);

        /// <summary>
        /// Set email favourited state
        /// </summary>
        /// <remarks>
        /// Set and return new favorite state for an email
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to set favourite state</param>
        /// <param name="favourited"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SetEmailFavouritedWithHttpInfo(Guid emailId, bool favourited, int operationIndex = 0);
        /// <summary>
        /// Validate email HTML contents
        /// </summary>
        /// <remarks>
        /// Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ValidationDto</returns>
        ValidationDto ValidateEmail(Guid emailId, int operationIndex = 0);

        /// <summary>
        /// Validate email HTML contents
        /// </summary>
        /// <remarks>
        /// Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ValidationDto</returns>
        ApiResponse<ValidationDto> ValidateEmailWithHttpInfo(Guid emailId, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEmailControllerApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag.
        /// </summary>
        /// <remarks>
        /// Apply RFC3501 section-2.3.2 IMAP flag operations on an email
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailPreview</returns>
        System.Threading.Tasks.Task<EmailPreview> ApplyImapFlagOperationAsync(Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag.
        /// </summary>
        /// <remarks>
        /// Apply RFC3501 section-2.3.2 IMAP flag operations on an email
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailPreview)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailPreview>> ApplyImapFlagOperationWithHttpInfoAsync(Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Check if email can be sent and options are valid.
        /// </summary>
        /// <remarks>
        /// Can user send email to given recipient or is the recipient blocked
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CanSendEmailResults</returns>
        System.Threading.Tasks.Task<CanSendEmailResults> CanSendAsync(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Check if email can be sent and options are valid.
        /// </summary>
        /// <remarks>
        /// Can user send email to given recipient or is the recipient blocked
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CanSendEmailResults)</returns>
        System.Threading.Tasks.Task<ApiResponse<CanSendEmailResults>> CanSendWithHttpInfoAsync(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Detect broken links, spelling, and images in email content
        /// </summary>
        /// <remarks>
        /// Find dead links, broken images, and spelling mistakes in email body. Will call included links via HTTP so do not invoke if your links are sensitive or stateful. Any resource that returns a 4xx or 5xx response or is not reachable via HEAD or GET HTTP operations will be considered unhealthy.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CheckEmailBodyResults</returns>
        System.Threading.Tasks.Task<CheckEmailBodyResults> CheckEmailBodyAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detect broken links, spelling, and images in email content
        /// </summary>
        /// <remarks>
        /// Find dead links, broken images, and spelling mistakes in email body. Will call included links via HTTP so do not invoke if your links are sensitive or stateful. Any resource that returns a 4xx or 5xx response or is not reachable via HEAD or GET HTTP operations will be considered unhealthy.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CheckEmailBodyResults)</returns>
        System.Threading.Tasks.Task<ApiResponse<CheckEmailBodyResults>> CheckEmailBodyWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Show which mail clients support the HTML and CSS features used in an email body.
        /// </summary>
        /// <remarks>
        /// Detect HTML and CSS features inside an email body and return a report of email client support across different platforms and versions.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CheckEmailBodyFeatureSupportResults</returns>
        System.Threading.Tasks.Task<CheckEmailBodyFeatureSupportResults> CheckEmailBodyFeatureSupportAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Show which mail clients support the HTML and CSS features used in an email body.
        /// </summary>
        /// <remarks>
        /// Detect HTML and CSS features inside an email body and return a report of email client support across different platforms and versions.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CheckEmailBodyFeatureSupportResults)</returns>
        System.Threading.Tasks.Task<ApiResponse<CheckEmailBodyFeatureSupportResults>> CheckEmailBodyFeatureSupportWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Show which email programs and devices support the features used in an email body.
        /// </summary>
        /// <remarks>
        /// Evaluate the features used in an email body and return a report of email client support across different platforms and versions.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CheckEmailClientSupportResults</returns>
        System.Threading.Tasks.Task<CheckEmailClientSupportResults> CheckEmailClientSupportAsync(CheckEmailClientSupportOptions checkEmailClientSupportOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Show which email programs and devices support the features used in an email body.
        /// </summary>
        /// <remarks>
        /// Evaluate the features used in an email body and return a report of email client support across different platforms and versions.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CheckEmailClientSupportResults)</returns>
        System.Threading.Tasks.Task<ApiResponse<CheckEmailClientSupportResults>> CheckEmailClientSupportWithHttpInfoAsync(CheckEmailClientSupportOptions checkEmailClientSupportOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Delete all emails in all inboxes.
        /// </summary>
        /// <remarks>
        /// Deletes all emails in your account. Be careful as emails cannot be recovered
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteAllEmailsAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete all emails in all inboxes.
        /// </summary>
        /// <remarks>
        /// Deletes all emails in your account. Be careful as emails cannot be recovered
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteAllEmailsWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Delete an email
        /// </summary>
        /// <remarks>
        /// Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteEmailAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an email
        /// </summary>
        /// <remarks>
        /// Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteEmailWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="apiKey">Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of byte[]</returns>
        System.Threading.Tasks.Task<byte[]> DownloadAttachmentAsync(Guid emailId, string attachmentId, string apiKey = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="apiKey">Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (byte[])</returns>
        System.Threading.Tasks.Task<ApiResponse<byte[]>> DownloadAttachmentWithHttpInfoAsync(Guid emailId, string attachmentId, string apiKey = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DownloadAttachmentDto</returns>
        System.Threading.Tasks.Task<DownloadAttachmentDto> DownloadAttachmentBase64Async(Guid emailId, string attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DownloadAttachmentDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<DownloadAttachmentDto>> DownloadAttachmentBase64WithHttpInfoAsync(Guid emailId, string attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email body as string. Returned as &#x60;plain/text&#x60; with content type header.
        /// </summary>
        /// <remarks>
        /// Returns the specified email body for a given email as a string
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> DownloadBodyAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email body as string. Returned as &#x60;plain/text&#x60; with content type header.
        /// </summary>
        /// <remarks>
        /// Returns the specified email body for a given email as a string
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> DownloadBodyWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header.
        /// </summary>
        /// <remarks>
        /// Returns the specified email body for a given email as a stream / array of bytes.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of byte[]</returns>
        System.Threading.Tasks.Task<byte[]> DownloadBodyBytesAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header.
        /// </summary>
        /// <remarks>
        /// Returns the specified email body for a given email as a stream / array of bytes.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (byte[])</returns>
        System.Threading.Tasks.Task<ApiResponse<byte[]>> DownloadBodyBytesWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Forward email to recipients
        /// </summary>
        /// <remarks>
        /// Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the &#x60;from&#x60; option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="forwardEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SentEmailDto</returns>
        System.Threading.Tasks.Task<SentEmailDto> ForwardEmailAsync(Guid emailId, ForwardEmailOptions forwardEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Forward email to recipients
        /// </summary>
        /// <remarks>
        /// Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the &#x60;from&#x60; option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="forwardEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SentEmailDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<SentEmailDto>> ForwardEmailWithHttpInfoAsync(Guid emailId, ForwardEmailOptions forwardEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods.
        /// </summary>
        /// <remarks>
        /// Returns the metadata such as name and content-type for a given attachment and email.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AttachmentMetaData</returns>
        System.Threading.Tasks.Task<AttachmentMetaData> GetAttachmentMetaDataAsync(Guid emailId, string attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods.
        /// </summary>
        /// <remarks>
        /// Returns the metadata such as name and content-type for a given attachment and email.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AttachmentMetaData)</returns>
        System.Threading.Tasks.Task<ApiResponse<AttachmentMetaData>> GetAttachmentMetaDataWithHttpInfoAsync(Guid emailId, string attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
        /// </summary>
        /// <remarks>
        /// Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        System.Threading.Tasks.Task<Email> GetEmailAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
        /// </summary>
        /// <remarks>
        /// Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        System.Threading.Tasks.Task<ApiResponse<Email>> GetEmailWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get all email attachment metadata. Metadata includes name and size of attachments.
        /// </summary>
        /// <remarks>
        /// Returns an array of attachment metadata such as name and content-type for a given email if present.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;AttachmentMetaData&gt;</returns>
        System.Threading.Tasks.Task<List<AttachmentMetaData>> GetEmailAttachmentsAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all email attachment metadata. Metadata includes name and size of attachments.
        /// </summary>
        /// <remarks>
        /// Returns an array of attachment metadata such as name and content-type for a given email if present.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;AttachmentMetaData&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<AttachmentMetaData>>> GetEmailAttachmentsWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email content regex pattern match results. Runs regex against email body and returns match groups.
        /// </summary>
        /// <remarks>
        /// Return the matches for a given Java style regex pattern. Do not include the typical &#x60;/&#x60; at start or end of regex in some languages. Given an example &#x60;your code is: 12345&#x60; the pattern to extract match looks like &#x60;code is: (\\d{6})&#x60;. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: &#x60;[&#39;code is: 123456&#39;, &#39;123456&#39;]&#x60; See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentMatchOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailContentMatchResult</returns>
        System.Threading.Tasks.Task<EmailContentMatchResult> GetEmailContentMatchAsync(Guid emailId, ContentMatchOptions contentMatchOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content regex pattern match results. Runs regex against email body and returns match groups.
        /// </summary>
        /// <remarks>
        /// Return the matches for a given Java style regex pattern. Do not include the typical &#x60;/&#x60; at start or end of regex in some languages. Given an example &#x60;your code is: 12345&#x60; the pattern to extract match looks like &#x60;code is: (\\d{6})&#x60;. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: &#x60;[&#39;code is: 123456&#39;, &#39;123456&#39;]&#x60; See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentMatchOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailContentMatchResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailContentMatchResult>> GetEmailContentMatchWithHttpInfoAsync(Guid emailId, ContentMatchOptions contentMatchOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email content part by content type
        /// </summary>
        /// <remarks>
        /// Get email body content parts from a multipart email message for a given content type
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailContentPartResult</returns>
        System.Threading.Tasks.Task<EmailContentPartResult> GetEmailContentPartAsync(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content part by content type
        /// </summary>
        /// <remarks>
        /// Get email body content parts from a multipart email message for a given content type
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailContentPartResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailContentPartResult>> GetEmailContentPartWithHttpInfoAsync(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email content part by content type raw response
        /// </summary>
        /// <remarks>
        /// Get email body content parts from a multipart email message for a given content type and return as response
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple. Starts from 0 and applies to the result list after selecting for your content type. Content type parts are sorted by order found in original MIME message. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> GetEmailContentPartContentAsync(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content part by content type raw response
        /// </summary>
        /// <remarks>
        /// Get email body content parts from a multipart email message for a given content type and return as response
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple. Starts from 0 and applies to the result list after selecting for your content type. Content type parts are sorted by order found in original MIME message. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> GetEmailContentPartContentWithHttpInfoAsync(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email count
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountDto</returns>
        System.Threading.Tasks.Task<CountDto> GetEmailCountAsync(Guid? inboxId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email count
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<CountDto>> GetEmailCountWithHttpInfoAsync(Guid? inboxId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email content as HTML. For displaying emails in browser context.
        /// </summary>
        /// <remarks>
        /// Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: &#x60;?apiKey&#x3D;xxx&#x60;. Returns content-type &#x60;text/html;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON. For JSON response see the &#x60;getEmailHTMLJson&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> GetEmailHTMLAsync(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content as HTML. For displaying emails in browser context.
        /// </summary>
        /// <remarks>
        /// Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: &#x60;?apiKey&#x3D;xxx&#x60;. Returns content-type &#x60;text/html;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON. For JSON response see the &#x60;getEmailHTMLJson&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> GetEmailHTMLWithHttpInfoAsync(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content
        /// </summary>
        /// <remarks>
        /// Retrieve email content as HTML response. Decodes quoted-printable entities and converts charset to UTF-8. Returns content-type &#x60;application/json;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailHtmlDto</returns>
        System.Threading.Tasks.Task<EmailHtmlDto> GetEmailHTMLJsonAsync(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content
        /// </summary>
        /// <remarks>
        /// Retrieve email content as HTML response. Decodes quoted-printable entities and converts charset to UTF-8. Returns content-type &#x60;application/json;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailHtmlDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailHtmlDto>> GetEmailHTMLJsonWithHttpInfoAsync(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters
        /// </summary>
        /// <remarks>
        /// Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to perform HTML query on</param>
        /// <param name="htmlSelector">HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailTextLinesResult</returns>
        System.Threading.Tasks.Task<EmailTextLinesResult> GetEmailHTMLQueryAsync(Guid emailId, string htmlSelector, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters
        /// </summary>
        /// <remarks>
        /// Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to perform HTML query on</param>
        /// <param name="htmlSelector">HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailTextLinesResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailTextLinesResult>> GetEmailHTMLQueryWithHttpInfoAsync(Guid emailId, string htmlSelector, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Parse and return list of links found in an email (only works for HTML content)
        /// </summary>
        /// <remarks>
        /// HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="selector">Optional HTML query selector for links (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailLinksResult</returns>
        System.Threading.Tasks.Task<EmailLinksResult> GetEmailLinksAsync(Guid emailId, string selector = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Parse and return list of links found in an email (only works for HTML content)
        /// </summary>
        /// <remarks>
        /// HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="selector">Optional HTML query selector for links (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailLinksResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailLinksResult>> GetEmailLinksWithHttpInfoAsync(Guid emailId, string selector = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email URLs for viewing in browser or downloading
        /// </summary>
        /// <remarks>
        /// Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailPreviewUrls</returns>
        System.Threading.Tasks.Task<EmailPreviewUrls> GetEmailPreviewURLsAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email URLs for viewing in browser or downloading
        /// </summary>
        /// <remarks>
        /// Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailPreviewUrls)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailPreviewUrls>> GetEmailPreviewURLsWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Take a screenshot of an email in a browser and return base64 encoded string
        /// </summary>
        /// <remarks>
        /// Capture image of email screenshot and return as base64 encoded string. Useful for embedding in HTML. Be careful as this may contain sensitive information.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailScreenshotResult</returns>
        System.Threading.Tasks.Task<EmailScreenshotResult> GetEmailScreenshotAsBase64Async(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Take a screenshot of an email in a browser and return base64 encoded string
        /// </summary>
        /// <remarks>
        /// Capture image of email screenshot and return as base64 encoded string. Useful for embedding in HTML. Be careful as this may contain sensitive information.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailScreenshotResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailScreenshotResult>> GetEmailScreenshotAsBase64WithHttpInfoAsync(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Take a screenshot of an email in a browser
        /// </summary>
        /// <remarks>
        /// Returns binary octet-stream of screenshot of the given email
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GetEmailScreenshotAsBinaryAsync(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Take a screenshot of an email in a browser
        /// </summary>
        /// <remarks>
        /// Returns binary octet-stream of screenshot of the given email
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetEmailScreenshotAsBinaryWithHttpInfoAsync(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get email data including headers but not body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
        /// </summary>
        /// <remarks>
        /// Returns a email summary object with headers. To retrieve the body see getEmail and to get raw unparsed email use the getRawEmail endpoints
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="decode"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailPreview</returns>
        System.Threading.Tasks.Task<EmailPreview> GetEmailSummaryAsync(Guid emailId, bool? decode = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email data including headers but not body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
        /// </summary>
        /// <remarks>
        /// Returns a email summary object with headers. To retrieve the body see getEmail and to get raw unparsed email use the getRawEmail endpoints
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="decode"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailPreview)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailPreview>> GetEmailSummaryWithHttpInfoAsync(Guid emailId, bool? decode = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters
        /// </summary>
        /// <remarks>
        /// Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="decodeHtmlEntities">Decode HTML entities (optional)</param>
        /// <param name="lineSeparator">Line separator character (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailTextLinesResult</returns>
        System.Threading.Tasks.Task<EmailTextLinesResult> GetEmailTextLinesAsync(Guid emailId, bool? decodeHtmlEntities = default, string lineSeparator = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters
        /// </summary>
        /// <remarks>
        /// Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="decodeHtmlEntities">Decode HTML entities (optional)</param>
        /// <param name="lineSeparator">Line separator character (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailTextLinesResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailTextLinesResult>> GetEmailTextLinesWithHttpInfoAsync(Guid emailId, bool? decodeHtmlEntities = default, string lineSeparator = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Return email thread information. Use items endpoints to get messages for thread.
        /// </summary>
        /// <remarks>
        /// Return email message thread summary from Message-ID, In-Reply-To, and References header. Get messages using items endpoint
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailThreadDto</returns>
        System.Threading.Tasks.Task<EmailThreadDto> GetEmailThreadAsync(Guid threadId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Return email thread information. Use items endpoints to get messages for thread.
        /// </summary>
        /// <remarks>
        /// Return email message thread summary from Message-ID, In-Reply-To, and References header. Get messages using items endpoint
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailThreadDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailThreadDto>> GetEmailThreadWithHttpInfoAsync(Guid threadId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Return email thread items.
        /// </summary>
        /// <remarks>
        /// Return email thread messages based on Message-ID, In-Reply-To, and References header
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailThreadItemsDto</returns>
        System.Threading.Tasks.Task<EmailThreadItemsDto> GetEmailThreadItemsAsync(Guid threadId, string sort = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Return email thread items.
        /// </summary>
        /// <remarks>
        /// Return email thread messages based on Message-ID, In-Reply-To, and References header
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailThreadItemsDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailThreadItemsDto>> GetEmailThreadItemsWithHttpInfoAsync(Guid threadId, string sort = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Return email threads in paginated form
        /// </summary>
        /// <remarks>
        /// Return email message chains built from Message-ID, In-Reply-To, and References header.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="htmlSelector">Optional inbox filter (optional)</param>
        /// <param name="page">Optional page index in email thread pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email thread pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter search filter for email threads. (optional)</param>
        /// <param name="since">Optional filter email threads created since time (optional)</param>
        /// <param name="before">Optional filter emails threads created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageEmailThreadProjection</returns>
        System.Threading.Tasks.Task<PageEmailThreadProjection> GetEmailThreadsAsync(Guid? htmlSelector = default, int? page = default, int? size = default, string sort = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Return email threads in paginated form
        /// </summary>
        /// <remarks>
        /// Return email message chains built from Message-ID, In-Reply-To, and References header.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="htmlSelector">Optional inbox filter (optional)</param>
        /// <param name="page">Optional page index in email thread pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email thread pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter search filter for email threads. (optional)</param>
        /// <param name="since">Optional filter email threads created since time (optional)</param>
        /// <param name="before">Optional filter emails threads created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageEmailThreadProjection)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageEmailThreadProjection>> GetEmailThreadsWithHttpInfoAsync(Guid? htmlSelector = default, int? page = default, int? size = default, string sort = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all.
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageEmailProjection</returns>
        System.Threading.Tasks.Task<PageEmailProjection> GetEmailsOffsetPaginatedAsync(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? favourited = default, bool? syncConnectors = default, Guid? plusAddressId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all.
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageEmailProjection)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageEmailProjection>> GetEmailsOffsetPaginatedWithHttpInfoAsync(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? favourited = default, bool? syncConnectors = default, Guid? plusAddressId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all.
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageEmailProjection</returns>
        System.Threading.Tasks.Task<PageEmailProjection> GetEmailsPaginatedAsync(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, Guid? plusAddressId = default, bool? favourited = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all.
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageEmailProjection)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageEmailProjection>> GetEmailsPaginatedWithHttpInfoAsync(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, Guid? plusAddressId = default, bool? favourited = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get gravatar url for email address
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="size"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GravatarUrl</returns>
        System.Threading.Tasks.Task<GravatarUrl> GetGravatarUrlForEmailAddressAsync(string emailAddress, string size = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Get gravatar url for email address
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="size"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GravatarUrl)</returns>
        System.Threading.Tasks.Task<ApiResponse<GravatarUrl>> GetGravatarUrlForEmailAddressWithHttpInfoAsync(string emailAddress, string size = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get latest email in all inboxes. Most recently received.
        /// </summary>
        /// <remarks>
        /// Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxIds">Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        System.Threading.Tasks.Task<Email> GetLatestEmailAsync(List<Guid> inboxIds = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get latest email in all inboxes. Most recently received.
        /// </summary>
        /// <remarks>
        /// Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxIds">Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        System.Threading.Tasks.Task<ApiResponse<Email>> GetLatestEmailWithHttpInfoAsync(List<Guid> inboxIds = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.
        /// </summary>
        /// <remarks>
        /// Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        System.Threading.Tasks.Task<Email> GetLatestEmailInInbox1Async(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.
        /// </summary>
        /// <remarks>
        /// Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        System.Threading.Tasks.Task<ApiResponse<Email>> GetLatestEmailInInbox1WithHttpInfoAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get all organization emails. List team or shared test email accounts
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter search filter for emails. (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favorited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageEmailProjection</returns>
        System.Threading.Tasks.Task<PageEmailProjection> GetOrganizationEmailsPaginatedAsync(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all organization emails. List team or shared test email accounts
        /// </summary>
        /// <remarks>
        /// By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter search filter for emails. (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favorited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageEmailProjection)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageEmailProjection>> GetOrganizationEmailsPaginatedWithHttpInfoAsync(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get raw email string. Returns unparsed raw SMTP message with headers and body.
        /// </summary>
        /// <remarks>
        /// Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GetRawEmailContentsAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get raw email string. Returns unparsed raw SMTP message with headers and body.
        /// </summary>
        /// <remarks>
        /// Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetRawEmailContentsWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
        /// </summary>
        /// <remarks>
        /// Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RawEmailJson</returns>
        System.Threading.Tasks.Task<RawEmailJson> GetRawEmailJsonAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
        /// </summary>
        /// <remarks>
        /// Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RawEmailJson)</returns>
        System.Threading.Tasks.Task<ApiResponse<RawEmailJson>> GetRawEmailJsonWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get unread email count
        /// </summary>
        /// <remarks>
        /// Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UnreadCount</returns>
        System.Threading.Tasks.Task<UnreadCount> GetUnreadEmailCountAsync(Guid? inboxId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get unread email count
        /// </summary>
        /// <remarks>
        /// Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UnreadCount)</returns>
        System.Threading.Tasks.Task<ApiResponse<UnreadCount>> GetUnreadEmailCountWithHttpInfoAsync(Guid? inboxId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Mark all emails as read or unread
        /// </summary>
        /// <remarks>
        /// Marks all emails as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task MarkAllAsReadAsync(bool? read = default, Guid? inboxId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Mark all emails as read or unread
        /// </summary>
        /// <remarks>
        /// Marks all emails as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> MarkAllAsReadWithHttpInfoAsync(bool? read = default, Guid? inboxId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Mark an email as read or unread
        /// </summary>
        /// <remarks>
        /// Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailPreview</returns>
        System.Threading.Tasks.Task<EmailPreview> MarkAsReadAsync(Guid emailId, bool? read = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Mark an email as read or unread
        /// </summary>
        /// <remarks>
        /// Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailPreview)</returns>
        System.Threading.Tasks.Task<ApiResponse<EmailPreview>> MarkAsReadWithHttpInfoAsync(Guid emailId, bool? read = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Reply to an email
        /// </summary>
        /// <remarks>
        /// Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails &#x60;to&#x60;, &#x60;cc&#x60;, and &#x60;bcc&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of the email that should be replied to</param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SentEmailDto</returns>
        System.Threading.Tasks.Task<SentEmailDto> ReplyToEmailAsync(Guid emailId, ReplyToEmailOptions replyToEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reply to an email
        /// </summary>
        /// <remarks>
        /// Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails &#x60;to&#x60;, &#x60;cc&#x60;, and &#x60;bcc&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of the email that should be replied to</param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SentEmailDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<SentEmailDto>> ReplyToEmailWithHttpInfoAsync(Guid emailId, ReplyToEmailOptions replyToEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get all emails by search criteria. Return in paginated form.
        /// </summary>
        /// <remarks>
        /// Search emails by given criteria return matches in paginated format. Searches against email recipients, sender, subject, email address and ID. Does not search email body
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favourited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageEmailProjection</returns>
        System.Threading.Tasks.Task<PageEmailProjection> SearchEmailsAsync(SearchEmailsOptions searchEmailsOptions, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all emails by search criteria. Return in paginated form.
        /// </summary>
        /// <remarks>
        /// Search emails by given criteria return matches in paginated format. Searches against email recipients, sender, subject, email address and ID. Does not search email body
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favourited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageEmailProjection)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageEmailProjection>> SearchEmailsWithHttpInfoAsync(SearchEmailsOptions searchEmailsOptions, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Send email
        /// </summary>
        /// <remarks>
        /// Alias for &#x60;InboxController.sendEmail&#x60; method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId">ID of the inbox you want to send the email from (optional)</param>
        /// <param name="useDomainPool">Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)</param>
        /// <param name="virtualSend">Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SendEmailSourceOptionalAsync(SendEmailOptions sendEmailOptions, Guid? inboxId = default, bool? useDomainPool = default, bool? virtualSend = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send email
        /// </summary>
        /// <remarks>
        /// Alias for &#x60;InboxController.sendEmail&#x60; method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId">ID of the inbox you want to send the email from (optional)</param>
        /// <param name="useDomainPool">Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)</param>
        /// <param name="virtualSend">Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SendEmailSourceOptionalWithHttpInfoAsync(SendEmailOptions sendEmailOptions, Guid? inboxId = default, bool? useDomainPool = default, bool? virtualSend = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Set email favourited state
        /// </summary>
        /// <remarks>
        /// Set and return new favorite state for an email
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to set favourite state</param>
        /// <param name="favourited"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SetEmailFavouritedAsync(Guid emailId, bool favourited, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set email favourited state
        /// </summary>
        /// <remarks>
        /// Set and return new favorite state for an email
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to set favourite state</param>
        /// <param name="favourited"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SetEmailFavouritedWithHttpInfoAsync(Guid emailId, bool favourited, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Validate email HTML contents
        /// </summary>
        /// <remarks>
        /// Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ValidationDto</returns>
        System.Threading.Tasks.Task<ValidationDto> ValidateEmailAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Validate email HTML contents
        /// </summary>
        /// <remarks>
        /// Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ValidationDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<ValidationDto>> ValidateEmailWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEmailControllerApi : IEmailControllerApiSync, IEmailControllerApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class EmailControllerApi : IEmailControllerApi
    {
        private mailslurp.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="EmailControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public EmailControllerApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EmailControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public EmailControllerApi(string basePath)
        {
            this.Configuration = mailslurp.Client.Configuration.MergeConfigurations(
                mailslurp.Client.GlobalConfiguration.Instance,
                new mailslurp.Client.Configuration { BasePath = basePath }
            );
            this.Client = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EmailControllerApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public EmailControllerApi(mailslurp.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = mailslurp.Client.Configuration.MergeConfigurations(
                mailslurp.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EmailControllerApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public EmailControllerApi(mailslurp.Client.ISynchronousClient client, mailslurp.Client.IAsynchronousClient asyncClient, mailslurp.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public mailslurp.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public mailslurp.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public mailslurp.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public mailslurp.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag. Apply RFC3501 section-2.3.2 IMAP flag operations on an email
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailPreview</returns>
        public EmailPreview ApplyImapFlagOperation(Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailPreview> localVarResponse = ApplyImapFlagOperationWithHttpInfo(emailId, imapFlagOperationOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag. Apply RFC3501 section-2.3.2 IMAP flag operations on an email
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailPreview</returns>
        public mailslurp.Client.ApiResponse<EmailPreview> ApplyImapFlagOperationWithHttpInfo(Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions, int operationIndex = 0)
        {
            // verify the required parameter 'imapFlagOperationOptions' is set
            if (imapFlagOperationOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'imapFlagOperationOptions' when calling EmailControllerApi->ApplyImapFlagOperation");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.Data = imapFlagOperationOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.ApplyImapFlagOperation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<EmailPreview>("/emails/{emailId}/imap-flag-operation", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ApplyImapFlagOperation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag. Apply RFC3501 section-2.3.2 IMAP flag operations on an email
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailPreview</returns>
        public async System.Threading.Tasks.Task<EmailPreview> ApplyImapFlagOperationAsync(Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailPreview> localVarResponse = await ApplyImapFlagOperationWithHttpInfoAsync(emailId, imapFlagOperationOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag. Apply RFC3501 section-2.3.2 IMAP flag operations on an email
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="imapFlagOperationOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailPreview)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailPreview>> ApplyImapFlagOperationWithHttpInfoAsync(Guid emailId, ImapFlagOperationOptions imapFlagOperationOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'imapFlagOperationOptions' is set
            if (imapFlagOperationOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'imapFlagOperationOptions' when calling EmailControllerApi->ApplyImapFlagOperation");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.Data = imapFlagOperationOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.ApplyImapFlagOperation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<EmailPreview>("/emails/{emailId}/imap-flag-operation", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ApplyImapFlagOperation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check if email can be sent and options are valid. Can user send email to given recipient or is the recipient blocked
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CanSendEmailResults</returns>
        public CanSendEmailResults CanSend(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<CanSendEmailResults> localVarResponse = CanSendWithHttpInfo(inboxId, sendEmailOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check if email can be sent and options are valid. Can user send email to given recipient or is the recipient blocked
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CanSendEmailResults</returns>
        public mailslurp.Client.ApiResponse<CanSendEmailResults> CanSendWithHttpInfo(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0)
        {
            // verify the required parameter 'sendEmailOptions' is set
            if (sendEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendEmailOptions' when calling EmailControllerApi->CanSend");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            localVarRequestOptions.Data = sendEmailOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.CanSend";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CanSendEmailResults>("/emails/can-send", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CanSend", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check if email can be sent and options are valid. Can user send email to given recipient or is the recipient blocked
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CanSendEmailResults</returns>
        public async System.Threading.Tasks.Task<CanSendEmailResults> CanSendAsync(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<CanSendEmailResults> localVarResponse = await CanSendWithHttpInfoAsync(inboxId, sendEmailOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check if email can be sent and options are valid. Can user send email to given recipient or is the recipient blocked
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to send the email from</param>
        /// <param name="sendEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CanSendEmailResults)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<CanSendEmailResults>> CanSendWithHttpInfoAsync(Guid inboxId, SendEmailOptions sendEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'sendEmailOptions' is set
            if (sendEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendEmailOptions' when calling EmailControllerApi->CanSend");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            localVarRequestOptions.Data = sendEmailOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.CanSend";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<CanSendEmailResults>("/emails/can-send", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CanSend", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Detect broken links, spelling, and images in email content Find dead links, broken images, and spelling mistakes in email body. Will call included links via HTTP so do not invoke if your links are sensitive or stateful. Any resource that returns a 4xx or 5xx response or is not reachable via HEAD or GET HTTP operations will be considered unhealthy.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CheckEmailBodyResults</returns>
        public CheckEmailBodyResults CheckEmailBody(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<CheckEmailBodyResults> localVarResponse = CheckEmailBodyWithHttpInfo(emailId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Detect broken links, spelling, and images in email content Find dead links, broken images, and spelling mistakes in email body. Will call included links via HTTP so do not invoke if your links are sensitive or stateful. Any resource that returns a 4xx or 5xx response or is not reachable via HEAD or GET HTTP operations will be considered unhealthy.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CheckEmailBodyResults</returns>
        public mailslurp.Client.ApiResponse<CheckEmailBodyResults> CheckEmailBodyWithHttpInfo(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.CheckEmailBody";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CheckEmailBodyResults>("/emails/{emailId}/check-email-body", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CheckEmailBody", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Detect broken links, spelling, and images in email content Find dead links, broken images, and spelling mistakes in email body. Will call included links via HTTP so do not invoke if your links are sensitive or stateful. Any resource that returns a 4xx or 5xx response or is not reachable via HEAD or GET HTTP operations will be considered unhealthy.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CheckEmailBodyResults</returns>
        public async System.Threading.Tasks.Task<CheckEmailBodyResults> CheckEmailBodyAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<CheckEmailBodyResults> localVarResponse = await CheckEmailBodyWithHttpInfoAsync(emailId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Detect broken links, spelling, and images in email content Find dead links, broken images, and spelling mistakes in email body. Will call included links via HTTP so do not invoke if your links are sensitive or stateful. Any resource that returns a 4xx or 5xx response or is not reachable via HEAD or GET HTTP operations will be considered unhealthy.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CheckEmailBodyResults)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<CheckEmailBodyResults>> CheckEmailBodyWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.CheckEmailBody";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<CheckEmailBodyResults>("/emails/{emailId}/check-email-body", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CheckEmailBody", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Show which mail clients support the HTML and CSS features used in an email body. Detect HTML and CSS features inside an email body and return a report of email client support across different platforms and versions.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CheckEmailBodyFeatureSupportResults</returns>
        public CheckEmailBodyFeatureSupportResults CheckEmailBodyFeatureSupport(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<CheckEmailBodyFeatureSupportResults> localVarResponse = CheckEmailBodyFeatureSupportWithHttpInfo(emailId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Show which mail clients support the HTML and CSS features used in an email body. Detect HTML and CSS features inside an email body and return a report of email client support across different platforms and versions.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CheckEmailBodyFeatureSupportResults</returns>
        public mailslurp.Client.ApiResponse<CheckEmailBodyFeatureSupportResults> CheckEmailBodyFeatureSupportWithHttpInfo(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.CheckEmailBodyFeatureSupport";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CheckEmailBodyFeatureSupportResults>("/emails/{emailId}/check-email-body-feature-support", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CheckEmailBodyFeatureSupport", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Show which mail clients support the HTML and CSS features used in an email body. Detect HTML and CSS features inside an email body and return a report of email client support across different platforms and versions.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CheckEmailBodyFeatureSupportResults</returns>
        public async System.Threading.Tasks.Task<CheckEmailBodyFeatureSupportResults> CheckEmailBodyFeatureSupportAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<CheckEmailBodyFeatureSupportResults> localVarResponse = await CheckEmailBodyFeatureSupportWithHttpInfoAsync(emailId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Show which mail clients support the HTML and CSS features used in an email body. Detect HTML and CSS features inside an email body and return a report of email client support across different platforms and versions.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CheckEmailBodyFeatureSupportResults)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<CheckEmailBodyFeatureSupportResults>> CheckEmailBodyFeatureSupportWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.CheckEmailBodyFeatureSupport";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<CheckEmailBodyFeatureSupportResults>("/emails/{emailId}/check-email-body-feature-support", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CheckEmailBodyFeatureSupport", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Show which email programs and devices support the features used in an email body. Evaluate the features used in an email body and return a report of email client support across different platforms and versions.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CheckEmailClientSupportResults</returns>
        public CheckEmailClientSupportResults CheckEmailClientSupport(CheckEmailClientSupportOptions checkEmailClientSupportOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<CheckEmailClientSupportResults> localVarResponse = CheckEmailClientSupportWithHttpInfo(checkEmailClientSupportOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Show which email programs and devices support the features used in an email body. Evaluate the features used in an email body and return a report of email client support across different platforms and versions.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CheckEmailClientSupportResults</returns>
        public mailslurp.Client.ApiResponse<CheckEmailClientSupportResults> CheckEmailClientSupportWithHttpInfo(CheckEmailClientSupportOptions checkEmailClientSupportOptions, int operationIndex = 0)
        {
            // verify the required parameter 'checkEmailClientSupportOptions' is set
            if (checkEmailClientSupportOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'checkEmailClientSupportOptions' when calling EmailControllerApi->CheckEmailClientSupport");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = checkEmailClientSupportOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.CheckEmailClientSupport";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CheckEmailClientSupportResults>("/emails/check-email-client-support", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CheckEmailClientSupport", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Show which email programs and devices support the features used in an email body. Evaluate the features used in an email body and return a report of email client support across different platforms and versions.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CheckEmailClientSupportResults</returns>
        public async System.Threading.Tasks.Task<CheckEmailClientSupportResults> CheckEmailClientSupportAsync(CheckEmailClientSupportOptions checkEmailClientSupportOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<CheckEmailClientSupportResults> localVarResponse = await CheckEmailClientSupportWithHttpInfoAsync(checkEmailClientSupportOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Show which email programs and devices support the features used in an email body. Evaluate the features used in an email body and return a report of email client support across different platforms and versions.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="checkEmailClientSupportOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CheckEmailClientSupportResults)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<CheckEmailClientSupportResults>> CheckEmailClientSupportWithHttpInfoAsync(CheckEmailClientSupportOptions checkEmailClientSupportOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'checkEmailClientSupportOptions' is set
            if (checkEmailClientSupportOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'checkEmailClientSupportOptions' when calling EmailControllerApi->CheckEmailClientSupport");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = checkEmailClientSupportOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.CheckEmailClientSupport";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<CheckEmailClientSupportResults>("/emails/check-email-client-support", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CheckEmailClientSupport", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete all emails in all inboxes. Deletes all emails in your account. Be careful as emails cannot be recovered
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteAllEmails(int operationIndex = 0)
        {
            DeleteAllEmailsWithHttpInfo();
        }

        /// <summary>
        /// Delete all emails in all inboxes. Deletes all emails in your account. Be careful as emails cannot be recovered
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> DeleteAllEmailsWithHttpInfo(int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "EmailControllerApi.DeleteAllEmails";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/emails", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAllEmails", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete all emails in all inboxes. Deletes all emails in your account. Be careful as emails cannot be recovered
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteAllEmailsAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            await DeleteAllEmailsWithHttpInfoAsync(operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete all emails in all inboxes. Deletes all emails in your account. Be careful as emails cannot be recovered
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> DeleteAllEmailsWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "EmailControllerApi.DeleteAllEmails";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/emails", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAllEmails", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete an email Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteEmail(Guid emailId, int operationIndex = 0)
        {
            DeleteEmailWithHttpInfo(emailId);
        }

        /// <summary>
        /// Delete an email Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> DeleteEmailWithHttpInfo(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.DeleteEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/emails/{emailId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete an email Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteEmailAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            await DeleteEmailWithHttpInfoAsync(emailId, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete an email Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> DeleteEmailWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.DeleteEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/emails/{emailId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string. Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="apiKey">Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>byte[]</returns>
        public byte[] DownloadAttachment(Guid emailId, string attachmentId, string apiKey = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<byte[]> localVarResponse = DownloadAttachmentWithHttpInfo(emailId, attachmentId, apiKey);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string. Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="apiKey">Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of byte[]</returns>
        public mailslurp.Client.ApiResponse<byte[]> DownloadAttachmentWithHttpInfo(Guid emailId, string attachmentId, string apiKey = default, int operationIndex = 0)
        {
            // verify the required parameter 'attachmentId' is set
            if (attachmentId == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'attachmentId' when calling EmailControllerApi->DownloadAttachment");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/octet-stream"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachmentId", mailslurp.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter
            if (apiKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "apiKey", apiKey));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.DownloadAttachment";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<byte[]>("/emails/{emailId}/attachments/{attachmentId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DownloadAttachment", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string. Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="apiKey">Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of byte[]</returns>
        public async System.Threading.Tasks.Task<byte[]> DownloadAttachmentAsync(Guid emailId, string attachmentId, string apiKey = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<byte[]> localVarResponse = await DownloadAttachmentWithHttpInfoAsync(emailId, attachmentId, apiKey, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string. Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="apiKey">Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (byte[])</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<byte[]>> DownloadAttachmentWithHttpInfoAsync(Guid emailId, string attachmentId, string apiKey = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'attachmentId' is set
            if (attachmentId == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'attachmentId' when calling EmailControllerApi->DownloadAttachment");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/octet-stream"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachmentId", mailslurp.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter
            if (apiKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "apiKey", apiKey));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.DownloadAttachment";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<byte[]>("/emails/{emailId}/attachments/{attachmentId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DownloadAttachment", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;. Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DownloadAttachmentDto</returns>
        public DownloadAttachmentDto DownloadAttachmentBase64(Guid emailId, string attachmentId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<DownloadAttachmentDto> localVarResponse = DownloadAttachmentBase64WithHttpInfo(emailId, attachmentId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;. Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DownloadAttachmentDto</returns>
        public mailslurp.Client.ApiResponse<DownloadAttachmentDto> DownloadAttachmentBase64WithHttpInfo(Guid emailId, string attachmentId, int operationIndex = 0)
        {
            // verify the required parameter 'attachmentId' is set
            if (attachmentId == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'attachmentId' when calling EmailControllerApi->DownloadAttachmentBase64");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachmentId", mailslurp.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.DownloadAttachmentBase64";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<DownloadAttachmentDto>("/emails/{emailId}/attachments/{attachmentId}/base64", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DownloadAttachmentBase64", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;. Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DownloadAttachmentDto</returns>
        public async System.Threading.Tasks.Task<DownloadAttachmentDto> DownloadAttachmentBase64Async(Guid emailId, string attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<DownloadAttachmentDto> localVarResponse = await DownloadAttachmentBase64WithHttpInfoAsync(emailId, attachmentId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;. Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DownloadAttachmentDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<DownloadAttachmentDto>> DownloadAttachmentBase64WithHttpInfoAsync(Guid emailId, string attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'attachmentId' is set
            if (attachmentId == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'attachmentId' when calling EmailControllerApi->DownloadAttachmentBase64");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachmentId", mailslurp.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.DownloadAttachmentBase64";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<DownloadAttachmentDto>("/emails/{emailId}/attachments/{attachmentId}/base64", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DownloadAttachmentBase64", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email body as string. Returned as &#x60;plain/text&#x60; with content type header. Returns the specified email body for a given email as a string
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        public string DownloadBody(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<string> localVarResponse = DownloadBodyWithHttpInfo(emailId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email body as string. Returned as &#x60;plain/text&#x60; with content type header. Returns the specified email body for a given email as a string
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        public mailslurp.Client.ApiResponse<string> DownloadBodyWithHttpInfo(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "text/html"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.DownloadBody";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<string>("/emails/{emailId}/body", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DownloadBody", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email body as string. Returned as &#x60;plain/text&#x60; with content type header. Returns the specified email body for a given email as a string
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> DownloadBodyAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<string> localVarResponse = await DownloadBodyWithHttpInfoAsync(emailId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email body as string. Returned as &#x60;plain/text&#x60; with content type header. Returns the specified email body for a given email as a string
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<string>> DownloadBodyWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "text/html"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.DownloadBody";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<string>("/emails/{emailId}/body", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DownloadBody", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header. Returns the specified email body for a given email as a stream / array of bytes.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>byte[]</returns>
        public byte[] DownloadBodyBytes(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<byte[]> localVarResponse = DownloadBodyBytesWithHttpInfo(emailId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header. Returns the specified email body for a given email as a stream / array of bytes.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of byte[]</returns>
        public mailslurp.Client.ApiResponse<byte[]> DownloadBodyBytesWithHttpInfo(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/octet-stream"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.DownloadBodyBytes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<byte[]>("/emails/{emailId}/body-bytes", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DownloadBodyBytes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header. Returns the specified email body for a given email as a stream / array of bytes.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of byte[]</returns>
        public async System.Threading.Tasks.Task<byte[]> DownloadBodyBytesAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<byte[]> localVarResponse = await DownloadBodyBytesWithHttpInfoAsync(emailId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header. Returns the specified email body for a given email as a stream / array of bytes.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (byte[])</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<byte[]>> DownloadBodyBytesWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/octet-stream"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.DownloadBodyBytes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<byte[]>("/emails/{emailId}/body-bytes", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DownloadBodyBytes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Forward email to recipients Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the &#x60;from&#x60; option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="forwardEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SentEmailDto</returns>
        public SentEmailDto ForwardEmail(Guid emailId, ForwardEmailOptions forwardEmailOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<SentEmailDto> localVarResponse = ForwardEmailWithHttpInfo(emailId, forwardEmailOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Forward email to recipients Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the &#x60;from&#x60; option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="forwardEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SentEmailDto</returns>
        public mailslurp.Client.ApiResponse<SentEmailDto> ForwardEmailWithHttpInfo(Guid emailId, ForwardEmailOptions forwardEmailOptions, int operationIndex = 0)
        {
            // verify the required parameter 'forwardEmailOptions' is set
            if (forwardEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'forwardEmailOptions' when calling EmailControllerApi->ForwardEmail");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.Data = forwardEmailOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.ForwardEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SentEmailDto>("/emails/{emailId}/forward", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ForwardEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Forward email to recipients Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the &#x60;from&#x60; option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="forwardEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SentEmailDto</returns>
        public async System.Threading.Tasks.Task<SentEmailDto> ForwardEmailAsync(Guid emailId, ForwardEmailOptions forwardEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<SentEmailDto> localVarResponse = await ForwardEmailWithHttpInfoAsync(emailId, forwardEmailOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Forward email to recipients Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the &#x60;from&#x60; option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="forwardEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SentEmailDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<SentEmailDto>> ForwardEmailWithHttpInfoAsync(Guid emailId, ForwardEmailOptions forwardEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'forwardEmailOptions' is set
            if (forwardEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'forwardEmailOptions' when calling EmailControllerApi->ForwardEmail");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.Data = forwardEmailOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.ForwardEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SentEmailDto>("/emails/{emailId}/forward", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ForwardEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods. Returns the metadata such as name and content-type for a given attachment and email.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>AttachmentMetaData</returns>
        public AttachmentMetaData GetAttachmentMetaData(Guid emailId, string attachmentId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<AttachmentMetaData> localVarResponse = GetAttachmentMetaDataWithHttpInfo(emailId, attachmentId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods. Returns the metadata such as name and content-type for a given attachment and email.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of AttachmentMetaData</returns>
        public mailslurp.Client.ApiResponse<AttachmentMetaData> GetAttachmentMetaDataWithHttpInfo(Guid emailId, string attachmentId, int operationIndex = 0)
        {
            // verify the required parameter 'attachmentId' is set
            if (attachmentId == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'attachmentId' when calling EmailControllerApi->GetAttachmentMetaData");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachmentId", mailslurp.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetAttachmentMetaData";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<AttachmentMetaData>("/emails/{emailId}/attachments/{attachmentId}/metadata", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAttachmentMetaData", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods. Returns the metadata such as name and content-type for a given attachment and email.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AttachmentMetaData</returns>
        public async System.Threading.Tasks.Task<AttachmentMetaData> GetAttachmentMetaDataAsync(Guid emailId, string attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<AttachmentMetaData> localVarResponse = await GetAttachmentMetaDataWithHttpInfoAsync(emailId, attachmentId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods. Returns the metadata such as name and content-type for a given attachment and email.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AttachmentMetaData)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<AttachmentMetaData>> GetAttachmentMetaDataWithHttpInfoAsync(Guid emailId, string attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'attachmentId' is set
            if (attachmentId == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'attachmentId' when calling EmailControllerApi->GetAttachmentMetaData");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachmentId", mailslurp.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetAttachmentMetaData";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<AttachmentMetaData>("/emails/{emailId}/attachments/{attachmentId}/metadata", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAttachmentMetaData", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController. Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        public Email GetEmail(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = GetEmailWithHttpInfo(emailId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController. Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        public mailslurp.Client.ApiResponse<Email> GetEmailWithHttpInfo(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json;charset=UTF-8",
                "application/xml;charset=UTF-8",
                "application/json; charset=UTF-8",
                "application/xml; charset=UTF-8"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Email>("/emails/{emailId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController. Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        public async System.Threading.Tasks.Task<Email> GetEmailAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = await GetEmailWithHttpInfoAsync(emailId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController. Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Email>> GetEmailWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json;charset=UTF-8",
                "application/xml;charset=UTF-8",
                "application/json; charset=UTF-8",
                "application/xml; charset=UTF-8"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Email>("/emails/{emailId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all email attachment metadata. Metadata includes name and size of attachments. Returns an array of attachment metadata such as name and content-type for a given email if present.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;AttachmentMetaData&gt;</returns>
        public List<AttachmentMetaData> GetEmailAttachments(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<List<AttachmentMetaData>> localVarResponse = GetEmailAttachmentsWithHttpInfo(emailId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all email attachment metadata. Metadata includes name and size of attachments. Returns an array of attachment metadata such as name and content-type for a given email if present.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;AttachmentMetaData&gt;</returns>
        public mailslurp.Client.ApiResponse<List<AttachmentMetaData>> GetEmailAttachmentsWithHttpInfo(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailAttachments";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<AttachmentMetaData>>("/emails/{emailId}/attachments", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailAttachments", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all email attachment metadata. Metadata includes name and size of attachments. Returns an array of attachment metadata such as name and content-type for a given email if present.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;AttachmentMetaData&gt;</returns>
        public async System.Threading.Tasks.Task<List<AttachmentMetaData>> GetEmailAttachmentsAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<List<AttachmentMetaData>> localVarResponse = await GetEmailAttachmentsWithHttpInfoAsync(emailId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all email attachment metadata. Metadata includes name and size of attachments. Returns an array of attachment metadata such as name and content-type for a given email if present.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;AttachmentMetaData&gt;)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<List<AttachmentMetaData>>> GetEmailAttachmentsWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailAttachments";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<AttachmentMetaData>>("/emails/{emailId}/attachments", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailAttachments", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email content regex pattern match results. Runs regex against email body and returns match groups. Return the matches for a given Java style regex pattern. Do not include the typical &#x60;/&#x60; at start or end of regex in some languages. Given an example &#x60;your code is: 12345&#x60; the pattern to extract match looks like &#x60;code is: (\\d{6})&#x60;. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: &#x60;[&#39;code is: 123456&#39;, &#39;123456&#39;]&#x60; See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentMatchOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailContentMatchResult</returns>
        public EmailContentMatchResult GetEmailContentMatch(Guid emailId, ContentMatchOptions contentMatchOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailContentMatchResult> localVarResponse = GetEmailContentMatchWithHttpInfo(emailId, contentMatchOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email content regex pattern match results. Runs regex against email body and returns match groups. Return the matches for a given Java style regex pattern. Do not include the typical &#x60;/&#x60; at start or end of regex in some languages. Given an example &#x60;your code is: 12345&#x60; the pattern to extract match looks like &#x60;code is: (\\d{6})&#x60;. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: &#x60;[&#39;code is: 123456&#39;, &#39;123456&#39;]&#x60; See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentMatchOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailContentMatchResult</returns>
        public mailslurp.Client.ApiResponse<EmailContentMatchResult> GetEmailContentMatchWithHttpInfo(Guid emailId, ContentMatchOptions contentMatchOptions, int operationIndex = 0)
        {
            // verify the required parameter 'contentMatchOptions' is set
            if (contentMatchOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'contentMatchOptions' when calling EmailControllerApi->GetEmailContentMatch");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.Data = contentMatchOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailContentMatch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<EmailContentMatchResult>("/emails/{emailId}/contentMatch", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailContentMatch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email content regex pattern match results. Runs regex against email body and returns match groups. Return the matches for a given Java style regex pattern. Do not include the typical &#x60;/&#x60; at start or end of regex in some languages. Given an example &#x60;your code is: 12345&#x60; the pattern to extract match looks like &#x60;code is: (\\d{6})&#x60;. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: &#x60;[&#39;code is: 123456&#39;, &#39;123456&#39;]&#x60; See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentMatchOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailContentMatchResult</returns>
        public async System.Threading.Tasks.Task<EmailContentMatchResult> GetEmailContentMatchAsync(Guid emailId, ContentMatchOptions contentMatchOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailContentMatchResult> localVarResponse = await GetEmailContentMatchWithHttpInfoAsync(emailId, contentMatchOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email content regex pattern match results. Runs regex against email body and returns match groups. Return the matches for a given Java style regex pattern. Do not include the typical &#x60;/&#x60; at start or end of regex in some languages. Given an example &#x60;your code is: 12345&#x60; the pattern to extract match looks like &#x60;code is: (\\d{6})&#x60;. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: &#x60;[&#39;code is: 123456&#39;, &#39;123456&#39;]&#x60; See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentMatchOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailContentMatchResult)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailContentMatchResult>> GetEmailContentMatchWithHttpInfoAsync(Guid emailId, ContentMatchOptions contentMatchOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'contentMatchOptions' is set
            if (contentMatchOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'contentMatchOptions' when calling EmailControllerApi->GetEmailContentMatch");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.Data = contentMatchOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailContentMatch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<EmailContentMatchResult>("/emails/{emailId}/contentMatch", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailContentMatch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email content part by content type Get email body content parts from a multipart email message for a given content type
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailContentPartResult</returns>
        public EmailContentPartResult GetEmailContentPart(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailContentPartResult> localVarResponse = GetEmailContentPartWithHttpInfo(emailId, contentType, strict, index);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email content part by content type Get email body content parts from a multipart email message for a given content type
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailContentPartResult</returns>
        public mailslurp.Client.ApiResponse<EmailContentPartResult> GetEmailContentPartWithHttpInfo(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0)
        {
            // verify the required parameter 'contentType' is set
            if (contentType == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'contentType' when calling EmailControllerApi->GetEmailContentPart");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json;charset=UTF-8",
                "application/xml;charset=UTF-8",
                "application/json; charset=UTF-8",
                "application/xml; charset=UTF-8"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "contentType", contentType));
            if (strict != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "strict", strict));
            }
            if (index != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "index", index));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailContentPart";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<EmailContentPartResult>("/emails/{emailId}/contentPart", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailContentPart", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email content part by content type Get email body content parts from a multipart email message for a given content type
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailContentPartResult</returns>
        public async System.Threading.Tasks.Task<EmailContentPartResult> GetEmailContentPartAsync(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailContentPartResult> localVarResponse = await GetEmailContentPartWithHttpInfoAsync(emailId, contentType, strict, index, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email content part by content type Get email body content parts from a multipart email message for a given content type
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailContentPartResult)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailContentPartResult>> GetEmailContentPartWithHttpInfoAsync(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'contentType' is set
            if (contentType == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'contentType' when calling EmailControllerApi->GetEmailContentPart");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json;charset=UTF-8",
                "application/xml;charset=UTF-8",
                "application/json; charset=UTF-8",
                "application/xml; charset=UTF-8"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "contentType", contentType));
            if (strict != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "strict", strict));
            }
            if (index != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "index", index));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailContentPart";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EmailContentPartResult>("/emails/{emailId}/contentPart", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailContentPart", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email content part by content type raw response Get email body content parts from a multipart email message for a given content type and return as response
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple. Starts from 0 and applies to the result list after selecting for your content type. Content type parts are sorted by order found in original MIME message. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        public string GetEmailContentPartContent(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<string> localVarResponse = GetEmailContentPartContentWithHttpInfo(emailId, contentType, strict, index);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email content part by content type raw response Get email body content parts from a multipart email message for a given content type and return as response
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple. Starts from 0 and applies to the result list after selecting for your content type. Content type parts are sorted by order found in original MIME message. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        public mailslurp.Client.ApiResponse<string> GetEmailContentPartContentWithHttpInfo(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0)
        {
            // verify the required parameter 'contentType' is set
            if (contentType == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'contentType' when calling EmailControllerApi->GetEmailContentPartContent");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "contentType", contentType));
            if (strict != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "strict", strict));
            }
            if (index != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "index", index));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailContentPartContent";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<string>("/emails/{emailId}/contentPart/raw", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailContentPartContent", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email content part by content type raw response Get email body content parts from a multipart email message for a given content type and return as response
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple. Starts from 0 and applies to the result list after selecting for your content type. Content type parts are sorted by order found in original MIME message. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> GetEmailContentPartContentAsync(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<string> localVarResponse = await GetEmailContentPartContentWithHttpInfoAsync(emailId, contentType, strict, index, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email content part by content type raw response Get email body content parts from a multipart email message for a given content type and return as response
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to match against</param>
        /// <param name="contentType">Content type</param>
        /// <param name="strict">Strict content type match (optional)</param>
        /// <param name="index">Index of content type part if multiple. Starts from 0 and applies to the result list after selecting for your content type. Content type parts are sorted by order found in original MIME message. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<string>> GetEmailContentPartContentWithHttpInfoAsync(Guid emailId, string contentType, bool? strict = default, int? index = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'contentType' is set
            if (contentType == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'contentType' when calling EmailControllerApi->GetEmailContentPartContent");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "contentType", contentType));
            if (strict != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "strict", strict));
            }
            if (index != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "index", index));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailContentPartContent";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<string>("/emails/{emailId}/contentPart/raw", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailContentPartContent", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email count 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CountDto</returns>
        public CountDto GetEmailCount(Guid? inboxId = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<CountDto> localVarResponse = GetEmailCountWithHttpInfo(inboxId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email count 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CountDto</returns>
        public mailslurp.Client.ApiResponse<CountDto> GetEmailCountWithHttpInfo(Guid? inboxId = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailCount";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<CountDto>("/emails/emails/count", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailCount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email count 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountDto</returns>
        public async System.Threading.Tasks.Task<CountDto> GetEmailCountAsync(Guid? inboxId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<CountDto> localVarResponse = await GetEmailCountWithHttpInfoAsync(inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email count 
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<CountDto>> GetEmailCountWithHttpInfoAsync(Guid? inboxId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailCount";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<CountDto>("/emails/emails/count", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailCount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email content as HTML. For displaying emails in browser context. Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: &#x60;?apiKey&#x3D;xxx&#x60;. Returns content-type &#x60;text/html;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON. For JSON response see the &#x60;getEmailHTMLJson&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        public string GetEmailHTML(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<string> localVarResponse = GetEmailHTMLWithHttpInfo(emailId, replaceCidImages);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email content as HTML. For displaying emails in browser context. Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: &#x60;?apiKey&#x3D;xxx&#x60;. Returns content-type &#x60;text/html;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON. For JSON response see the &#x60;getEmailHTMLJson&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        public mailslurp.Client.ApiResponse<string> GetEmailHTMLWithHttpInfo(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/html;charset=utf-8",
                "text/html"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            if (replaceCidImages != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "replaceCidImages", replaceCidImages));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailHTML";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<string>("/emails/{emailId}/html", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailHTML", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email content as HTML. For displaying emails in browser context. Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: &#x60;?apiKey&#x3D;xxx&#x60;. Returns content-type &#x60;text/html;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON. For JSON response see the &#x60;getEmailHTMLJson&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> GetEmailHTMLAsync(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<string> localVarResponse = await GetEmailHTMLWithHttpInfoAsync(emailId, replaceCidImages, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email content as HTML. For displaying emails in browser context. Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: &#x60;?apiKey&#x3D;xxx&#x60;. Returns content-type &#x60;text/html;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON. For JSON response see the &#x60;getEmailHTMLJson&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<string>> GetEmailHTMLWithHttpInfoAsync(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/html;charset=utf-8",
                "text/html"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            if (replaceCidImages != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "replaceCidImages", replaceCidImages));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailHTML";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<string>("/emails/{emailId}/html", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailHTML", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content Retrieve email content as HTML response. Decodes quoted-printable entities and converts charset to UTF-8. Returns content-type &#x60;application/json;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailHtmlDto</returns>
        public EmailHtmlDto GetEmailHTMLJson(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailHtmlDto> localVarResponse = GetEmailHTMLJsonWithHttpInfo(emailId, replaceCidImages);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content Retrieve email content as HTML response. Decodes quoted-printable entities and converts charset to UTF-8. Returns content-type &#x60;application/json;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailHtmlDto</returns>
        public mailslurp.Client.ApiResponse<EmailHtmlDto> GetEmailHTMLJsonWithHttpInfo(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            if (replaceCidImages != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "replaceCidImages", replaceCidImages));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailHTMLJson";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<EmailHtmlDto>("/emails/{emailId}/html/json", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailHTMLJson", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content Retrieve email content as HTML response. Decodes quoted-printable entities and converts charset to UTF-8. Returns content-type &#x60;application/json;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailHtmlDto</returns>
        public async System.Threading.Tasks.Task<EmailHtmlDto> GetEmailHTMLJsonAsync(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailHtmlDto> localVarResponse = await GetEmailHTMLJsonWithHttpInfoAsync(emailId, replaceCidImages, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content Retrieve email content as HTML response. Decodes quoted-printable entities and converts charset to UTF-8. Returns content-type &#x60;application/json;charset&#x3D;utf-8&#x60; so you must call expecting that content response not JSON.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="replaceCidImages"> (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailHtmlDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailHtmlDto>> GetEmailHTMLJsonWithHttpInfoAsync(Guid emailId, bool? replaceCidImages = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            if (replaceCidImages != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "replaceCidImages", replaceCidImages));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailHTMLJson";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EmailHtmlDto>("/emails/{emailId}/html/json", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailHTMLJson", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to perform HTML query on</param>
        /// <param name="htmlSelector">HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailTextLinesResult</returns>
        public EmailTextLinesResult GetEmailHTMLQuery(Guid emailId, string htmlSelector, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailTextLinesResult> localVarResponse = GetEmailHTMLQueryWithHttpInfo(emailId, htmlSelector);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to perform HTML query on</param>
        /// <param name="htmlSelector">HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailTextLinesResult</returns>
        public mailslurp.Client.ApiResponse<EmailTextLinesResult> GetEmailHTMLQueryWithHttpInfo(Guid emailId, string htmlSelector, int operationIndex = 0)
        {
            // verify the required parameter 'htmlSelector' is set
            if (htmlSelector == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'htmlSelector' when calling EmailControllerApi->GetEmailHTMLQuery");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "htmlSelector", htmlSelector));

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailHTMLQuery";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<EmailTextLinesResult>("/emails/{emailId}/htmlQuery", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailHTMLQuery", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to perform HTML query on</param>
        /// <param name="htmlSelector">HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailTextLinesResult</returns>
        public async System.Threading.Tasks.Task<EmailTextLinesResult> GetEmailHTMLQueryAsync(Guid emailId, string htmlSelector, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailTextLinesResult> localVarResponse = await GetEmailHTMLQueryWithHttpInfoAsync(emailId, htmlSelector, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to perform HTML query on</param>
        /// <param name="htmlSelector">HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailTextLinesResult)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailTextLinesResult>> GetEmailHTMLQueryWithHttpInfoAsync(Guid emailId, string htmlSelector, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'htmlSelector' is set
            if (htmlSelector == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'htmlSelector' when calling EmailControllerApi->GetEmailHTMLQuery");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "htmlSelector", htmlSelector));

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailHTMLQuery";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EmailTextLinesResult>("/emails/{emailId}/htmlQuery", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailHTMLQuery", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Parse and return list of links found in an email (only works for HTML content) HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="selector">Optional HTML query selector for links (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailLinksResult</returns>
        public EmailLinksResult GetEmailLinks(Guid emailId, string selector = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailLinksResult> localVarResponse = GetEmailLinksWithHttpInfo(emailId, selector);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Parse and return list of links found in an email (only works for HTML content) HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="selector">Optional HTML query selector for links (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailLinksResult</returns>
        public mailslurp.Client.ApiResponse<EmailLinksResult> GetEmailLinksWithHttpInfo(Guid emailId, string selector = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            if (selector != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "selector", selector));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailLinks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<EmailLinksResult>("/emails/{emailId}/links", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailLinks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Parse and return list of links found in an email (only works for HTML content) HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="selector">Optional HTML query selector for links (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailLinksResult</returns>
        public async System.Threading.Tasks.Task<EmailLinksResult> GetEmailLinksAsync(Guid emailId, string selector = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailLinksResult> localVarResponse = await GetEmailLinksWithHttpInfoAsync(emailId, selector, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Parse and return list of links found in an email (only works for HTML content) HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="selector">Optional HTML query selector for links (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailLinksResult)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailLinksResult>> GetEmailLinksWithHttpInfoAsync(Guid emailId, string selector = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            if (selector != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "selector", selector));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailLinks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EmailLinksResult>("/emails/{emailId}/links", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailLinks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email URLs for viewing in browser or downloading Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailPreviewUrls</returns>
        public EmailPreviewUrls GetEmailPreviewURLs(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailPreviewUrls> localVarResponse = GetEmailPreviewURLsWithHttpInfo(emailId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email URLs for viewing in browser or downloading Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailPreviewUrls</returns>
        public mailslurp.Client.ApiResponse<EmailPreviewUrls> GetEmailPreviewURLsWithHttpInfo(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailPreviewURLs";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<EmailPreviewUrls>("/emails/{emailId}/urls", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailPreviewURLs", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email URLs for viewing in browser or downloading Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailPreviewUrls</returns>
        public async System.Threading.Tasks.Task<EmailPreviewUrls> GetEmailPreviewURLsAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailPreviewUrls> localVarResponse = await GetEmailPreviewURLsWithHttpInfoAsync(emailId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email URLs for viewing in browser or downloading Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailPreviewUrls)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailPreviewUrls>> GetEmailPreviewURLsWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailPreviewURLs";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EmailPreviewUrls>("/emails/{emailId}/urls", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailPreviewURLs", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Take a screenshot of an email in a browser and return base64 encoded string Capture image of email screenshot and return as base64 encoded string. Useful for embedding in HTML. Be careful as this may contain sensitive information.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailScreenshotResult</returns>
        public EmailScreenshotResult GetEmailScreenshotAsBase64(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailScreenshotResult> localVarResponse = GetEmailScreenshotAsBase64WithHttpInfo(emailId, getEmailScreenshotOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Take a screenshot of an email in a browser and return base64 encoded string Capture image of email screenshot and return as base64 encoded string. Useful for embedding in HTML. Be careful as this may contain sensitive information.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailScreenshotResult</returns>
        public mailslurp.Client.ApiResponse<EmailScreenshotResult> GetEmailScreenshotAsBase64WithHttpInfo(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0)
        {
            // verify the required parameter 'getEmailScreenshotOptions' is set
            if (getEmailScreenshotOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'getEmailScreenshotOptions' when calling EmailControllerApi->GetEmailScreenshotAsBase64");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.Data = getEmailScreenshotOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailScreenshotAsBase64";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<EmailScreenshotResult>("/emails/{emailId}/screenshot/base64", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailScreenshotAsBase64", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Take a screenshot of an email in a browser and return base64 encoded string Capture image of email screenshot and return as base64 encoded string. Useful for embedding in HTML. Be careful as this may contain sensitive information.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailScreenshotResult</returns>
        public async System.Threading.Tasks.Task<EmailScreenshotResult> GetEmailScreenshotAsBase64Async(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailScreenshotResult> localVarResponse = await GetEmailScreenshotAsBase64WithHttpInfoAsync(emailId, getEmailScreenshotOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Take a screenshot of an email in a browser and return base64 encoded string Capture image of email screenshot and return as base64 encoded string. Useful for embedding in HTML. Be careful as this may contain sensitive information.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailScreenshotResult)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailScreenshotResult>> GetEmailScreenshotAsBase64WithHttpInfoAsync(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'getEmailScreenshotOptions' is set
            if (getEmailScreenshotOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'getEmailScreenshotOptions' when calling EmailControllerApi->GetEmailScreenshotAsBase64");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.Data = getEmailScreenshotOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailScreenshotAsBase64";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<EmailScreenshotResult>("/emails/{emailId}/screenshot/base64", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailScreenshotAsBase64", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Take a screenshot of an email in a browser Returns binary octet-stream of screenshot of the given email
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void GetEmailScreenshotAsBinary(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0)
        {
            GetEmailScreenshotAsBinaryWithHttpInfo(emailId, getEmailScreenshotOptions);
        }

        /// <summary>
        /// Take a screenshot of an email in a browser Returns binary octet-stream of screenshot of the given email
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> GetEmailScreenshotAsBinaryWithHttpInfo(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0)
        {
            // verify the required parameter 'getEmailScreenshotOptions' is set
            if (getEmailScreenshotOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'getEmailScreenshotOptions' when calling EmailControllerApi->GetEmailScreenshotAsBinary");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.Data = getEmailScreenshotOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailScreenshotAsBinary";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/emails/{emailId}/screenshot/binary", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailScreenshotAsBinary", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Take a screenshot of an email in a browser Returns binary octet-stream of screenshot of the given email
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GetEmailScreenshotAsBinaryAsync(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            await GetEmailScreenshotAsBinaryWithHttpInfoAsync(emailId, getEmailScreenshotOptions, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Take a screenshot of an email in a browser Returns binary octet-stream of screenshot of the given email
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="getEmailScreenshotOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> GetEmailScreenshotAsBinaryWithHttpInfoAsync(Guid emailId, GetEmailScreenshotOptions getEmailScreenshotOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'getEmailScreenshotOptions' is set
            if (getEmailScreenshotOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'getEmailScreenshotOptions' when calling EmailControllerApi->GetEmailScreenshotAsBinary");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.Data = getEmailScreenshotOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailScreenshotAsBinary";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/emails/{emailId}/screenshot/binary", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailScreenshotAsBinary", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email data including headers but not body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController. Returns a email summary object with headers. To retrieve the body see getEmail and to get raw unparsed email use the getRawEmail endpoints
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="decode"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailPreview</returns>
        public EmailPreview GetEmailSummary(Guid emailId, bool? decode = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailPreview> localVarResponse = GetEmailSummaryWithHttpInfo(emailId, decode);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email data including headers but not body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController. Returns a email summary object with headers. To retrieve the body see getEmail and to get raw unparsed email use the getRawEmail endpoints
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="decode"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailPreview</returns>
        public mailslurp.Client.ApiResponse<EmailPreview> GetEmailSummaryWithHttpInfo(Guid emailId, bool? decode = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            if (decode != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "decode", decode));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailSummary";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<EmailPreview>("/emails/{emailId}/summary", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailSummary", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get email data including headers but not body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController. Returns a email summary object with headers. To retrieve the body see getEmail and to get raw unparsed email use the getRawEmail endpoints
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="decode"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailPreview</returns>
        public async System.Threading.Tasks.Task<EmailPreview> GetEmailSummaryAsync(Guid emailId, bool? decode = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailPreview> localVarResponse = await GetEmailSummaryWithHttpInfoAsync(emailId, decode, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get email data including headers but not body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController. Returns a email summary object with headers. To retrieve the body see getEmail and to get raw unparsed email use the getRawEmail endpoints
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="decode"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailPreview)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailPreview>> GetEmailSummaryWithHttpInfoAsync(Guid emailId, bool? decode = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            if (decode != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "decode", decode));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailSummary";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EmailPreview>("/emails/{emailId}/summary", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailSummary", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="decodeHtmlEntities">Decode HTML entities (optional)</param>
        /// <param name="lineSeparator">Line separator character (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailTextLinesResult</returns>
        public EmailTextLinesResult GetEmailTextLines(Guid emailId, bool? decodeHtmlEntities = default, string lineSeparator = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailTextLinesResult> localVarResponse = GetEmailTextLinesWithHttpInfo(emailId, decodeHtmlEntities, lineSeparator);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="decodeHtmlEntities">Decode HTML entities (optional)</param>
        /// <param name="lineSeparator">Line separator character (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailTextLinesResult</returns>
        public mailslurp.Client.ApiResponse<EmailTextLinesResult> GetEmailTextLinesWithHttpInfo(Guid emailId, bool? decodeHtmlEntities = default, string lineSeparator = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            if (decodeHtmlEntities != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "decodeHtmlEntities", decodeHtmlEntities));
            }
            if (lineSeparator != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "lineSeparator", lineSeparator));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailTextLines";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<EmailTextLinesResult>("/emails/{emailId}/textLines", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailTextLines", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="decodeHtmlEntities">Decode HTML entities (optional)</param>
        /// <param name="lineSeparator">Line separator character (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailTextLinesResult</returns>
        public async System.Threading.Tasks.Task<EmailTextLinesResult> GetEmailTextLinesAsync(Guid emailId, bool? decodeHtmlEntities = default, string lineSeparator = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailTextLinesResult> localVarResponse = await GetEmailTextLinesWithHttpInfoAsync(emailId, decodeHtmlEntities, lineSeparator, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Parse and return text from an email, stripping HTML and decoding encoded characters Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to fetch text for</param>
        /// <param name="decodeHtmlEntities">Decode HTML entities (optional)</param>
        /// <param name="lineSeparator">Line separator character (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailTextLinesResult)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailTextLinesResult>> GetEmailTextLinesWithHttpInfoAsync(Guid emailId, bool? decodeHtmlEntities = default, string lineSeparator = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            if (decodeHtmlEntities != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "decodeHtmlEntities", decodeHtmlEntities));
            }
            if (lineSeparator != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "lineSeparator", lineSeparator));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailTextLines";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EmailTextLinesResult>("/emails/{emailId}/textLines", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailTextLines", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Return email thread information. Use items endpoints to get messages for thread. Return email message thread summary from Message-ID, In-Reply-To, and References header. Get messages using items endpoint
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailThreadDto</returns>
        public EmailThreadDto GetEmailThread(Guid threadId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailThreadDto> localVarResponse = GetEmailThreadWithHttpInfo(threadId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Return email thread information. Use items endpoints to get messages for thread. Return email message thread summary from Message-ID, In-Reply-To, and References header. Get messages using items endpoint
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailThreadDto</returns>
        public mailslurp.Client.ApiResponse<EmailThreadDto> GetEmailThreadWithHttpInfo(Guid threadId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("threadId", mailslurp.Client.ClientUtils.ParameterToString(threadId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailThread";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<EmailThreadDto>("/emails/threads/{threadId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailThread", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Return email thread information. Use items endpoints to get messages for thread. Return email message thread summary from Message-ID, In-Reply-To, and References header. Get messages using items endpoint
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailThreadDto</returns>
        public async System.Threading.Tasks.Task<EmailThreadDto> GetEmailThreadAsync(Guid threadId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailThreadDto> localVarResponse = await GetEmailThreadWithHttpInfoAsync(threadId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Return email thread information. Use items endpoints to get messages for thread. Return email message thread summary from Message-ID, In-Reply-To, and References header. Get messages using items endpoint
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailThreadDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailThreadDto>> GetEmailThreadWithHttpInfoAsync(Guid threadId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("threadId", mailslurp.Client.ClientUtils.ParameterToString(threadId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailThread";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EmailThreadDto>("/emails/threads/{threadId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailThread", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Return email thread items. Return email thread messages based on Message-ID, In-Reply-To, and References header
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailThreadItemsDto</returns>
        public EmailThreadItemsDto GetEmailThreadItems(Guid threadId, string sort = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailThreadItemsDto> localVarResponse = GetEmailThreadItemsWithHttpInfo(threadId, sort);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Return email thread items. Return email thread messages based on Message-ID, In-Reply-To, and References header
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailThreadItemsDto</returns>
        public mailslurp.Client.ApiResponse<EmailThreadItemsDto> GetEmailThreadItemsWithHttpInfo(Guid threadId, string sort = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("threadId", mailslurp.Client.ClientUtils.ParameterToString(threadId)); // path parameter
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailThreadItems";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<EmailThreadItemsDto>("/emails/threads/{threadId}/items", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailThreadItems", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Return email thread items. Return email thread messages based on Message-ID, In-Reply-To, and References header
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailThreadItemsDto</returns>
        public async System.Threading.Tasks.Task<EmailThreadItemsDto> GetEmailThreadItemsAsync(Guid threadId, string sort = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailThreadItemsDto> localVarResponse = await GetEmailThreadItemsWithHttpInfoAsync(threadId, sort, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Return email thread items. Return email thread messages based on Message-ID, In-Reply-To, and References header
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId"></param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailThreadItemsDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailThreadItemsDto>> GetEmailThreadItemsWithHttpInfoAsync(Guid threadId, string sort = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("threadId", mailslurp.Client.ClientUtils.ParameterToString(threadId)); // path parameter
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailThreadItems";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EmailThreadItemsDto>("/emails/threads/{threadId}/items", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailThreadItems", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Return email threads in paginated form Return email message chains built from Message-ID, In-Reply-To, and References header.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="htmlSelector">Optional inbox filter (optional)</param>
        /// <param name="page">Optional page index in email thread pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email thread pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter search filter for email threads. (optional)</param>
        /// <param name="since">Optional filter email threads created since time (optional)</param>
        /// <param name="before">Optional filter emails threads created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageEmailThreadProjection</returns>
        public PageEmailThreadProjection GetEmailThreads(Guid? htmlSelector = default, int? page = default, int? size = default, string sort = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageEmailThreadProjection> localVarResponse = GetEmailThreadsWithHttpInfo(htmlSelector, page, size, sort, searchFilter, since, before);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Return email threads in paginated form Return email message chains built from Message-ID, In-Reply-To, and References header.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="htmlSelector">Optional inbox filter (optional)</param>
        /// <param name="page">Optional page index in email thread pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email thread pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter search filter for email threads. (optional)</param>
        /// <param name="since">Optional filter email threads created since time (optional)</param>
        /// <param name="before">Optional filter emails threads created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageEmailThreadProjection</returns>
        public mailslurp.Client.ApiResponse<PageEmailThreadProjection> GetEmailThreadsWithHttpInfo(Guid? htmlSelector = default, int? page = default, int? size = default, string sort = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (htmlSelector != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "htmlSelector", htmlSelector));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailThreads";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageEmailThreadProjection>("/emails/threads", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailThreads", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Return email threads in paginated form Return email message chains built from Message-ID, In-Reply-To, and References header.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="htmlSelector">Optional inbox filter (optional)</param>
        /// <param name="page">Optional page index in email thread pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email thread pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter search filter for email threads. (optional)</param>
        /// <param name="since">Optional filter email threads created since time (optional)</param>
        /// <param name="before">Optional filter emails threads created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageEmailThreadProjection</returns>
        public async System.Threading.Tasks.Task<PageEmailThreadProjection> GetEmailThreadsAsync(Guid? htmlSelector = default, int? page = default, int? size = default, string sort = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<PageEmailThreadProjection> localVarResponse = await GetEmailThreadsWithHttpInfoAsync(htmlSelector, page, size, sort, searchFilter, since, before, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Return email threads in paginated form Return email message chains built from Message-ID, In-Reply-To, and References header.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="htmlSelector">Optional inbox filter (optional)</param>
        /// <param name="page">Optional page index in email thread pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email thread pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="searchFilter">Optional search filter search filter for email threads. (optional)</param>
        /// <param name="since">Optional filter email threads created since time (optional)</param>
        /// <param name="before">Optional filter emails threads created before given date time (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageEmailThreadProjection)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageEmailThreadProjection>> GetEmailThreadsWithHttpInfoAsync(Guid? htmlSelector = default, int? page = default, int? size = default, string sort = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (htmlSelector != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "htmlSelector", htmlSelector));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailThreads";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageEmailThreadProjection>("/emails/threads", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailThreads", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all. By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageEmailProjection</returns>
        public PageEmailProjection GetEmailsOffsetPaginated(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? favourited = default, bool? syncConnectors = default, Guid? plusAddressId = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageEmailProjection> localVarResponse = GetEmailsOffsetPaginatedWithHttpInfo(inboxId, page, size, sort, unreadOnly, searchFilter, since, before, favourited, syncConnectors, plusAddressId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all. By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageEmailProjection</returns>
        public mailslurp.Client.ApiResponse<PageEmailProjection> GetEmailsOffsetPaginatedWithHttpInfo(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? favourited = default, bool? syncConnectors = default, Guid? plusAddressId = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("multi", "inboxId", inboxId));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (favourited != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourited", favourited));
            }
            if (syncConnectors != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "syncConnectors", syncConnectors));
            }
            if (plusAddressId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "plusAddressId", plusAddressId));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailsOffsetPaginated";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageEmailProjection>("/emails/offset-paginated", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailsOffsetPaginated", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all. By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageEmailProjection</returns>
        public async System.Threading.Tasks.Task<PageEmailProjection> GetEmailsOffsetPaginatedAsync(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? favourited = default, bool? syncConnectors = default, Guid? plusAddressId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<PageEmailProjection> localVarResponse = await GetEmailsOffsetPaginatedWithHttpInfoAsync(inboxId, page, size, sort, unreadOnly, searchFilter, since, before, favourited, syncConnectors, plusAddressId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all. By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageEmailProjection)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageEmailProjection>> GetEmailsOffsetPaginatedWithHttpInfoAsync(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? favourited = default, bool? syncConnectors = default, Guid? plusAddressId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("multi", "inboxId", inboxId));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (favourited != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourited", favourited));
            }
            if (syncConnectors != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "syncConnectors", syncConnectors));
            }
            if (plusAddressId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "plusAddressId", plusAddressId));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailsOffsetPaginated";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageEmailProjection>("/emails/offset-paginated", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailsOffsetPaginated", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all. By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageEmailProjection</returns>
        public PageEmailProjection GetEmailsPaginated(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, Guid? plusAddressId = default, bool? favourited = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageEmailProjection> localVarResponse = GetEmailsPaginatedWithHttpInfo(inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, plusAddressId, favourited);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all. By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageEmailProjection</returns>
        public mailslurp.Client.ApiResponse<PageEmailProjection> GetEmailsPaginatedWithHttpInfo(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, Guid? plusAddressId = default, bool? favourited = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("multi", "inboxId", inboxId));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (syncConnectors != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "syncConnectors", syncConnectors));
            }
            if (plusAddressId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "plusAddressId", plusAddressId));
            }
            if (favourited != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourited", favourited));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailsPaginated";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageEmailProjection>("/emails", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailsPaginated", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all. By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageEmailProjection</returns>
        public async System.Threading.Tasks.Task<PageEmailProjection> GetEmailsPaginatedAsync(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, Guid? plusAddressId = default, bool? favourited = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<PageEmailProjection> localVarResponse = await GetEmailsPaginatedWithHttpInfoAsync(inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, plusAddressId, favourited, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all emails in all inboxes in paginated form. Email API list all. By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="favourited">Optional filter emails that are favourited (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageEmailProjection)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageEmailProjection>> GetEmailsPaginatedWithHttpInfoAsync(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, Guid? plusAddressId = default, bool? favourited = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("multi", "inboxId", inboxId));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (syncConnectors != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "syncConnectors", syncConnectors));
            }
            if (plusAddressId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "plusAddressId", plusAddressId));
            }
            if (favourited != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourited", favourited));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetEmailsPaginated";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageEmailProjection>("/emails", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEmailsPaginated", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get gravatar url for email address
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="size"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GravatarUrl</returns>
        public GravatarUrl GetGravatarUrlForEmailAddress(string emailAddress, string size = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<GravatarUrl> localVarResponse = GetGravatarUrlForEmailAddressWithHttpInfo(emailAddress, size);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get gravatar url for email address
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="size"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GravatarUrl</returns>
        public mailslurp.Client.ApiResponse<GravatarUrl> GetGravatarUrlForEmailAddressWithHttpInfo(string emailAddress, string size = default, int operationIndex = 0)
        {
            // verify the required parameter 'emailAddress' is set
            if (emailAddress == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'emailAddress' when calling EmailControllerApi->GetGravatarUrlForEmailAddress");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "emailAddress", emailAddress));
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetGravatarUrlForEmailAddress";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GravatarUrl>("/emails/gravatarFor", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetGravatarUrlForEmailAddress", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Get gravatar url for email address
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="size"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GravatarUrl</returns>
        public async System.Threading.Tasks.Task<GravatarUrl> GetGravatarUrlForEmailAddressAsync(string emailAddress, string size = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<GravatarUrl> localVarResponse = await GetGravatarUrlForEmailAddressWithHttpInfoAsync(emailAddress, size, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Get gravatar url for email address
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailAddress"></param>
        /// <param name="size"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GravatarUrl)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<GravatarUrl>> GetGravatarUrlForEmailAddressWithHttpInfoAsync(string emailAddress, string size = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'emailAddress' is set
            if (emailAddress == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'emailAddress' when calling EmailControllerApi->GetGravatarUrlForEmailAddress");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "emailAddress", emailAddress));
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetGravatarUrlForEmailAddress";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<GravatarUrl>("/emails/gravatarFor", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetGravatarUrlForEmailAddress", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get latest email in all inboxes. Most recently received. Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxIds">Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        public Email GetLatestEmail(List<Guid> inboxIds = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = GetLatestEmailWithHttpInfo(inboxIds);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get latest email in all inboxes. Most recently received. Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxIds">Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        public mailslurp.Client.ApiResponse<Email> GetLatestEmailWithHttpInfo(List<Guid> inboxIds = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("multi", "inboxIds", inboxIds));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetLatestEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Email>("/emails/latest", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLatestEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get latest email in all inboxes. Most recently received. Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxIds">Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        public async System.Threading.Tasks.Task<Email> GetLatestEmailAsync(List<Guid> inboxIds = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = await GetLatestEmailWithHttpInfoAsync(inboxIds, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get latest email in all inboxes. Most recently received. Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxIds">Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Email>> GetLatestEmailWithHttpInfoAsync(List<Guid> inboxIds = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("multi", "inboxIds", inboxIds));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetLatestEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Email>("/emails/latest", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLatestEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet. Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        public Email GetLatestEmailInInbox1(Guid inboxId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = GetLatestEmailInInbox1WithHttpInfo(inboxId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet. Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        public mailslurp.Client.ApiResponse<Email> GetLatestEmailInInbox1WithHttpInfo(Guid inboxId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));

            localVarRequestOptions.Operation = "EmailControllerApi.GetLatestEmailInInbox1";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Email>("/emails/latestIn", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLatestEmailInInbox1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet. Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        public async System.Threading.Tasks.Task<Email> GetLatestEmailInInbox1Async(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = await GetLatestEmailInInbox1WithHttpInfoAsync(inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet. Get the newest email in all inboxes or in a passed set of inbox IDs
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of the inbox you want to get the latest email from</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Email>> GetLatestEmailInInbox1WithHttpInfoAsync(Guid inboxId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));

            localVarRequestOptions.Operation = "EmailControllerApi.GetLatestEmailInInbox1";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Email>("/emails/latestIn", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLatestEmailInInbox1", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all organization emails. List team or shared test email accounts By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter search filter for emails. (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favorited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageEmailProjection</returns>
        public PageEmailProjection GetOrganizationEmailsPaginated(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageEmailProjection> localVarResponse = GetOrganizationEmailsPaginatedWithHttpInfo(inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, favourited, plusAddressId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all organization emails. List team or shared test email accounts By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter search filter for emails. (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favorited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageEmailProjection</returns>
        public mailslurp.Client.ApiResponse<PageEmailProjection> GetOrganizationEmailsPaginatedWithHttpInfo(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("multi", "inboxId", inboxId));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (syncConnectors != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "syncConnectors", syncConnectors));
            }
            if (favourited != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourited", favourited));
            }
            if (plusAddressId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "plusAddressId", plusAddressId));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetOrganizationEmailsPaginated";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageEmailProjection>("/emails/organization", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOrganizationEmailsPaginated", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all organization emails. List team or shared test email accounts By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter search filter for emails. (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favorited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageEmailProjection</returns>
        public async System.Threading.Tasks.Task<PageEmailProjection> GetOrganizationEmailsPaginatedAsync(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<PageEmailProjection> localVarResponse = await GetOrganizationEmailsPaginatedWithHttpInfoAsync(inboxId, page, size, sort, unreadOnly, searchFilter, since, before, syncConnectors, favourited, plusAddressId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all organization emails. List team or shared test email accounts By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)</param>
        /// <param name="page">Optional page index in email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="unreadOnly">Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)</param>
        /// <param name="searchFilter">Optional search filter search filter for emails. (optional)</param>
        /// <param name="since">Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)</param>
        /// <param name="before">Optional filter emails received before given date time (optional)</param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favorited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageEmailProjection)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageEmailProjection>> GetOrganizationEmailsPaginatedWithHttpInfoAsync(List<Guid> inboxId = default, int? page = default, int? size = default, string sort = default, bool? unreadOnly = default, string searchFilter = default, DateTime? since = default, DateTime? before = default, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("multi", "inboxId", inboxId));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (searchFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "searchFilter", searchFilter));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (syncConnectors != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "syncConnectors", syncConnectors));
            }
            if (favourited != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourited", favourited));
            }
            if (plusAddressId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "plusAddressId", plusAddressId));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetOrganizationEmailsPaginated";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageEmailProjection>("/emails/organization", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOrganizationEmailsPaginated", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get raw email string. Returns unparsed raw SMTP message with headers and body. Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void GetRawEmailContents(Guid emailId, int operationIndex = 0)
        {
            GetRawEmailContentsWithHttpInfo(emailId);
        }

        /// <summary>
        /// Get raw email string. Returns unparsed raw SMTP message with headers and body. Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> GetRawEmailContentsWithHttpInfo(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetRawEmailContents";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Object>("/emails/{emailId}/raw", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRawEmailContents", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get raw email string. Returns unparsed raw SMTP message with headers and body. Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GetRawEmailContentsAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            await GetRawEmailContentsWithHttpInfoAsync(emailId, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get raw email string. Returns unparsed raw SMTP message with headers and body. Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> GetRawEmailContentsWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetRawEmailContents";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Object>("/emails/{emailId}/raw", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRawEmailContents", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get raw email in JSON. Unparsed SMTP message in JSON wrapper format. Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RawEmailJson</returns>
        public RawEmailJson GetRawEmailJson(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<RawEmailJson> localVarResponse = GetRawEmailJsonWithHttpInfo(emailId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get raw email in JSON. Unparsed SMTP message in JSON wrapper format. Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RawEmailJson</returns>
        public mailslurp.Client.ApiResponse<RawEmailJson> GetRawEmailJsonWithHttpInfo(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetRawEmailJson";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<RawEmailJson>("/emails/{emailId}/raw/json", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRawEmailJson", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get raw email in JSON. Unparsed SMTP message in JSON wrapper format. Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RawEmailJson</returns>
        public async System.Threading.Tasks.Task<RawEmailJson> GetRawEmailJsonAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<RawEmailJson> localVarResponse = await GetRawEmailJsonWithHttpInfoAsync(emailId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get raw email in JSON. Unparsed SMTP message in JSON wrapper format. Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RawEmailJson)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<RawEmailJson>> GetRawEmailJsonWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.GetRawEmailJson";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<RawEmailJson>("/emails/{emailId}/raw/json", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRawEmailJson", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get unread email count Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>UnreadCount</returns>
        public UnreadCount GetUnreadEmailCount(Guid? inboxId = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<UnreadCount> localVarResponse = GetUnreadEmailCountWithHttpInfo(inboxId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get unread email count Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of UnreadCount</returns>
        public mailslurp.Client.ApiResponse<UnreadCount> GetUnreadEmailCountWithHttpInfo(Guid? inboxId = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetUnreadEmailCount";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<UnreadCount>("/emails/unreadCount", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetUnreadEmailCount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get unread email count Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UnreadCount</returns>
        public async System.Threading.Tasks.Task<UnreadCount> GetUnreadEmailCountAsync(Guid? inboxId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<UnreadCount> localVarResponse = await GetUnreadEmailCountWithHttpInfoAsync(inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get unread email count Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UnreadCount)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<UnreadCount>> GetUnreadEmailCountWithHttpInfoAsync(Guid? inboxId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.GetUnreadEmailCount";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<UnreadCount>("/emails/unreadCount", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetUnreadEmailCount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Mark all emails as read or unread Marks all emails as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void MarkAllAsRead(bool? read = default, Guid? inboxId = default, int operationIndex = 0)
        {
            MarkAllAsReadWithHttpInfo(read, inboxId);
        }

        /// <summary>
        /// Mark all emails as read or unread Marks all emails as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> MarkAllAsReadWithHttpInfo(bool? read = default, Guid? inboxId = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (read != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "read", read));
            }
            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.MarkAllAsRead";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<Object>("/emails/read", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("MarkAllAsRead", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Mark all emails as read or unread Marks all emails as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task MarkAllAsReadAsync(bool? read = default, Guid? inboxId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            await MarkAllAsReadWithHttpInfoAsync(read, inboxId, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Mark all emails as read or unread Marks all emails as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="inboxId">Optional inbox ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> MarkAllAsReadWithHttpInfoAsync(bool? read = default, Guid? inboxId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (read != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "read", read));
            }
            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.MarkAllAsRead";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<Object>("/emails/read", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("MarkAllAsRead", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Mark an email as read or unread Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EmailPreview</returns>
        public EmailPreview MarkAsRead(Guid emailId, bool? read = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<EmailPreview> localVarResponse = MarkAsReadWithHttpInfo(emailId, read);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Mark an email as read or unread Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EmailPreview</returns>
        public mailslurp.Client.ApiResponse<EmailPreview> MarkAsReadWithHttpInfo(Guid emailId, bool? read = default, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            if (read != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "read", read));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.MarkAsRead";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<EmailPreview>("/emails/{emailId}/read", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("MarkAsRead", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Mark an email as read or unread Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EmailPreview</returns>
        public async System.Threading.Tasks.Task<EmailPreview> MarkAsReadAsync(Guid emailId, bool? read = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<EmailPreview> localVarResponse = await MarkAsReadWithHttpInfoAsync(emailId, read, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Mark an email as read or unread Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId"></param>
        /// <param name="read">What value to assign to email read property. Default true. (optional, default to true)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EmailPreview)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<EmailPreview>> MarkAsReadWithHttpInfoAsync(Guid emailId, bool? read = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            if (read != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "read", read));
            }

            localVarRequestOptions.Operation = "EmailControllerApi.MarkAsRead";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<EmailPreview>("/emails/{emailId}/read", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("MarkAsRead", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reply to an email Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails &#x60;to&#x60;, &#x60;cc&#x60;, and &#x60;bcc&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of the email that should be replied to</param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SentEmailDto</returns>
        public SentEmailDto ReplyToEmail(Guid emailId, ReplyToEmailOptions replyToEmailOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<SentEmailDto> localVarResponse = ReplyToEmailWithHttpInfo(emailId, replyToEmailOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Reply to an email Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails &#x60;to&#x60;, &#x60;cc&#x60;, and &#x60;bcc&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of the email that should be replied to</param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SentEmailDto</returns>
        public mailslurp.Client.ApiResponse<SentEmailDto> ReplyToEmailWithHttpInfo(Guid emailId, ReplyToEmailOptions replyToEmailOptions, int operationIndex = 0)
        {
            // verify the required parameter 'replyToEmailOptions' is set
            if (replyToEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'replyToEmailOptions' when calling EmailControllerApi->ReplyToEmail");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.Data = replyToEmailOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.ReplyToEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<SentEmailDto>("/emails/{emailId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReplyToEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reply to an email Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails &#x60;to&#x60;, &#x60;cc&#x60;, and &#x60;bcc&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of the email that should be replied to</param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SentEmailDto</returns>
        public async System.Threading.Tasks.Task<SentEmailDto> ReplyToEmailAsync(Guid emailId, ReplyToEmailOptions replyToEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<SentEmailDto> localVarResponse = await ReplyToEmailWithHttpInfoAsync(emailId, replyToEmailOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Reply to an email Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails &#x60;to&#x60;, &#x60;cc&#x60;, and &#x60;bcc&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of the email that should be replied to</param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SentEmailDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<SentEmailDto>> ReplyToEmailWithHttpInfoAsync(Guid emailId, ReplyToEmailOptions replyToEmailOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'replyToEmailOptions' is set
            if (replyToEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'replyToEmailOptions' when calling EmailControllerApi->ReplyToEmail");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.Data = replyToEmailOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.ReplyToEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<SentEmailDto>("/emails/{emailId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReplyToEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all emails by search criteria. Return in paginated form. Search emails by given criteria return matches in paginated format. Searches against email recipients, sender, subject, email address and ID. Does not search email body
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favourited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageEmailProjection</returns>
        public PageEmailProjection SearchEmails(SearchEmailsOptions searchEmailsOptions, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<PageEmailProjection> localVarResponse = SearchEmailsWithHttpInfo(searchEmailsOptions, syncConnectors, favourited, plusAddressId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all emails by search criteria. Return in paginated form. Search emails by given criteria return matches in paginated format. Searches against email recipients, sender, subject, email address and ID. Does not search email body
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favourited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageEmailProjection</returns>
        public mailslurp.Client.ApiResponse<PageEmailProjection> SearchEmailsWithHttpInfo(SearchEmailsOptions searchEmailsOptions, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0)
        {
            // verify the required parameter 'searchEmailsOptions' is set
            if (searchEmailsOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'searchEmailsOptions' when calling EmailControllerApi->SearchEmails");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (syncConnectors != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "syncConnectors", syncConnectors));
            }
            if (favourited != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourited", favourited));
            }
            if (plusAddressId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "plusAddressId", plusAddressId));
            }
            localVarRequestOptions.Data = searchEmailsOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.SearchEmails";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PageEmailProjection>("/emails/search", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchEmails", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all emails by search criteria. Return in paginated form. Search emails by given criteria return matches in paginated format. Searches against email recipients, sender, subject, email address and ID. Does not search email body
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favourited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageEmailProjection</returns>
        public async System.Threading.Tasks.Task<PageEmailProjection> SearchEmailsAsync(SearchEmailsOptions searchEmailsOptions, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<PageEmailProjection> localVarResponse = await SearchEmailsWithHttpInfoAsync(searchEmailsOptions, syncConnectors, favourited, plusAddressId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all emails by search criteria. Return in paginated form. Search emails by given criteria return matches in paginated format. Searches against email recipients, sender, subject, email address and ID. Does not search email body
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchEmailsOptions"></param>
        /// <param name="syncConnectors">Sync connectors (optional)</param>
        /// <param name="favourited">Search only favourited emails (optional)</param>
        /// <param name="plusAddressId">Optional plus address ID filter (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageEmailProjection)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<PageEmailProjection>> SearchEmailsWithHttpInfoAsync(SearchEmailsOptions searchEmailsOptions, bool? syncConnectors = default, bool? favourited = default, Guid? plusAddressId = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'searchEmailsOptions' is set
            if (searchEmailsOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'searchEmailsOptions' when calling EmailControllerApi->SearchEmails");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (syncConnectors != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "syncConnectors", syncConnectors));
            }
            if (favourited != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourited", favourited));
            }
            if (plusAddressId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "plusAddressId", plusAddressId));
            }
            localVarRequestOptions.Data = searchEmailsOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.SearchEmails";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PageEmailProjection>("/emails/search", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchEmails", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send email Alias for &#x60;InboxController.sendEmail&#x60; method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId">ID of the inbox you want to send the email from (optional)</param>
        /// <param name="useDomainPool">Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)</param>
        /// <param name="virtualSend">Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void SendEmailSourceOptional(SendEmailOptions sendEmailOptions, Guid? inboxId = default, bool? useDomainPool = default, bool? virtualSend = default, int operationIndex = 0)
        {
            SendEmailSourceOptionalWithHttpInfo(sendEmailOptions, inboxId, useDomainPool, virtualSend);
        }

        /// <summary>
        /// Send email Alias for &#x60;InboxController.sendEmail&#x60; method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId">ID of the inbox you want to send the email from (optional)</param>
        /// <param name="useDomainPool">Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)</param>
        /// <param name="virtualSend">Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> SendEmailSourceOptionalWithHttpInfo(SendEmailOptions sendEmailOptions, Guid? inboxId = default, bool? useDomainPool = default, bool? virtualSend = default, int operationIndex = 0)
        {
            // verify the required parameter 'sendEmailOptions' is set
            if (sendEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendEmailOptions' when calling EmailControllerApi->SendEmailSourceOptional");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }
            if (useDomainPool != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "useDomainPool", useDomainPool));
            }
            if (virtualSend != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "virtualSend", virtualSend));
            }
            localVarRequestOptions.Data = sendEmailOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.SendEmailSourceOptional";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/emails", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendEmailSourceOptional", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send email Alias for &#x60;InboxController.sendEmail&#x60; method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId">ID of the inbox you want to send the email from (optional)</param>
        /// <param name="useDomainPool">Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)</param>
        /// <param name="virtualSend">Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SendEmailSourceOptionalAsync(SendEmailOptions sendEmailOptions, Guid? inboxId = default, bool? useDomainPool = default, bool? virtualSend = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            await SendEmailSourceOptionalWithHttpInfoAsync(sendEmailOptions, inboxId, useDomainPool, virtualSend, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Send email Alias for &#x60;InboxController.sendEmail&#x60; method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendEmailOptions"></param>
        /// <param name="inboxId">ID of the inbox you want to send the email from (optional)</param>
        /// <param name="useDomainPool">Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)</param>
        /// <param name="virtualSend">Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> SendEmailSourceOptionalWithHttpInfoAsync(SendEmailOptions sendEmailOptions, Guid? inboxId = default, bool? useDomainPool = default, bool? virtualSend = default, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'sendEmailOptions' is set
            if (sendEmailOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'sendEmailOptions' when calling EmailControllerApi->SendEmailSourceOptional");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }
            if (useDomainPool != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "useDomainPool", useDomainPool));
            }
            if (virtualSend != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "virtualSend", virtualSend));
            }
            localVarRequestOptions.Data = sendEmailOptions;

            localVarRequestOptions.Operation = "EmailControllerApi.SendEmailSourceOptional";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/emails", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SendEmailSourceOptional", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set email favourited state Set and return new favorite state for an email
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to set favourite state</param>
        /// <param name="favourited"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void SetEmailFavourited(Guid emailId, bool favourited, int operationIndex = 0)
        {
            SetEmailFavouritedWithHttpInfo(emailId, favourited);
        }

        /// <summary>
        /// Set email favourited state Set and return new favorite state for an email
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to set favourite state</param>
        /// <param name="favourited"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public mailslurp.Client.ApiResponse<Object> SetEmailFavouritedWithHttpInfo(Guid emailId, bool favourited, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourited", favourited));

            localVarRequestOptions.Operation = "EmailControllerApi.SetEmailFavourited";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/emails/{emailId}/favourite", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetEmailFavourited", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set email favourited state Set and return new favorite state for an email
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to set favourite state</param>
        /// <param name="favourited"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SetEmailFavouritedAsync(Guid emailId, bool favourited, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            await SetEmailFavouritedWithHttpInfoAsync(emailId, favourited, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Set email favourited state Set and return new favorite state for an email
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email to set favourite state</param>
        /// <param name="favourited"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Object>> SetEmailFavouritedWithHttpInfoAsync(Guid emailId, bool favourited, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "favourited", favourited));

            localVarRequestOptions.Operation = "EmailControllerApi.SetEmailFavourited";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/emails/{emailId}/favourite", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetEmailFavourited", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Validate email HTML contents Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ValidationDto</returns>
        public ValidationDto ValidateEmail(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<ValidationDto> localVarResponse = ValidateEmailWithHttpInfo(emailId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Validate email HTML contents Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ValidationDto</returns>
        public mailslurp.Client.ApiResponse<ValidationDto> ValidateEmailWithHttpInfo(Guid emailId, int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.ValidateEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ValidationDto>("/emails/{emailId}/validate", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ValidateEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Validate email HTML contents Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ValidationDto</returns>
        public async System.Threading.Tasks.Task<ValidationDto> ValidateEmailAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {
            mailslurp.Client.ApiResponse<ValidationDto> localVarResponse = await ValidateEmailWithHttpInfoAsync(emailId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Validate email HTML contents Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">ID of email</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ValidationDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<ValidationDto>> ValidateEmailWithHttpInfoAsync(Guid emailId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default)
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("emailId", mailslurp.Client.ClientUtils.ParameterToString(emailId)); // path parameter

            localVarRequestOptions.Operation = "EmailControllerApi.ValidateEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ValidationDto>("/emails/{emailId}/validate", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ValidateEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
