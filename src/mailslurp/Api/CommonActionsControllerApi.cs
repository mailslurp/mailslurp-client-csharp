// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ICommonActionsControllerApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        CommonActionsControllerApiEvents Events { get; }

        /// <summary>
        /// Create new random inbox
        /// </summary>
        /// <remarks>
        /// Returns an Inbox with an &#x60;id&#x60; and an &#x60;emailAddress&#x60;
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowTeamAccess"> (optional)</param>
        /// <param name="useDomainPool"> (optional)</param>
        /// <param name="expiresAt"> (optional)</param>
        /// <param name="expiresIn"> (optional)</param>
        /// <param name="emailAddress"> (optional)</param>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="name"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="favourite"> (optional)</param>
        /// <param name="virtualInbox"> (optional)</param>
        /// <param name="useShortAddress"> (optional)</param>
        /// <param name="domainName"> (optional)</param>
        /// <param name="domainId"> (optional)</param>
        /// <param name="prefix"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateNewEmailAddressApiResponse"/>&gt;</returns>
        Task<ICreateNewEmailAddressApiResponse> CreateNewEmailAddressAsync(Option<bool> allowTeamAccess = default, Option<bool> useDomainPool = default, Option<DateTime> expiresAt = default, Option<long> expiresIn = default, Option<string> emailAddress = default, Option<string> inboxType = default, Option<string> description = default, Option<string> name = default, Option<List<string>> tags = default, Option<bool> favourite = default, Option<bool> virtualInbox = default, Option<bool> useShortAddress = default, Option<string> domainName = default, Option<Guid> domainId = default, Option<string> prefix = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create new random inbox
        /// </summary>
        /// <remarks>
        /// Returns an Inbox with an &#x60;id&#x60; and an &#x60;emailAddress&#x60;
        /// </remarks>
        /// <param name="allowTeamAccess"> (optional)</param>
        /// <param name="useDomainPool"> (optional)</param>
        /// <param name="expiresAt"> (optional)</param>
        /// <param name="expiresIn"> (optional)</param>
        /// <param name="emailAddress"> (optional)</param>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="name"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="favourite"> (optional)</param>
        /// <param name="virtualInbox"> (optional)</param>
        /// <param name="useShortAddress"> (optional)</param>
        /// <param name="domainName"> (optional)</param>
        /// <param name="domainId"> (optional)</param>
        /// <param name="prefix"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateNewEmailAddressApiResponse"/>&gt;</returns>
        Task<ICreateNewEmailAddressApiResponse> CreateNewEmailAddressOrDefaultAsync(Option<bool> allowTeamAccess = default, Option<bool> useDomainPool = default, Option<DateTime> expiresAt = default, Option<long> expiresIn = default, Option<string> emailAddress = default, Option<string> inboxType = default, Option<string> description = default, Option<string> name = default, Option<List<string>> tags = default, Option<bool> favourite = default, Option<bool> virtualInbox = default, Option<bool> useShortAddress = default, Option<string> domainName = default, Option<Guid> domainId = default, Option<string> prefix = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create new random inbox
        /// </summary>
        /// <remarks>
        /// Returns an Inbox with an &#x60;id&#x60; and an &#x60;emailAddress&#x60;
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowTeamAccess"> (optional)</param>
        /// <param name="useDomainPool"> (optional)</param>
        /// <param name="expiresAt"> (optional)</param>
        /// <param name="expiresIn"> (optional)</param>
        /// <param name="emailAddress"> (optional)</param>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="name"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="favourite"> (optional)</param>
        /// <param name="virtualInbox"> (optional)</param>
        /// <param name="useShortAddress"> (optional)</param>
        /// <param name="domainName"> (optional)</param>
        /// <param name="domainId"> (optional)</param>
        /// <param name="prefix"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRandomInboxApiResponse"/>&gt;</returns>
        Task<ICreateRandomInboxApiResponse> CreateRandomInboxAsync(Option<bool> allowTeamAccess = default, Option<bool> useDomainPool = default, Option<DateTime> expiresAt = default, Option<long> expiresIn = default, Option<string> emailAddress = default, Option<string> inboxType = default, Option<string> description = default, Option<string> name = default, Option<List<string>> tags = default, Option<bool> favourite = default, Option<bool> virtualInbox = default, Option<bool> useShortAddress = default, Option<string> domainName = default, Option<Guid> domainId = default, Option<string> prefix = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create new random inbox
        /// </summary>
        /// <remarks>
        /// Returns an Inbox with an &#x60;id&#x60; and an &#x60;emailAddress&#x60;
        /// </remarks>
        /// <param name="allowTeamAccess"> (optional)</param>
        /// <param name="useDomainPool"> (optional)</param>
        /// <param name="expiresAt"> (optional)</param>
        /// <param name="expiresIn"> (optional)</param>
        /// <param name="emailAddress"> (optional)</param>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="name"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="favourite"> (optional)</param>
        /// <param name="virtualInbox"> (optional)</param>
        /// <param name="useShortAddress"> (optional)</param>
        /// <param name="domainName"> (optional)</param>
        /// <param name="domainId"> (optional)</param>
        /// <param name="prefix"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRandomInboxApiResponse"/>&gt;</returns>
        Task<ICreateRandomInboxApiResponse> CreateRandomInboxOrDefaultAsync(Option<bool> allowTeamAccess = default, Option<bool> useDomainPool = default, Option<DateTime> expiresAt = default, Option<long> expiresIn = default, Option<string> emailAddress = default, Option<string> inboxType = default, Option<string> description = default, Option<string> name = default, Option<List<string>> tags = default, Option<bool> favourite = default, Option<bool> virtualInbox = default, Option<bool> useShortAddress = default, Option<string> domainName = default, Option<Guid> domainId = default, Option<string> prefix = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete inbox email address by inbox id
        /// </summary>
        /// <remarks>
        /// Deletes inbox email address
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteEmailAddressApiResponse"/>&gt;</returns>
        Task<IDeleteEmailAddressApiResponse> DeleteEmailAddressAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete inbox email address by inbox id
        /// </summary>
        /// <remarks>
        /// Deletes inbox email address
        /// </remarks>
        /// <param name="inboxId">ID of inbox to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteEmailAddressApiResponse"/>&gt;</returns>
        Task<IDeleteEmailAddressApiResponse> DeleteEmailAddressOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete all emails in an inbox
        /// </summary>
        /// <remarks>
        /// Deletes all emails
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to empty</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEmptyInboxApiResponse"/>&gt;</returns>
        Task<IEmptyInboxApiResponse> EmptyInboxAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete all emails in an inbox
        /// </summary>
        /// <remarks>
        /// Deletes all emails
        /// </remarks>
        /// <param name="inboxId">ID of inbox to empty</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEmptyInboxApiResponse"/>&gt;</returns>
        Task<IEmptyInboxApiResponse> EmptyInboxOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send an email using query parameters
        /// </summary>
        /// <remarks>
        /// If no senderId or inboxId provided a random email address will be used to send from. Ensure your parameters are URL encoded.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="to">Email address to send to</param>
        /// <param name="senderId">ID of inbox to send from. If null an inbox will be created for sending (optional)</param>
        /// <param name="body">Body of the email message. Supports HTML (optional)</param>
        /// <param name="subject">Subject line of the email (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailQueryApiResponse"/>&gt;</returns>
        Task<ISendEmailQueryApiResponse> SendEmailQueryAsync(string to, Option<Guid> senderId = default, Option<string> body = default, Option<string> subject = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send an email using query parameters
        /// </summary>
        /// <remarks>
        /// If no senderId or inboxId provided a random email address will be used to send from. Ensure your parameters are URL encoded.
        /// </remarks>
        /// <param name="to">Email address to send to</param>
        /// <param name="senderId">ID of inbox to send from. If null an inbox will be created for sending (optional)</param>
        /// <param name="body">Body of the email message. Supports HTML (optional)</param>
        /// <param name="subject">Subject line of the email (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailQueryApiResponse"/>&gt;</returns>
        Task<ISendEmailQueryApiResponse> SendEmailQueryOrDefaultAsync(string to, Option<Guid> senderId = default, Option<string> body = default, Option<string> subject = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send an email
        /// </summary>
        /// <remarks>
        /// If no senderId or inboxId provided a random email address will be used to send from.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="simpleSendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailSimpleApiResponse"/>&gt;</returns>
        Task<ISendEmailSimpleApiResponse> SendEmailSimpleAsync(SimpleSendEmailOptions simpleSendEmailOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send an email
        /// </summary>
        /// <remarks>
        /// If no senderId or inboxId provided a random email address will be used to send from.
        /// </remarks>
        /// <param name="simpleSendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailSimpleApiResponse"/>&gt;</returns>
        Task<ISendEmailSimpleApiResponse> SendEmailSimpleOrDefaultAsync(SimpleSendEmailOptions simpleSendEmailOptions, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateNewEmailAddressApiResponse"/>
    /// </summary>
    public interface ICreateNewEmailAddressApiResponse : mailslurp.Client.IApiResponse, ICreated<mailslurp.Model.InboxDto>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ICreateRandomInboxApiResponse"/>
    /// </summary>
    public interface ICreateRandomInboxApiResponse : mailslurp.Client.IApiResponse, ICreated<mailslurp.Model.InboxDto>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteEmailAddressApiResponse"/>
    /// </summary>
    public interface IDeleteEmailAddressApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IEmptyInboxApiResponse"/>
    /// </summary>
    public interface IEmptyInboxApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="ISendEmailQueryApiResponse"/>
    /// </summary>
    public interface ISendEmailQueryApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ISendEmailSimpleApiResponse"/>
    /// </summary>
    public interface ISendEmailSimpleApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class CommonActionsControllerApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnCreateNewEmailAddress;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorCreateNewEmailAddress;

        internal void ExecuteOnCreateNewEmailAddress(CommonActionsControllerApi.CreateNewEmailAddressApiResponse apiResponse)
        {
            OnCreateNewEmailAddress?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateNewEmailAddress(Exception exception)
        {
            OnErrorCreateNewEmailAddress?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnCreateRandomInbox;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorCreateRandomInbox;

        internal void ExecuteOnCreateRandomInbox(CommonActionsControllerApi.CreateRandomInboxApiResponse apiResponse)
        {
            OnCreateRandomInbox?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateRandomInbox(Exception exception)
        {
            OnErrorCreateRandomInbox?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteEmailAddress;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteEmailAddress;

        internal void ExecuteOnDeleteEmailAddress(CommonActionsControllerApi.DeleteEmailAddressApiResponse apiResponse)
        {
            OnDeleteEmailAddress?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteEmailAddress(Exception exception)
        {
            OnErrorDeleteEmailAddress?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnEmptyInbox;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorEmptyInbox;

        internal void ExecuteOnEmptyInbox(CommonActionsControllerApi.EmptyInboxApiResponse apiResponse)
        {
            OnEmptyInbox?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEmptyInbox(Exception exception)
        {
            OnErrorEmptyInbox?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSendEmailQuery;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSendEmailQuery;

        internal void ExecuteOnSendEmailQuery(CommonActionsControllerApi.SendEmailQueryApiResponse apiResponse)
        {
            OnSendEmailQuery?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendEmailQuery(Exception exception)
        {
            OnErrorSendEmailQuery?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSendEmailSimple;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSendEmailSimple;

        internal void ExecuteOnSendEmailSimple(CommonActionsControllerApi.SendEmailSimpleApiResponse apiResponse)
        {
            OnSendEmailSimple?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendEmailSimple(Exception exception)
        {
            OnErrorSendEmailSimple?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class CommonActionsControllerApi : ICommonActionsControllerApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<CommonActionsControllerApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public CommonActionsControllerApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="CommonActionsControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CommonActionsControllerApi(ILogger<CommonActionsControllerApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, CommonActionsControllerApiEvents commonActionsControllerApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<CommonActionsControllerApi>();
            HttpClient = httpClient;
            Events = commonActionsControllerApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatCreateNewEmailAddress(ref Option<bool> allowTeamAccess, ref Option<bool> useDomainPool, ref Option<DateTime> expiresAt, ref Option<long> expiresIn, ref Option<string> emailAddress, ref Option<string> inboxType, ref Option<string> description, ref Option<string> name, Option<List<string>> tags, ref Option<bool> favourite, ref Option<bool> virtualInbox, ref Option<bool> useShortAddress, ref Option<string> domainName, ref Option<Guid> domainId, ref Option<string> prefix);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="emailAddress"></param>
        /// <param name="inboxType"></param>
        /// <param name="description"></param>
        /// <param name="name"></param>
        /// <param name="tags"></param>
        /// <param name="domainName"></param>
        /// <param name="prefix"></param>
        /// <returns></returns>
        private void ValidateCreateNewEmailAddress(Option<string> emailAddress, Option<string> inboxType, Option<string> description, Option<string> name, Option<List<string>> tags, Option<string> domainName, Option<string> prefix)
        {
            if (emailAddress.IsSet && emailAddress.Value == null)
                throw new ArgumentNullException(nameof(emailAddress));

            if (inboxType.IsSet && inboxType.Value == null)
                throw new ArgumentNullException(nameof(inboxType));

            if (description.IsSet && description.Value == null)
                throw new ArgumentNullException(nameof(description));

            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name));

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));

            if (domainName.IsSet && domainName.Value == null)
                throw new ArgumentNullException(nameof(domainName));

            if (prefix.IsSet && prefix.Value == null)
                throw new ArgumentNullException(nameof(prefix));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="allowTeamAccess"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="expiresAt"></param>
        /// <param name="expiresIn"></param>
        /// <param name="emailAddress"></param>
        /// <param name="inboxType"></param>
        /// <param name="description"></param>
        /// <param name="name"></param>
        /// <param name="tags"></param>
        /// <param name="favourite"></param>
        /// <param name="virtualInbox"></param>
        /// <param name="useShortAddress"></param>
        /// <param name="domainName"></param>
        /// <param name="domainId"></param>
        /// <param name="prefix"></param>
        private void AfterCreateNewEmailAddressDefaultImplementation(ICreateNewEmailAddressApiResponse apiResponseLocalVar, Option<bool> allowTeamAccess, Option<bool> useDomainPool, Option<DateTime> expiresAt, Option<long> expiresIn, Option<string> emailAddress, Option<string> inboxType, Option<string> description, Option<string> name, Option<List<string>> tags, Option<bool> favourite, Option<bool> virtualInbox, Option<bool> useShortAddress, Option<string> domainName, Option<Guid> domainId, Option<string> prefix)
        {
            bool suppressDefaultLog = false;
            AfterCreateNewEmailAddress(ref suppressDefaultLog, apiResponseLocalVar, allowTeamAccess, useDomainPool, expiresAt, expiresIn, emailAddress, inboxType, description, name, tags, favourite, virtualInbox, useShortAddress, domainName, domainId, prefix);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="allowTeamAccess"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="expiresAt"></param>
        /// <param name="expiresIn"></param>
        /// <param name="emailAddress"></param>
        /// <param name="inboxType"></param>
        /// <param name="description"></param>
        /// <param name="name"></param>
        /// <param name="tags"></param>
        /// <param name="favourite"></param>
        /// <param name="virtualInbox"></param>
        /// <param name="useShortAddress"></param>
        /// <param name="domainName"></param>
        /// <param name="domainId"></param>
        /// <param name="prefix"></param>
        partial void AfterCreateNewEmailAddress(ref bool suppressDefaultLog, ICreateNewEmailAddressApiResponse apiResponseLocalVar, Option<bool> allowTeamAccess, Option<bool> useDomainPool, Option<DateTime> expiresAt, Option<long> expiresIn, Option<string> emailAddress, Option<string> inboxType, Option<string> description, Option<string> name, Option<List<string>> tags, Option<bool> favourite, Option<bool> virtualInbox, Option<bool> useShortAddress, Option<string> domainName, Option<Guid> domainId, Option<string> prefix);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="allowTeamAccess"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="expiresAt"></param>
        /// <param name="expiresIn"></param>
        /// <param name="emailAddress"></param>
        /// <param name="inboxType"></param>
        /// <param name="description"></param>
        /// <param name="name"></param>
        /// <param name="tags"></param>
        /// <param name="favourite"></param>
        /// <param name="virtualInbox"></param>
        /// <param name="useShortAddress"></param>
        /// <param name="domainName"></param>
        /// <param name="domainId"></param>
        /// <param name="prefix"></param>
        private void OnErrorCreateNewEmailAddressDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool> allowTeamAccess, Option<bool> useDomainPool, Option<DateTime> expiresAt, Option<long> expiresIn, Option<string> emailAddress, Option<string> inboxType, Option<string> description, Option<string> name, Option<List<string>> tags, Option<bool> favourite, Option<bool> virtualInbox, Option<bool> useShortAddress, Option<string> domainName, Option<Guid> domainId, Option<string> prefix)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateNewEmailAddress(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, allowTeamAccess, useDomainPool, expiresAt, expiresIn, emailAddress, inboxType, description, name, tags, favourite, virtualInbox, useShortAddress, domainName, domainId, prefix);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="allowTeamAccess"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="expiresAt"></param>
        /// <param name="expiresIn"></param>
        /// <param name="emailAddress"></param>
        /// <param name="inboxType"></param>
        /// <param name="description"></param>
        /// <param name="name"></param>
        /// <param name="tags"></param>
        /// <param name="favourite"></param>
        /// <param name="virtualInbox"></param>
        /// <param name="useShortAddress"></param>
        /// <param name="domainName"></param>
        /// <param name="domainId"></param>
        /// <param name="prefix"></param>
        partial void OnErrorCreateNewEmailAddress(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool> allowTeamAccess, Option<bool> useDomainPool, Option<DateTime> expiresAt, Option<long> expiresIn, Option<string> emailAddress, Option<string> inboxType, Option<string> description, Option<string> name, Option<List<string>> tags, Option<bool> favourite, Option<bool> virtualInbox, Option<bool> useShortAddress, Option<string> domainName, Option<Guid> domainId, Option<string> prefix);

        /// <summary>
        /// Create new random inbox Returns an Inbox with an &#x60;id&#x60; and an &#x60;emailAddress&#x60;
        /// </summary>
        /// <param name="allowTeamAccess"> (optional)</param>
        /// <param name="useDomainPool"> (optional)</param>
        /// <param name="expiresAt"> (optional)</param>
        /// <param name="expiresIn"> (optional)</param>
        /// <param name="emailAddress"> (optional)</param>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="name"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="favourite"> (optional)</param>
        /// <param name="virtualInbox"> (optional)</param>
        /// <param name="useShortAddress"> (optional)</param>
        /// <param name="domainName"> (optional)</param>
        /// <param name="domainId"> (optional)</param>
        /// <param name="prefix"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateNewEmailAddressApiResponse"/>&gt;</returns>
        public async Task<ICreateNewEmailAddressApiResponse> CreateNewEmailAddressOrDefaultAsync(Option<bool> allowTeamAccess = default, Option<bool> useDomainPool = default, Option<DateTime> expiresAt = default, Option<long> expiresIn = default, Option<string> emailAddress = default, Option<string> inboxType = default, Option<string> description = default, Option<string> name = default, Option<List<string>> tags = default, Option<bool> favourite = default, Option<bool> virtualInbox = default, Option<bool> useShortAddress = default, Option<string> domainName = default, Option<Guid> domainId = default, Option<string> prefix = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateNewEmailAddressAsync(allowTeamAccess, useDomainPool, expiresAt, expiresIn, emailAddress, inboxType, description, name, tags, favourite, virtualInbox, useShortAddress, domainName, domainId, prefix, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create new random inbox Returns an Inbox with an &#x60;id&#x60; and an &#x60;emailAddress&#x60;
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowTeamAccess"> (optional)</param>
        /// <param name="useDomainPool"> (optional)</param>
        /// <param name="expiresAt"> (optional)</param>
        /// <param name="expiresIn"> (optional)</param>
        /// <param name="emailAddress"> (optional)</param>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="name"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="favourite"> (optional)</param>
        /// <param name="virtualInbox"> (optional)</param>
        /// <param name="useShortAddress"> (optional)</param>
        /// <param name="domainName"> (optional)</param>
        /// <param name="domainId"> (optional)</param>
        /// <param name="prefix"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateNewEmailAddressApiResponse"/>&gt;</returns>
        public async Task<ICreateNewEmailAddressApiResponse> CreateNewEmailAddressAsync(Option<bool> allowTeamAccess = default, Option<bool> useDomainPool = default, Option<DateTime> expiresAt = default, Option<long> expiresIn = default, Option<string> emailAddress = default, Option<string> inboxType = default, Option<string> description = default, Option<string> name = default, Option<List<string>> tags = default, Option<bool> favourite = default, Option<bool> virtualInbox = default, Option<bool> useShortAddress = default, Option<string> domainName = default, Option<Guid> domainId = default, Option<string> prefix = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateNewEmailAddress(emailAddress, inboxType, description, name, tags, domainName, prefix);

                FormatCreateNewEmailAddress(ref allowTeamAccess, ref useDomainPool, ref expiresAt, ref expiresIn, ref emailAddress, ref inboxType, ref description, ref name, tags, ref favourite, ref virtualInbox, ref useShortAddress, ref domainName, ref domainId, ref prefix);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/newEmailAddress"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/newEmailAddress");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (allowTeamAccess.IsSet)
                        parseQueryStringLocalVar["allowTeamAccess"] = ClientUtils.ParameterToString(allowTeamAccess.Value);

                    if (useDomainPool.IsSet)
                        parseQueryStringLocalVar["useDomainPool"] = ClientUtils.ParameterToString(useDomainPool.Value);

                    if (expiresAt.IsSet)
                        parseQueryStringLocalVar["expiresAt"] = ClientUtils.ParameterToString(expiresAt.Value);

                    if (expiresIn.IsSet)
                        parseQueryStringLocalVar["expiresIn"] = ClientUtils.ParameterToString(expiresIn.Value);

                    if (emailAddress.IsSet)
                        parseQueryStringLocalVar["emailAddress"] = ClientUtils.ParameterToString(emailAddress.Value);

                    if (inboxType.IsSet)
                        parseQueryStringLocalVar["inboxType"] = ClientUtils.ParameterToString(inboxType.Value);

                    if (description.IsSet)
                        parseQueryStringLocalVar["description"] = ClientUtils.ParameterToString(description.Value);

                    if (name.IsSet)
                        parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name.Value);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags.Value);

                    if (favourite.IsSet)
                        parseQueryStringLocalVar["favourite"] = ClientUtils.ParameterToString(favourite.Value);

                    if (virtualInbox.IsSet)
                        parseQueryStringLocalVar["virtualInbox"] = ClientUtils.ParameterToString(virtualInbox.Value);

                    if (useShortAddress.IsSet)
                        parseQueryStringLocalVar["useShortAddress"] = ClientUtils.ParameterToString(useShortAddress.Value);

                    if (domainName.IsSet)
                        parseQueryStringLocalVar["domainName"] = ClientUtils.ParameterToString(domainName.Value);

                    if (domainId.IsSet)
                        parseQueryStringLocalVar["domainId"] = ClientUtils.ParameterToString(domainId.Value);

                    if (prefix.IsSet)
                        parseQueryStringLocalVar["prefix"] = ClientUtils.ParameterToString(prefix.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<CreateNewEmailAddressApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateNewEmailAddressApiResponse>();

                        CreateNewEmailAddressApiResponse apiResponseLocalVar = new CreateNewEmailAddressApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/newEmailAddress", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateNewEmailAddressDefaultImplementation(apiResponseLocalVar, allowTeamAccess, useDomainPool, expiresAt, expiresIn, emailAddress, inboxType, description, name, tags, favourite, virtualInbox, useShortAddress, domainName, domainId, prefix);

                        Events.ExecuteOnCreateNewEmailAddress(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateNewEmailAddressDefaultImplementation(e, "/newEmailAddress", uriBuilderLocalVar.Path, allowTeamAccess, useDomainPool, expiresAt, expiresIn, emailAddress, inboxType, description, name, tags, favourite, virtualInbox, useShortAddress, domainName, domainId, prefix);
                Events.ExecuteOnErrorCreateNewEmailAddress(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateNewEmailAddressApiResponse"/>
        /// </summary>
        public partial class CreateNewEmailAddressApiResponse : mailslurp.Client.ApiResponse, ICreateNewEmailAddressApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateNewEmailAddressApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateNewEmailAddressApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateNewEmailAddressApiResponse(ILogger<CreateNewEmailAddressApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxDto Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out mailslurp.Model.InboxDto result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateRandomInbox(ref Option<bool> allowTeamAccess, ref Option<bool> useDomainPool, ref Option<DateTime> expiresAt, ref Option<long> expiresIn, ref Option<string> emailAddress, ref Option<string> inboxType, ref Option<string> description, ref Option<string> name, Option<List<string>> tags, ref Option<bool> favourite, ref Option<bool> virtualInbox, ref Option<bool> useShortAddress, ref Option<string> domainName, ref Option<Guid> domainId, ref Option<string> prefix);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="emailAddress"></param>
        /// <param name="inboxType"></param>
        /// <param name="description"></param>
        /// <param name="name"></param>
        /// <param name="tags"></param>
        /// <param name="domainName"></param>
        /// <param name="prefix"></param>
        /// <returns></returns>
        private void ValidateCreateRandomInbox(Option<string> emailAddress, Option<string> inboxType, Option<string> description, Option<string> name, Option<List<string>> tags, Option<string> domainName, Option<string> prefix)
        {
            if (emailAddress.IsSet && emailAddress.Value == null)
                throw new ArgumentNullException(nameof(emailAddress));

            if (inboxType.IsSet && inboxType.Value == null)
                throw new ArgumentNullException(nameof(inboxType));

            if (description.IsSet && description.Value == null)
                throw new ArgumentNullException(nameof(description));

            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name));

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));

            if (domainName.IsSet && domainName.Value == null)
                throw new ArgumentNullException(nameof(domainName));

            if (prefix.IsSet && prefix.Value == null)
                throw new ArgumentNullException(nameof(prefix));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="allowTeamAccess"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="expiresAt"></param>
        /// <param name="expiresIn"></param>
        /// <param name="emailAddress"></param>
        /// <param name="inboxType"></param>
        /// <param name="description"></param>
        /// <param name="name"></param>
        /// <param name="tags"></param>
        /// <param name="favourite"></param>
        /// <param name="virtualInbox"></param>
        /// <param name="useShortAddress"></param>
        /// <param name="domainName"></param>
        /// <param name="domainId"></param>
        /// <param name="prefix"></param>
        private void AfterCreateRandomInboxDefaultImplementation(ICreateRandomInboxApiResponse apiResponseLocalVar, Option<bool> allowTeamAccess, Option<bool> useDomainPool, Option<DateTime> expiresAt, Option<long> expiresIn, Option<string> emailAddress, Option<string> inboxType, Option<string> description, Option<string> name, Option<List<string>> tags, Option<bool> favourite, Option<bool> virtualInbox, Option<bool> useShortAddress, Option<string> domainName, Option<Guid> domainId, Option<string> prefix)
        {
            bool suppressDefaultLog = false;
            AfterCreateRandomInbox(ref suppressDefaultLog, apiResponseLocalVar, allowTeamAccess, useDomainPool, expiresAt, expiresIn, emailAddress, inboxType, description, name, tags, favourite, virtualInbox, useShortAddress, domainName, domainId, prefix);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="allowTeamAccess"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="expiresAt"></param>
        /// <param name="expiresIn"></param>
        /// <param name="emailAddress"></param>
        /// <param name="inboxType"></param>
        /// <param name="description"></param>
        /// <param name="name"></param>
        /// <param name="tags"></param>
        /// <param name="favourite"></param>
        /// <param name="virtualInbox"></param>
        /// <param name="useShortAddress"></param>
        /// <param name="domainName"></param>
        /// <param name="domainId"></param>
        /// <param name="prefix"></param>
        partial void AfterCreateRandomInbox(ref bool suppressDefaultLog, ICreateRandomInboxApiResponse apiResponseLocalVar, Option<bool> allowTeamAccess, Option<bool> useDomainPool, Option<DateTime> expiresAt, Option<long> expiresIn, Option<string> emailAddress, Option<string> inboxType, Option<string> description, Option<string> name, Option<List<string>> tags, Option<bool> favourite, Option<bool> virtualInbox, Option<bool> useShortAddress, Option<string> domainName, Option<Guid> domainId, Option<string> prefix);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="allowTeamAccess"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="expiresAt"></param>
        /// <param name="expiresIn"></param>
        /// <param name="emailAddress"></param>
        /// <param name="inboxType"></param>
        /// <param name="description"></param>
        /// <param name="name"></param>
        /// <param name="tags"></param>
        /// <param name="favourite"></param>
        /// <param name="virtualInbox"></param>
        /// <param name="useShortAddress"></param>
        /// <param name="domainName"></param>
        /// <param name="domainId"></param>
        /// <param name="prefix"></param>
        private void OnErrorCreateRandomInboxDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool> allowTeamAccess, Option<bool> useDomainPool, Option<DateTime> expiresAt, Option<long> expiresIn, Option<string> emailAddress, Option<string> inboxType, Option<string> description, Option<string> name, Option<List<string>> tags, Option<bool> favourite, Option<bool> virtualInbox, Option<bool> useShortAddress, Option<string> domainName, Option<Guid> domainId, Option<string> prefix)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateRandomInbox(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, allowTeamAccess, useDomainPool, expiresAt, expiresIn, emailAddress, inboxType, description, name, tags, favourite, virtualInbox, useShortAddress, domainName, domainId, prefix);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="allowTeamAccess"></param>
        /// <param name="useDomainPool"></param>
        /// <param name="expiresAt"></param>
        /// <param name="expiresIn"></param>
        /// <param name="emailAddress"></param>
        /// <param name="inboxType"></param>
        /// <param name="description"></param>
        /// <param name="name"></param>
        /// <param name="tags"></param>
        /// <param name="favourite"></param>
        /// <param name="virtualInbox"></param>
        /// <param name="useShortAddress"></param>
        /// <param name="domainName"></param>
        /// <param name="domainId"></param>
        /// <param name="prefix"></param>
        partial void OnErrorCreateRandomInbox(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool> allowTeamAccess, Option<bool> useDomainPool, Option<DateTime> expiresAt, Option<long> expiresIn, Option<string> emailAddress, Option<string> inboxType, Option<string> description, Option<string> name, Option<List<string>> tags, Option<bool> favourite, Option<bool> virtualInbox, Option<bool> useShortAddress, Option<string> domainName, Option<Guid> domainId, Option<string> prefix);

        /// <summary>
        /// Create new random inbox Returns an Inbox with an &#x60;id&#x60; and an &#x60;emailAddress&#x60;
        /// </summary>
        /// <param name="allowTeamAccess"> (optional)</param>
        /// <param name="useDomainPool"> (optional)</param>
        /// <param name="expiresAt"> (optional)</param>
        /// <param name="expiresIn"> (optional)</param>
        /// <param name="emailAddress"> (optional)</param>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="name"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="favourite"> (optional)</param>
        /// <param name="virtualInbox"> (optional)</param>
        /// <param name="useShortAddress"> (optional)</param>
        /// <param name="domainName"> (optional)</param>
        /// <param name="domainId"> (optional)</param>
        /// <param name="prefix"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRandomInboxApiResponse"/>&gt;</returns>
        public async Task<ICreateRandomInboxApiResponse> CreateRandomInboxOrDefaultAsync(Option<bool> allowTeamAccess = default, Option<bool> useDomainPool = default, Option<DateTime> expiresAt = default, Option<long> expiresIn = default, Option<string> emailAddress = default, Option<string> inboxType = default, Option<string> description = default, Option<string> name = default, Option<List<string>> tags = default, Option<bool> favourite = default, Option<bool> virtualInbox = default, Option<bool> useShortAddress = default, Option<string> domainName = default, Option<Guid> domainId = default, Option<string> prefix = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateRandomInboxAsync(allowTeamAccess, useDomainPool, expiresAt, expiresIn, emailAddress, inboxType, description, name, tags, favourite, virtualInbox, useShortAddress, domainName, domainId, prefix, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create new random inbox Returns an Inbox with an &#x60;id&#x60; and an &#x60;emailAddress&#x60;
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowTeamAccess"> (optional)</param>
        /// <param name="useDomainPool"> (optional)</param>
        /// <param name="expiresAt"> (optional)</param>
        /// <param name="expiresIn"> (optional)</param>
        /// <param name="emailAddress"> (optional)</param>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="name"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="favourite"> (optional)</param>
        /// <param name="virtualInbox"> (optional)</param>
        /// <param name="useShortAddress"> (optional)</param>
        /// <param name="domainName"> (optional)</param>
        /// <param name="domainId"> (optional)</param>
        /// <param name="prefix"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRandomInboxApiResponse"/>&gt;</returns>
        public async Task<ICreateRandomInboxApiResponse> CreateRandomInboxAsync(Option<bool> allowTeamAccess = default, Option<bool> useDomainPool = default, Option<DateTime> expiresAt = default, Option<long> expiresIn = default, Option<string> emailAddress = default, Option<string> inboxType = default, Option<string> description = default, Option<string> name = default, Option<List<string>> tags = default, Option<bool> favourite = default, Option<bool> virtualInbox = default, Option<bool> useShortAddress = default, Option<string> domainName = default, Option<Guid> domainId = default, Option<string> prefix = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateRandomInbox(emailAddress, inboxType, description, name, tags, domainName, prefix);

                FormatCreateRandomInbox(ref allowTeamAccess, ref useDomainPool, ref expiresAt, ref expiresIn, ref emailAddress, ref inboxType, ref description, ref name, tags, ref favourite, ref virtualInbox, ref useShortAddress, ref domainName, ref domainId, ref prefix);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/createInbox"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/createInbox");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (allowTeamAccess.IsSet)
                        parseQueryStringLocalVar["allowTeamAccess"] = ClientUtils.ParameterToString(allowTeamAccess.Value);

                    if (useDomainPool.IsSet)
                        parseQueryStringLocalVar["useDomainPool"] = ClientUtils.ParameterToString(useDomainPool.Value);

                    if (expiresAt.IsSet)
                        parseQueryStringLocalVar["expiresAt"] = ClientUtils.ParameterToString(expiresAt.Value);

                    if (expiresIn.IsSet)
                        parseQueryStringLocalVar["expiresIn"] = ClientUtils.ParameterToString(expiresIn.Value);

                    if (emailAddress.IsSet)
                        parseQueryStringLocalVar["emailAddress"] = ClientUtils.ParameterToString(emailAddress.Value);

                    if (inboxType.IsSet)
                        parseQueryStringLocalVar["inboxType"] = ClientUtils.ParameterToString(inboxType.Value);

                    if (description.IsSet)
                        parseQueryStringLocalVar["description"] = ClientUtils.ParameterToString(description.Value);

                    if (name.IsSet)
                        parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name.Value);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags.Value);

                    if (favourite.IsSet)
                        parseQueryStringLocalVar["favourite"] = ClientUtils.ParameterToString(favourite.Value);

                    if (virtualInbox.IsSet)
                        parseQueryStringLocalVar["virtualInbox"] = ClientUtils.ParameterToString(virtualInbox.Value);

                    if (useShortAddress.IsSet)
                        parseQueryStringLocalVar["useShortAddress"] = ClientUtils.ParameterToString(useShortAddress.Value);

                    if (domainName.IsSet)
                        parseQueryStringLocalVar["domainName"] = ClientUtils.ParameterToString(domainName.Value);

                    if (domainId.IsSet)
                        parseQueryStringLocalVar["domainId"] = ClientUtils.ParameterToString(domainId.Value);

                    if (prefix.IsSet)
                        parseQueryStringLocalVar["prefix"] = ClientUtils.ParameterToString(prefix.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<CreateRandomInboxApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateRandomInboxApiResponse>();

                        CreateRandomInboxApiResponse apiResponseLocalVar = new CreateRandomInboxApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/createInbox", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateRandomInboxDefaultImplementation(apiResponseLocalVar, allowTeamAccess, useDomainPool, expiresAt, expiresIn, emailAddress, inboxType, description, name, tags, favourite, virtualInbox, useShortAddress, domainName, domainId, prefix);

                        Events.ExecuteOnCreateRandomInbox(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateRandomInboxDefaultImplementation(e, "/createInbox", uriBuilderLocalVar.Path, allowTeamAccess, useDomainPool, expiresAt, expiresIn, emailAddress, inboxType, description, name, tags, favourite, virtualInbox, useShortAddress, domainName, domainId, prefix);
                Events.ExecuteOnErrorCreateRandomInbox(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateRandomInboxApiResponse"/>
        /// </summary>
        public partial class CreateRandomInboxApiResponse : mailslurp.Client.ApiResponse, ICreateRandomInboxApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateRandomInboxApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateRandomInboxApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateRandomInboxApiResponse(ILogger<CreateRandomInboxApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxDto Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out mailslurp.Model.InboxDto result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteEmailAddress(ref Guid inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterDeleteEmailAddressDefaultImplementation(IDeleteEmailAddressApiResponse apiResponseLocalVar, Guid inboxId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteEmailAddress(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterDeleteEmailAddress(ref bool suppressDefaultLog, IDeleteEmailAddressApiResponse apiResponseLocalVar, Guid inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorDeleteEmailAddressDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteEmailAddress(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorDeleteEmailAddress(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId);

        /// <summary>
        /// Delete inbox email address by inbox id Deletes inbox email address
        /// </summary>
        /// <param name="inboxId">ID of inbox to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteEmailAddressApiResponse"/>&gt;</returns>
        public async Task<IDeleteEmailAddressApiResponse> DeleteEmailAddressOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteEmailAddressAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete inbox email address by inbox id Deletes inbox email address
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteEmailAddressApiResponse"/>&gt;</returns>
        public async Task<IDeleteEmailAddressApiResponse> DeleteEmailAddressAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteEmailAddress(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/deleteEmailAddress"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/deleteEmailAddress");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DeleteEmailAddressApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteEmailAddressApiResponse>();

                        DeleteEmailAddressApiResponse apiResponseLocalVar = new DeleteEmailAddressApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/deleteEmailAddress", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteEmailAddressDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnDeleteEmailAddress(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteEmailAddressDefaultImplementation(e, "/deleteEmailAddress", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorDeleteEmailAddress(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteEmailAddressApiResponse"/>
        /// </summary>
        public partial class DeleteEmailAddressApiResponse : mailslurp.Client.ApiResponse, IDeleteEmailAddressApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteEmailAddressApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteEmailAddressApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteEmailAddressApiResponse(ILogger<DeleteEmailAddressApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEmptyInbox(ref Guid inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterEmptyInboxDefaultImplementation(IEmptyInboxApiResponse apiResponseLocalVar, Guid inboxId)
        {
            bool suppressDefaultLog = false;
            AfterEmptyInbox(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterEmptyInbox(ref bool suppressDefaultLog, IEmptyInboxApiResponse apiResponseLocalVar, Guid inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorEmptyInboxDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorEmptyInbox(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorEmptyInbox(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId);

        /// <summary>
        /// Delete all emails in an inbox Deletes all emails
        /// </summary>
        /// <param name="inboxId">ID of inbox to empty</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEmptyInboxApiResponse"/>&gt;</returns>
        public async Task<IEmptyInboxApiResponse> EmptyInboxOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EmptyInboxAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete all emails in an inbox Deletes all emails
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox to empty</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEmptyInboxApiResponse"/>&gt;</returns>
        public async Task<IEmptyInboxApiResponse> EmptyInboxAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatEmptyInbox(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/emptyInbox"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/emptyInbox");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<EmptyInboxApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EmptyInboxApiResponse>();

                        EmptyInboxApiResponse apiResponseLocalVar = new EmptyInboxApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/emptyInbox", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEmptyInboxDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnEmptyInbox(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEmptyInboxDefaultImplementation(e, "/emptyInbox", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorEmptyInbox(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EmptyInboxApiResponse"/>
        /// </summary>
        public partial class EmptyInboxApiResponse : mailslurp.Client.ApiResponse, IEmptyInboxApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EmptyInboxApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EmptyInboxApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EmptyInboxApiResponse(ILogger<EmptyInboxApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendEmailQuery(ref string to, ref Option<Guid> senderId, ref Option<string> body, ref Option<string> subject);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="to"></param>
        /// <param name="body"></param>
        /// <param name="subject"></param>
        /// <returns></returns>
        private void ValidateSendEmailQuery(string to, Option<string> body, Option<string> subject)
        {
            if (to == null)
                throw new ArgumentNullException(nameof(to));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));

            if (subject.IsSet && subject.Value == null)
                throw new ArgumentNullException(nameof(subject));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="to"></param>
        /// <param name="senderId"></param>
        /// <param name="body"></param>
        /// <param name="subject"></param>
        private void AfterSendEmailQueryDefaultImplementation(ISendEmailQueryApiResponse apiResponseLocalVar, string to, Option<Guid> senderId, Option<string> body, Option<string> subject)
        {
            bool suppressDefaultLog = false;
            AfterSendEmailQuery(ref suppressDefaultLog, apiResponseLocalVar, to, senderId, body, subject);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="to"></param>
        /// <param name="senderId"></param>
        /// <param name="body"></param>
        /// <param name="subject"></param>
        partial void AfterSendEmailQuery(ref bool suppressDefaultLog, ISendEmailQueryApiResponse apiResponseLocalVar, string to, Option<Guid> senderId, Option<string> body, Option<string> subject);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="to"></param>
        /// <param name="senderId"></param>
        /// <param name="body"></param>
        /// <param name="subject"></param>
        private void OnErrorSendEmailQueryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string to, Option<Guid> senderId, Option<string> body, Option<string> subject)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendEmailQuery(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, to, senderId, body, subject);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="to"></param>
        /// <param name="senderId"></param>
        /// <param name="body"></param>
        /// <param name="subject"></param>
        partial void OnErrorSendEmailQuery(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string to, Option<Guid> senderId, Option<string> body, Option<string> subject);

        /// <summary>
        /// Send an email using query parameters If no senderId or inboxId provided a random email address will be used to send from. Ensure your parameters are URL encoded.
        /// </summary>
        /// <param name="to">Email address to send to</param>
        /// <param name="senderId">ID of inbox to send from. If null an inbox will be created for sending (optional)</param>
        /// <param name="body">Body of the email message. Supports HTML (optional)</param>
        /// <param name="subject">Subject line of the email (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailQueryApiResponse"/>&gt;</returns>
        public async Task<ISendEmailQueryApiResponse> SendEmailQueryOrDefaultAsync(string to, Option<Guid> senderId = default, Option<string> body = default, Option<string> subject = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendEmailQueryAsync(to, senderId, body, subject, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send an email using query parameters If no senderId or inboxId provided a random email address will be used to send from. Ensure your parameters are URL encoded.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="to">Email address to send to</param>
        /// <param name="senderId">ID of inbox to send from. If null an inbox will be created for sending (optional)</param>
        /// <param name="body">Body of the email message. Supports HTML (optional)</param>
        /// <param name="subject">Subject line of the email (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailQueryApiResponse"/>&gt;</returns>
        public async Task<ISendEmailQueryApiResponse> SendEmailQueryAsync(string to, Option<Guid> senderId = default, Option<string> body = default, Option<string> subject = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendEmailQuery(to, body, subject);

                FormatSendEmailQuery(ref to, ref senderId, ref body, ref subject);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/sendEmailQuery"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/sendEmailQuery");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["to"] = ClientUtils.ParameterToString(to);

                    if (senderId.IsSet)
                        parseQueryStringLocalVar["senderId"] = ClientUtils.ParameterToString(senderId.Value);

                    if (body.IsSet)
                        parseQueryStringLocalVar["body"] = ClientUtils.ParameterToString(body.Value);

                    if (subject.IsSet)
                        parseQueryStringLocalVar["subject"] = ClientUtils.ParameterToString(subject.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SendEmailQueryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendEmailQueryApiResponse>();

                        SendEmailQueryApiResponse apiResponseLocalVar = new SendEmailQueryApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/sendEmailQuery", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendEmailQueryDefaultImplementation(apiResponseLocalVar, to, senderId, body, subject);

                        Events.ExecuteOnSendEmailQuery(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendEmailQueryDefaultImplementation(e, "/sendEmailQuery", uriBuilderLocalVar.Path, to, senderId, body, subject);
                Events.ExecuteOnErrorSendEmailQuery(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendEmailQueryApiResponse"/>
        /// </summary>
        public partial class SendEmailQueryApiResponse : mailslurp.Client.ApiResponse, ISendEmailQueryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendEmailQueryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendEmailQueryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendEmailQueryApiResponse(ILogger<SendEmailQueryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendEmailSimple(SimpleSendEmailOptions simpleSendEmailOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="simpleSendEmailOptions"></param>
        /// <returns></returns>
        private void ValidateSendEmailSimple(SimpleSendEmailOptions simpleSendEmailOptions)
        {
            if (simpleSendEmailOptions == null)
                throw new ArgumentNullException(nameof(simpleSendEmailOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="simpleSendEmailOptions"></param>
        private void AfterSendEmailSimpleDefaultImplementation(ISendEmailSimpleApiResponse apiResponseLocalVar, SimpleSendEmailOptions simpleSendEmailOptions)
        {
            bool suppressDefaultLog = false;
            AfterSendEmailSimple(ref suppressDefaultLog, apiResponseLocalVar, simpleSendEmailOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="simpleSendEmailOptions"></param>
        partial void AfterSendEmailSimple(ref bool suppressDefaultLog, ISendEmailSimpleApiResponse apiResponseLocalVar, SimpleSendEmailOptions simpleSendEmailOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="simpleSendEmailOptions"></param>
        private void OnErrorSendEmailSimpleDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SimpleSendEmailOptions simpleSendEmailOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendEmailSimple(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, simpleSendEmailOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="simpleSendEmailOptions"></param>
        partial void OnErrorSendEmailSimple(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, SimpleSendEmailOptions simpleSendEmailOptions);

        /// <summary>
        /// Send an email If no senderId or inboxId provided a random email address will be used to send from.
        /// </summary>
        /// <param name="simpleSendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailSimpleApiResponse"/>&gt;</returns>
        public async Task<ISendEmailSimpleApiResponse> SendEmailSimpleOrDefaultAsync(SimpleSendEmailOptions simpleSendEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendEmailSimpleAsync(simpleSendEmailOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send an email If no senderId or inboxId provided a random email address will be used to send from.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="simpleSendEmailOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendEmailSimpleApiResponse"/>&gt;</returns>
        public async Task<ISendEmailSimpleApiResponse> SendEmailSimpleAsync(SimpleSendEmailOptions simpleSendEmailOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendEmailSimple(simpleSendEmailOptions);

                FormatSendEmailSimple(simpleSendEmailOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/sendEmail"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/sendEmail");

                    httpRequestMessageLocalVar.Content = (simpleSendEmailOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(simpleSendEmailOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<SendEmailSimpleApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendEmailSimpleApiResponse>();

                        SendEmailSimpleApiResponse apiResponseLocalVar = new SendEmailSimpleApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/sendEmail", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendEmailSimpleDefaultImplementation(apiResponseLocalVar, simpleSendEmailOptions);

                        Events.ExecuteOnSendEmailSimple(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendEmailSimpleDefaultImplementation(e, "/sendEmail", uriBuilderLocalVar.Path, simpleSendEmailOptions);
                Events.ExecuteOnErrorSendEmailSimple(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendEmailSimpleApiResponse"/>
        /// </summary>
        public partial class SendEmailSimpleApiResponse : mailslurp.Client.ApiResponse, ISendEmailSimpleApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendEmailSimpleApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendEmailSimpleApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendEmailSimpleApiResponse(ILogger<SendEmailSimpleApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
