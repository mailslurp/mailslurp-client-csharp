// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IAttachmentControllerApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        AttachmentControllerApiEvents Events { get; }

        /// <summary>
        /// Delete all attachments
        /// </summary>
        /// <remarks>
        /// Delete all attachments
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllAttachmentsApiResponse"/>&gt;</returns>
        Task<IDeleteAllAttachmentsApiResponse> DeleteAllAttachmentsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete all attachments
        /// </summary>
        /// <remarks>
        /// Delete all attachments
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllAttachmentsApiResponse"/>&gt;</returns>
        Task<IDeleteAllAttachmentsApiResponse> DeleteAllAttachmentsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an attachment
        /// </summary>
        /// <remarks>
        /// Delete an attachment
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAttachmentApiResponse"/>&gt;</returns>
        Task<IDeleteAttachmentApiResponse> DeleteAttachmentAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an attachment
        /// </summary>
        /// <remarks>
        /// Delete an attachment
        /// </remarks>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAttachmentApiResponse"/>&gt;</returns>
        Task<IDeleteAttachmentApiResponse> DeleteAttachmentOrDefaultAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentAsBase64EncodedApiResponse"/>&gt;</returns>
        Task<IDownloadAttachmentAsBase64EncodedApiResponse> DownloadAttachmentAsBase64EncodedAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </remarks>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentAsBase64EncodedApiResponse"/>&gt;</returns>
        Task<IDownloadAttachmentAsBase64EncodedApiResponse> DownloadAttachmentAsBase64EncodedOrDefaultAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Download attachments. Get email attachment bytes. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentAsBytesApiResponse"/>&gt;</returns>
        Task<IDownloadAttachmentAsBytesApiResponse> DownloadAttachmentAsBytesAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Download attachments. Get email attachment bytes. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints.
        /// </summary>
        /// <remarks>
        /// Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </remarks>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentAsBytesApiResponse"/>&gt;</returns>
        Task<IDownloadAttachmentAsBytesApiResponse> DownloadAttachmentAsBytesOrDefaultAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an attachment entity
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentApiResponse"/>&gt;</returns>
        Task<IGetAttachmentApiResponse> GetAttachmentAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an attachment entity
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentApiResponse"/>&gt;</returns>
        Task<IGetAttachmentApiResponse> GetAttachmentOrDefaultAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment metadata information
        /// </summary>
        /// <remarks>
        /// Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties &#x60;name&#x60; and &#x60;content-type&#x60; and &#x60;content-length&#x60; in bytes for a given attachment.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentInfoApiResponse"/>&gt;</returns>
        Task<IGetAttachmentInfoApiResponse> GetAttachmentInfoAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachment metadata information
        /// </summary>
        /// <remarks>
        /// Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties &#x60;name&#x60; and &#x60;content-type&#x60; and &#x60;content-length&#x60; in bytes for a given attachment.
        /// </remarks>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentInfoApiResponse"/>&gt;</returns>
        Task<IGetAttachmentInfoApiResponse> GetAttachmentInfoOrDefaultAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachments
        /// </summary>
        /// <remarks>
        /// Get all attachments in paginated response. Each entity contains meta data for the attachment such as &#x60;name&#x60; and &#x60;content-type&#x60;. Use the &#x60;attachmentId&#x60; and the download endpoints to get the file contents.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index for list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size for list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="fileNameFilter">Optional file name and content type search filter (optional)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="inboxId">Optional inboxId to filter attachments by (optional)</param>
        /// <param name="emailId">Optional emailId to filter attachments by (optional)</param>
        /// <param name="sentEmailId">Optional sentEmailId to filter attachments by (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentsApiResponse"/>&gt;</returns>
        Task<IGetAttachmentsApiResponse> GetAttachmentsAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> fileNameFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<Guid> inboxId = default, Option<Guid> emailId = default, Option<Guid> sentEmailId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get email attachments
        /// </summary>
        /// <remarks>
        /// Get all attachments in paginated response. Each entity contains meta data for the attachment such as &#x60;name&#x60; and &#x60;content-type&#x60;. Use the &#x60;attachmentId&#x60; and the download endpoints to get the file contents.
        /// </remarks>
        /// <param name="page">Optional page index for list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size for list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="fileNameFilter">Optional file name and content type search filter (optional)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="inboxId">Optional inboxId to filter attachments by (optional)</param>
        /// <param name="emailId">Optional emailId to filter attachments by (optional)</param>
        /// <param name="sentEmailId">Optional sentEmailId to filter attachments by (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentsApiResponse"/>&gt;</returns>
        Task<IGetAttachmentsApiResponse> GetAttachmentsOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> fileNameFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<Guid> inboxId = default, Option<Guid> emailId = default, Option<Guid> sentEmailId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadAttachmentOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadAttachmentApiResponse"/>&gt;</returns>
        Task<IUploadAttachmentApiResponse> UploadAttachmentAsync(UploadAttachmentOptions uploadAttachmentOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="uploadAttachmentOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadAttachmentApiResponse"/>&gt;</returns>
        Task<IUploadAttachmentApiResponse> UploadAttachmentOrDefaultAsync(UploadAttachmentOptions uploadAttachmentOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType"> (optional)</param>
        /// <param name="contentType2">Optional contentType for file. For instance &#x60;application/pdf&#x60; (optional)</param>
        /// <param name="contentId">Optional content ID (CID) to save upload with (optional)</param>
        /// <param name="filename">Optional filename to save upload with (optional)</param>
        /// <param name="fileSize">Optional byte length to save upload with (optional)</param>
        /// <param name="filename2"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadAttachmentBytesApiResponse"/>&gt;</returns>
        Task<IUploadAttachmentBytesApiResponse> UploadAttachmentBytesAsync(Option<string> contentType = default, Option<string> contentType2 = default, Option<string> contentId = default, Option<string> filename = default, Option<long> fileSize = default, Option<string> filename2 = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="contentType"> (optional)</param>
        /// <param name="contentType2">Optional contentType for file. For instance &#x60;application/pdf&#x60; (optional)</param>
        /// <param name="contentId">Optional content ID (CID) to save upload with (optional)</param>
        /// <param name="filename">Optional filename to save upload with (optional)</param>
        /// <param name="fileSize">Optional byte length to save upload with (optional)</param>
        /// <param name="filename2"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadAttachmentBytesApiResponse"/>&gt;</returns>
        Task<IUploadAttachmentBytesApiResponse> UploadAttachmentBytesOrDefaultAsync(Option<string> contentType = default, Option<string> contentType2 = default, Option<string> contentId = default, Option<string> filename = default, Option<long> fileSize = default, Option<string> filename2 = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentId">Optional content ID of attachment (optional)</param>
        /// <param name="contentType">Optional content type of attachment (optional)</param>
        /// <param name="filename">Optional name of file (optional)</param>
        /// <param name="contentTypeHeader">Optional content type header of attachment (optional)</param>
        /// <param name="xFilename">Optional filename header of attachment (optional)</param>
        /// <param name="xFilenameRaw">Optional raw filename header of attachment that will be converted to punycode (optional)</param>
        /// <param name="xFilesize">Optional content size of attachment (optional)</param>
        /// <param name="uploadMultipartFormRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadMultipartFormApiResponse"/>&gt;</returns>
        Task<IUploadMultipartFormApiResponse> UploadMultipartFormAsync(Option<string> contentId = default, Option<string> contentType = default, Option<string> filename = default, Option<string> contentTypeHeader = default, Option<string> xFilename = default, Option<string> xFilenameRaw = default, Option<long> xFilesize = default, Option<UploadMultipartFormRequest> uploadMultipartFormRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="contentId">Optional content ID of attachment (optional)</param>
        /// <param name="contentType">Optional content type of attachment (optional)</param>
        /// <param name="filename">Optional name of file (optional)</param>
        /// <param name="contentTypeHeader">Optional content type header of attachment (optional)</param>
        /// <param name="xFilename">Optional filename header of attachment (optional)</param>
        /// <param name="xFilenameRaw">Optional raw filename header of attachment that will be converted to punycode (optional)</param>
        /// <param name="xFilesize">Optional content size of attachment (optional)</param>
        /// <param name="uploadMultipartFormRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadMultipartFormApiResponse"/>&gt;</returns>
        Task<IUploadMultipartFormApiResponse> UploadMultipartFormOrDefaultAsync(Option<string> contentId = default, Option<string> contentType = default, Option<string> filename = default, Option<string> contentTypeHeader = default, Option<string> xFilename = default, Option<string> xFilenameRaw = default, Option<long> xFilesize = default, Option<UploadMultipartFormRequest> uploadMultipartFormRequest = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IDeleteAllAttachmentsApiResponse"/>
    /// </summary>
    public interface IDeleteAllAttachmentsApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteAttachmentApiResponse"/>
    /// </summary>
    public interface IDeleteAttachmentApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IDownloadAttachmentAsBase64EncodedApiResponse"/>
    /// </summary>
    public interface IDownloadAttachmentAsBase64EncodedApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.DownloadAttachmentDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDownloadAttachmentAsBytesApiResponse"/>
    /// </summary>
    public interface IDownloadAttachmentAsBytesApiResponse : mailslurp.Client.IApiResponse, IDefault<byte[]>
    {
        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IGetAttachmentApiResponse"/>
    /// </summary>
    public interface IGetAttachmentApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.AttachmentEntityDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetAttachmentInfoApiResponse"/>
    /// </summary>
    public interface IGetAttachmentInfoApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.AttachmentMetaData>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetAttachmentsApiResponse"/>
    /// </summary>
    public interface IGetAttachmentsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageAttachmentEntity>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUploadAttachmentApiResponse"/>
    /// </summary>
    public interface IUploadAttachmentApiResponse : mailslurp.Client.IApiResponse, ICreated<List<string>>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IUploadAttachmentBytesApiResponse"/>
    /// </summary>
    public interface IUploadAttachmentBytesApiResponse : mailslurp.Client.IApiResponse, ICreated<List<string>>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IUploadMultipartFormApiResponse"/>
    /// </summary>
    public interface IUploadMultipartFormApiResponse : mailslurp.Client.IApiResponse, ICreated<List<string>>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class AttachmentControllerApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteAllAttachments;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteAllAttachments;

        internal void ExecuteOnDeleteAllAttachments(AttachmentControllerApi.DeleteAllAttachmentsApiResponse apiResponse)
        {
            OnDeleteAllAttachments?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteAllAttachments(Exception exception)
        {
            OnErrorDeleteAllAttachments?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteAttachment;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteAttachment;

        internal void ExecuteOnDeleteAttachment(AttachmentControllerApi.DeleteAttachmentApiResponse apiResponse)
        {
            OnDeleteAttachment?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteAttachment(Exception exception)
        {
            OnErrorDeleteAttachment?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDownloadAttachmentAsBase64Encoded;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDownloadAttachmentAsBase64Encoded;

        internal void ExecuteOnDownloadAttachmentAsBase64Encoded(AttachmentControllerApi.DownloadAttachmentAsBase64EncodedApiResponse apiResponse)
        {
            OnDownloadAttachmentAsBase64Encoded?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDownloadAttachmentAsBase64Encoded(Exception exception)
        {
            OnErrorDownloadAttachmentAsBase64Encoded?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDownloadAttachmentAsBytes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDownloadAttachmentAsBytes;

        internal void ExecuteOnDownloadAttachmentAsBytes(AttachmentControllerApi.DownloadAttachmentAsBytesApiResponse apiResponse)
        {
            OnDownloadAttachmentAsBytes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDownloadAttachmentAsBytes(Exception exception)
        {
            OnErrorDownloadAttachmentAsBytes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetAttachment;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetAttachment;

        internal void ExecuteOnGetAttachment(AttachmentControllerApi.GetAttachmentApiResponse apiResponse)
        {
            OnGetAttachment?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAttachment(Exception exception)
        {
            OnErrorGetAttachment?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetAttachmentInfo;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetAttachmentInfo;

        internal void ExecuteOnGetAttachmentInfo(AttachmentControllerApi.GetAttachmentInfoApiResponse apiResponse)
        {
            OnGetAttachmentInfo?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAttachmentInfo(Exception exception)
        {
            OnErrorGetAttachmentInfo?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetAttachments;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetAttachments;

        internal void ExecuteOnGetAttachments(AttachmentControllerApi.GetAttachmentsApiResponse apiResponse)
        {
            OnGetAttachments?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAttachments(Exception exception)
        {
            OnErrorGetAttachments?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUploadAttachment;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUploadAttachment;

        internal void ExecuteOnUploadAttachment(AttachmentControllerApi.UploadAttachmentApiResponse apiResponse)
        {
            OnUploadAttachment?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUploadAttachment(Exception exception)
        {
            OnErrorUploadAttachment?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUploadAttachmentBytes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUploadAttachmentBytes;

        internal void ExecuteOnUploadAttachmentBytes(AttachmentControllerApi.UploadAttachmentBytesApiResponse apiResponse)
        {
            OnUploadAttachmentBytes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUploadAttachmentBytes(Exception exception)
        {
            OnErrorUploadAttachmentBytes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUploadMultipartForm;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUploadMultipartForm;

        internal void ExecuteOnUploadMultipartForm(AttachmentControllerApi.UploadMultipartFormApiResponse apiResponse)
        {
            OnUploadMultipartForm?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUploadMultipartForm(Exception exception)
        {
            OnErrorUploadMultipartForm?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class AttachmentControllerApi : IAttachmentControllerApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<AttachmentControllerApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public AttachmentControllerApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AttachmentControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AttachmentControllerApi(ILogger<AttachmentControllerApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, AttachmentControllerApiEvents attachmentControllerApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<AttachmentControllerApi>();
            HttpClient = httpClient;
            Events = attachmentControllerApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterDeleteAllAttachmentsDefaultImplementation(IDeleteAllAttachmentsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterDeleteAllAttachments(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterDeleteAllAttachments(ref bool suppressDefaultLog, IDeleteAllAttachmentsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorDeleteAllAttachmentsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteAllAttachments(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorDeleteAllAttachments(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Delete all attachments Delete all attachments
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllAttachmentsApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllAttachmentsApiResponse> DeleteAllAttachmentsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteAllAttachmentsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete all attachments Delete all attachments
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAllAttachmentsApiResponse"/>&gt;</returns>
        public async Task<IDeleteAllAttachmentsApiResponse> DeleteAllAttachmentsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/attachments"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/attachments");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DeleteAllAttachmentsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteAllAttachmentsApiResponse>();

                        DeleteAllAttachmentsApiResponse apiResponseLocalVar = new DeleteAllAttachmentsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/attachments", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteAllAttachmentsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnDeleteAllAttachments(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteAllAttachmentsDefaultImplementation(e, "/attachments", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorDeleteAllAttachments(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteAllAttachmentsApiResponse"/>
        /// </summary>
        public partial class DeleteAllAttachmentsApiResponse : mailslurp.Client.ApiResponse, IDeleteAllAttachmentsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteAllAttachmentsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteAllAttachmentsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteAllAttachmentsApiResponse(ILogger<DeleteAllAttachmentsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteAttachment(ref string attachmentId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="attachmentId"></param>
        /// <returns></returns>
        private void ValidateDeleteAttachment(string attachmentId)
        {
            if (attachmentId == null)
                throw new ArgumentNullException(nameof(attachmentId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="attachmentId"></param>
        private void AfterDeleteAttachmentDefaultImplementation(IDeleteAttachmentApiResponse apiResponseLocalVar, string attachmentId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteAttachment(ref suppressDefaultLog, apiResponseLocalVar, attachmentId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="attachmentId"></param>
        partial void AfterDeleteAttachment(ref bool suppressDefaultLog, IDeleteAttachmentApiResponse apiResponseLocalVar, string attachmentId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="attachmentId"></param>
        private void OnErrorDeleteAttachmentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string attachmentId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteAttachment(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, attachmentId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="attachmentId"></param>
        partial void OnErrorDeleteAttachment(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string attachmentId);

        /// <summary>
        /// Delete an attachment Delete an attachment
        /// </summary>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAttachmentApiResponse"/>&gt;</returns>
        public async Task<IDeleteAttachmentApiResponse> DeleteAttachmentOrDefaultAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteAttachmentAsync(attachmentId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete an attachment Delete an attachment
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAttachmentApiResponse"/>&gt;</returns>
        public async Task<IDeleteAttachmentApiResponse> DeleteAttachmentAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteAttachment(attachmentId);

                FormatDeleteAttachment(ref attachmentId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/attachments/{attachmentId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/attachments/{attachmentId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BattachmentId%7D", Uri.EscapeDataString(attachmentId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DeleteAttachmentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteAttachmentApiResponse>();

                        DeleteAttachmentApiResponse apiResponseLocalVar = new DeleteAttachmentApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/attachments/{attachmentId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteAttachmentDefaultImplementation(apiResponseLocalVar, attachmentId);

                        Events.ExecuteOnDeleteAttachment(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteAttachmentDefaultImplementation(e, "/attachments/{attachmentId}", uriBuilderLocalVar.Path, attachmentId);
                Events.ExecuteOnErrorDeleteAttachment(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteAttachmentApiResponse"/>
        /// </summary>
        public partial class DeleteAttachmentApiResponse : mailslurp.Client.ApiResponse, IDeleteAttachmentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteAttachmentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteAttachmentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteAttachmentApiResponse(ILogger<DeleteAttachmentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDownloadAttachmentAsBase64Encoded(ref string attachmentId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="attachmentId"></param>
        /// <returns></returns>
        private void ValidateDownloadAttachmentAsBase64Encoded(string attachmentId)
        {
            if (attachmentId == null)
                throw new ArgumentNullException(nameof(attachmentId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="attachmentId"></param>
        private void AfterDownloadAttachmentAsBase64EncodedDefaultImplementation(IDownloadAttachmentAsBase64EncodedApiResponse apiResponseLocalVar, string attachmentId)
        {
            bool suppressDefaultLog = false;
            AfterDownloadAttachmentAsBase64Encoded(ref suppressDefaultLog, apiResponseLocalVar, attachmentId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="attachmentId"></param>
        partial void AfterDownloadAttachmentAsBase64Encoded(ref bool suppressDefaultLog, IDownloadAttachmentAsBase64EncodedApiResponse apiResponseLocalVar, string attachmentId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="attachmentId"></param>
        private void OnErrorDownloadAttachmentAsBase64EncodedDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string attachmentId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDownloadAttachmentAsBase64Encoded(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, attachmentId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="attachmentId"></param>
        partial void OnErrorDownloadAttachmentAsBase64Encoded(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string attachmentId);

        /// <summary>
        /// Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents. Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </summary>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentAsBase64EncodedApiResponse"/>&gt;</returns>
        public async Task<IDownloadAttachmentAsBase64EncodedApiResponse> DownloadAttachmentAsBase64EncodedOrDefaultAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DownloadAttachmentAsBase64EncodedAsync(attachmentId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents. Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the &#x60;downloadAttachment&#x60; method but allows some clients to get around issues with binary responses.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentAsBase64EncodedApiResponse"/>&gt;</returns>
        public async Task<IDownloadAttachmentAsBase64EncodedApiResponse> DownloadAttachmentAsBase64EncodedAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDownloadAttachmentAsBase64Encoded(attachmentId);

                FormatDownloadAttachmentAsBase64Encoded(ref attachmentId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/attachments/{attachmentId}/base64"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/attachments/{attachmentId}/base64");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BattachmentId%7D", Uri.EscapeDataString(attachmentId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DownloadAttachmentAsBase64EncodedApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DownloadAttachmentAsBase64EncodedApiResponse>();

                        DownloadAttachmentAsBase64EncodedApiResponse apiResponseLocalVar = new DownloadAttachmentAsBase64EncodedApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/attachments/{attachmentId}/base64", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDownloadAttachmentAsBase64EncodedDefaultImplementation(apiResponseLocalVar, attachmentId);

                        Events.ExecuteOnDownloadAttachmentAsBase64Encoded(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDownloadAttachmentAsBase64EncodedDefaultImplementation(e, "/attachments/{attachmentId}/base64", uriBuilderLocalVar.Path, attachmentId);
                Events.ExecuteOnErrorDownloadAttachmentAsBase64Encoded(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DownloadAttachmentAsBase64EncodedApiResponse"/>
        /// </summary>
        public partial class DownloadAttachmentAsBase64EncodedApiResponse : mailslurp.Client.ApiResponse, IDownloadAttachmentAsBase64EncodedApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DownloadAttachmentAsBase64EncodedApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DownloadAttachmentAsBase64EncodedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DownloadAttachmentAsBase64EncodedApiResponse(ILogger<DownloadAttachmentAsBase64EncodedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.DownloadAttachmentDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.DownloadAttachmentDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.DownloadAttachmentDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDownloadAttachmentAsBytes(ref string attachmentId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="attachmentId"></param>
        /// <returns></returns>
        private void ValidateDownloadAttachmentAsBytes(string attachmentId)
        {
            if (attachmentId == null)
                throw new ArgumentNullException(nameof(attachmentId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="attachmentId"></param>
        private void AfterDownloadAttachmentAsBytesDefaultImplementation(IDownloadAttachmentAsBytesApiResponse apiResponseLocalVar, string attachmentId)
        {
            bool suppressDefaultLog = false;
            AfterDownloadAttachmentAsBytes(ref suppressDefaultLog, apiResponseLocalVar, attachmentId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="attachmentId"></param>
        partial void AfterDownloadAttachmentAsBytes(ref bool suppressDefaultLog, IDownloadAttachmentAsBytesApiResponse apiResponseLocalVar, string attachmentId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="attachmentId"></param>
        private void OnErrorDownloadAttachmentAsBytesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string attachmentId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDownloadAttachmentAsBytes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, attachmentId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="attachmentId"></param>
        partial void OnErrorDownloadAttachmentAsBytes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string attachmentId);

        /// <summary>
        /// Download attachments. Get email attachment bytes. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints. Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </summary>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentAsBytesApiResponse"/>&gt;</returns>
        public async Task<IDownloadAttachmentAsBytesApiResponse> DownloadAttachmentAsBytesOrDefaultAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DownloadAttachmentAsBytesAsync(attachmentId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Download attachments. Get email attachment bytes. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints. Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDownloadAttachmentAsBytesApiResponse"/>&gt;</returns>
        public async Task<IDownloadAttachmentAsBytesApiResponse> DownloadAttachmentAsBytesAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDownloadAttachmentAsBytes(attachmentId);

                FormatDownloadAttachmentAsBytes(ref attachmentId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/attachments/{attachmentId}/bytes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/attachments/{attachmentId}/bytes");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BattachmentId%7D", Uri.EscapeDataString(attachmentId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/octet-stream"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DownloadAttachmentAsBytesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DownloadAttachmentAsBytesApiResponse>();

                        DownloadAttachmentAsBytesApiResponse apiResponseLocalVar = new DownloadAttachmentAsBytesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/attachments/{attachmentId}/bytes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDownloadAttachmentAsBytesDefaultImplementation(apiResponseLocalVar, attachmentId);

                        Events.ExecuteOnDownloadAttachmentAsBytes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDownloadAttachmentAsBytesDefaultImplementation(e, "/attachments/{attachmentId}/bytes", uriBuilderLocalVar.Path, attachmentId);
                Events.ExecuteOnErrorDownloadAttachmentAsBytes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DownloadAttachmentAsBytesApiResponse"/>
        /// </summary>
        public partial class DownloadAttachmentAsBytesApiResponse : mailslurp.Client.ApiResponse, IDownloadAttachmentAsBytesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DownloadAttachmentAsBytesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DownloadAttachmentAsBytesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DownloadAttachmentAsBytesApiResponse(ILogger<DownloadAttachmentAsBytesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => true;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public byte[] Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<byte[]>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault(out byte[] result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAttachment(ref string attachmentId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="attachmentId"></param>
        /// <returns></returns>
        private void ValidateGetAttachment(string attachmentId)
        {
            if (attachmentId == null)
                throw new ArgumentNullException(nameof(attachmentId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="attachmentId"></param>
        private void AfterGetAttachmentDefaultImplementation(IGetAttachmentApiResponse apiResponseLocalVar, string attachmentId)
        {
            bool suppressDefaultLog = false;
            AfterGetAttachment(ref suppressDefaultLog, apiResponseLocalVar, attachmentId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="attachmentId"></param>
        partial void AfterGetAttachment(ref bool suppressDefaultLog, IGetAttachmentApiResponse apiResponseLocalVar, string attachmentId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="attachmentId"></param>
        private void OnErrorGetAttachmentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string attachmentId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAttachment(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, attachmentId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="attachmentId"></param>
        partial void OnErrorGetAttachment(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string attachmentId);

        /// <summary>
        /// Get an attachment entity 
        /// </summary>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentApiResponse"/>&gt;</returns>
        public async Task<IGetAttachmentApiResponse> GetAttachmentOrDefaultAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAttachmentAsync(attachmentId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an attachment entity 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentApiResponse"/>&gt;</returns>
        public async Task<IGetAttachmentApiResponse> GetAttachmentAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAttachment(attachmentId);

                FormatGetAttachment(ref attachmentId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/attachments/{attachmentId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/attachments/{attachmentId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BattachmentId%7D", Uri.EscapeDataString(attachmentId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetAttachmentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAttachmentApiResponse>();

                        GetAttachmentApiResponse apiResponseLocalVar = new GetAttachmentApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/attachments/{attachmentId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAttachmentDefaultImplementation(apiResponseLocalVar, attachmentId);

                        Events.ExecuteOnGetAttachment(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAttachmentDefaultImplementation(e, "/attachments/{attachmentId}", uriBuilderLocalVar.Path, attachmentId);
                Events.ExecuteOnErrorGetAttachment(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAttachmentApiResponse"/>
        /// </summary>
        public partial class GetAttachmentApiResponse : mailslurp.Client.ApiResponse, IGetAttachmentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAttachmentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAttachmentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAttachmentApiResponse(ILogger<GetAttachmentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.AttachmentEntityDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.AttachmentEntityDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.AttachmentEntityDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAttachmentInfo(ref string attachmentId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="attachmentId"></param>
        /// <returns></returns>
        private void ValidateGetAttachmentInfo(string attachmentId)
        {
            if (attachmentId == null)
                throw new ArgumentNullException(nameof(attachmentId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="attachmentId"></param>
        private void AfterGetAttachmentInfoDefaultImplementation(IGetAttachmentInfoApiResponse apiResponseLocalVar, string attachmentId)
        {
            bool suppressDefaultLog = false;
            AfterGetAttachmentInfo(ref suppressDefaultLog, apiResponseLocalVar, attachmentId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="attachmentId"></param>
        partial void AfterGetAttachmentInfo(ref bool suppressDefaultLog, IGetAttachmentInfoApiResponse apiResponseLocalVar, string attachmentId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="attachmentId"></param>
        private void OnErrorGetAttachmentInfoDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string attachmentId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAttachmentInfo(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, attachmentId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="attachmentId"></param>
        partial void OnErrorGetAttachmentInfo(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string attachmentId);

        /// <summary>
        /// Get email attachment metadata information Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties &#x60;name&#x60; and &#x60;content-type&#x60; and &#x60;content-length&#x60; in bytes for a given attachment.
        /// </summary>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentInfoApiResponse"/>&gt;</returns>
        public async Task<IGetAttachmentInfoApiResponse> GetAttachmentInfoOrDefaultAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAttachmentInfoAsync(attachmentId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email attachment metadata information Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties &#x60;name&#x60; and &#x60;content-type&#x60; and &#x60;content-length&#x60; in bytes for a given attachment.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="attachmentId">ID of attachment</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentInfoApiResponse"/>&gt;</returns>
        public async Task<IGetAttachmentInfoApiResponse> GetAttachmentInfoAsync(string attachmentId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAttachmentInfo(attachmentId);

                FormatGetAttachmentInfo(ref attachmentId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/attachments/{attachmentId}/metadata"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/attachments/{attachmentId}/metadata");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BattachmentId%7D", Uri.EscapeDataString(attachmentId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetAttachmentInfoApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAttachmentInfoApiResponse>();

                        GetAttachmentInfoApiResponse apiResponseLocalVar = new GetAttachmentInfoApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/attachments/{attachmentId}/metadata", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAttachmentInfoDefaultImplementation(apiResponseLocalVar, attachmentId);

                        Events.ExecuteOnGetAttachmentInfo(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAttachmentInfoDefaultImplementation(e, "/attachments/{attachmentId}/metadata", uriBuilderLocalVar.Path, attachmentId);
                Events.ExecuteOnErrorGetAttachmentInfo(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAttachmentInfoApiResponse"/>
        /// </summary>
        public partial class GetAttachmentInfoApiResponse : mailslurp.Client.ApiResponse, IGetAttachmentInfoApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAttachmentInfoApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAttachmentInfoApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAttachmentInfoApiResponse(ILogger<GetAttachmentInfoApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.AttachmentMetaData Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.AttachmentMetaData>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.AttachmentMetaData result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAttachments(ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<string> fileNameFilter, ref Option<DateTime> since, ref Option<DateTime> before, ref Option<Guid> inboxId, ref Option<Guid> emailId, ref Option<Guid> sentEmailId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="fileNameFilter"></param>
        /// <returns></returns>
        private void ValidateGetAttachments(Option<string> sort, Option<string> fileNameFilter)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (fileNameFilter.IsSet && fileNameFilter.Value == null)
                throw new ArgumentNullException(nameof(fileNameFilter));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="fileNameFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxId"></param>
        /// <param name="emailId"></param>
        /// <param name="sentEmailId"></param>
        private void AfterGetAttachmentsDefaultImplementation(IGetAttachmentsApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> fileNameFilter, Option<DateTime> since, Option<DateTime> before, Option<Guid> inboxId, Option<Guid> emailId, Option<Guid> sentEmailId)
        {
            bool suppressDefaultLog = false;
            AfterGetAttachments(ref suppressDefaultLog, apiResponseLocalVar, page, size, sort, fileNameFilter, since, before, inboxId, emailId, sentEmailId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="fileNameFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxId"></param>
        /// <param name="emailId"></param>
        /// <param name="sentEmailId"></param>
        partial void AfterGetAttachments(ref bool suppressDefaultLog, IGetAttachmentsApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> fileNameFilter, Option<DateTime> since, Option<DateTime> before, Option<Guid> inboxId, Option<Guid> emailId, Option<Guid> sentEmailId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="fileNameFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxId"></param>
        /// <param name="emailId"></param>
        /// <param name="sentEmailId"></param>
        private void OnErrorGetAttachmentsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> fileNameFilter, Option<DateTime> since, Option<DateTime> before, Option<Guid> inboxId, Option<Guid> emailId, Option<Guid> sentEmailId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAttachments(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, page, size, sort, fileNameFilter, since, before, inboxId, emailId, sentEmailId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="fileNameFilter"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxId"></param>
        /// <param name="emailId"></param>
        /// <param name="sentEmailId"></param>
        partial void OnErrorGetAttachments(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<string> fileNameFilter, Option<DateTime> since, Option<DateTime> before, Option<Guid> inboxId, Option<Guid> emailId, Option<Guid> sentEmailId);

        /// <summary>
        /// Get email attachments Get all attachments in paginated response. Each entity contains meta data for the attachment such as &#x60;name&#x60; and &#x60;content-type&#x60;. Use the &#x60;attachmentId&#x60; and the download endpoints to get the file contents.
        /// </summary>
        /// <param name="page">Optional page index for list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size for list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="fileNameFilter">Optional file name and content type search filter (optional)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="inboxId">Optional inboxId to filter attachments by (optional)</param>
        /// <param name="emailId">Optional emailId to filter attachments by (optional)</param>
        /// <param name="sentEmailId">Optional sentEmailId to filter attachments by (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentsApiResponse"/>&gt;</returns>
        public async Task<IGetAttachmentsApiResponse> GetAttachmentsOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> fileNameFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<Guid> inboxId = default, Option<Guid> emailId = default, Option<Guid> sentEmailId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAttachmentsAsync(page, size, sort, fileNameFilter, since, before, inboxId, emailId, sentEmailId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get email attachments Get all attachments in paginated response. Each entity contains meta data for the attachment such as &#x60;name&#x60; and &#x60;content-type&#x60;. Use the &#x60;attachmentId&#x60; and the download endpoints to get the file contents.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index for list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size for list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="fileNameFilter">Optional file name and content type search filter (optional)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="inboxId">Optional inboxId to filter attachments by (optional)</param>
        /// <param name="emailId">Optional emailId to filter attachments by (optional)</param>
        /// <param name="sentEmailId">Optional sentEmailId to filter attachments by (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAttachmentsApiResponse"/>&gt;</returns>
        public async Task<IGetAttachmentsApiResponse> GetAttachmentsAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<string> fileNameFilter = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<Guid> inboxId = default, Option<Guid> emailId = default, Option<Guid> sentEmailId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAttachments(sort, fileNameFilter);

                FormatGetAttachments(ref page, ref size, ref sort, ref fileNameFilter, ref since, ref before, ref inboxId, ref emailId, ref sentEmailId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/attachments"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/attachments");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (fileNameFilter.IsSet)
                        parseQueryStringLocalVar["fileNameFilter"] = ClientUtils.ParameterToString(fileNameFilter.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    if (emailId.IsSet)
                        parseQueryStringLocalVar["emailId"] = ClientUtils.ParameterToString(emailId.Value);

                    if (sentEmailId.IsSet)
                        parseQueryStringLocalVar["sentEmailId"] = ClientUtils.ParameterToString(sentEmailId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetAttachmentsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAttachmentsApiResponse>();

                        GetAttachmentsApiResponse apiResponseLocalVar = new GetAttachmentsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/attachments", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAttachmentsDefaultImplementation(apiResponseLocalVar, page, size, sort, fileNameFilter, since, before, inboxId, emailId, sentEmailId);

                        Events.ExecuteOnGetAttachments(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAttachmentsDefaultImplementation(e, "/attachments", uriBuilderLocalVar.Path, page, size, sort, fileNameFilter, since, before, inboxId, emailId, sentEmailId);
                Events.ExecuteOnErrorGetAttachments(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAttachmentsApiResponse"/>
        /// </summary>
        public partial class GetAttachmentsApiResponse : mailslurp.Client.ApiResponse, IGetAttachmentsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAttachmentsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAttachmentsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAttachmentsApiResponse(ILogger<GetAttachmentsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageAttachmentEntity Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageAttachmentEntity>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageAttachmentEntity result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUploadAttachment(UploadAttachmentOptions uploadAttachmentOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="uploadAttachmentOptions"></param>
        /// <returns></returns>
        private void ValidateUploadAttachment(UploadAttachmentOptions uploadAttachmentOptions)
        {
            if (uploadAttachmentOptions == null)
                throw new ArgumentNullException(nameof(uploadAttachmentOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="uploadAttachmentOptions"></param>
        private void AfterUploadAttachmentDefaultImplementation(IUploadAttachmentApiResponse apiResponseLocalVar, UploadAttachmentOptions uploadAttachmentOptions)
        {
            bool suppressDefaultLog = false;
            AfterUploadAttachment(ref suppressDefaultLog, apiResponseLocalVar, uploadAttachmentOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="uploadAttachmentOptions"></param>
        partial void AfterUploadAttachment(ref bool suppressDefaultLog, IUploadAttachmentApiResponse apiResponseLocalVar, UploadAttachmentOptions uploadAttachmentOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="uploadAttachmentOptions"></param>
        private void OnErrorUploadAttachmentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, UploadAttachmentOptions uploadAttachmentOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUploadAttachment(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, uploadAttachmentOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="uploadAttachmentOptions"></param>
        partial void OnErrorUploadAttachment(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, UploadAttachmentOptions uploadAttachmentOptions);

        /// <summary>
        /// Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment. 
        /// </summary>
        /// <param name="uploadAttachmentOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadAttachmentApiResponse"/>&gt;</returns>
        public async Task<IUploadAttachmentApiResponse> UploadAttachmentOrDefaultAsync(UploadAttachmentOptions uploadAttachmentOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UploadAttachmentAsync(uploadAttachmentOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadAttachmentOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadAttachmentApiResponse"/>&gt;</returns>
        public async Task<IUploadAttachmentApiResponse> UploadAttachmentAsync(UploadAttachmentOptions uploadAttachmentOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUploadAttachment(uploadAttachmentOptions);

                FormatUploadAttachment(uploadAttachmentOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/attachments"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/attachments");

                    httpRequestMessageLocalVar.Content = (uploadAttachmentOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(uploadAttachmentOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UploadAttachmentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UploadAttachmentApiResponse>();

                        UploadAttachmentApiResponse apiResponseLocalVar = new UploadAttachmentApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/attachments", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUploadAttachmentDefaultImplementation(apiResponseLocalVar, uploadAttachmentOptions);

                        Events.ExecuteOnUploadAttachment(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUploadAttachmentDefaultImplementation(e, "/attachments", uriBuilderLocalVar.Path, uploadAttachmentOptions);
                Events.ExecuteOnErrorUploadAttachment(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UploadAttachmentApiResponse"/>
        /// </summary>
        public partial class UploadAttachmentApiResponse : mailslurp.Client.ApiResponse, IUploadAttachmentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UploadAttachmentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UploadAttachmentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UploadAttachmentApiResponse(ILogger<UploadAttachmentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public List<string> Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<List<string>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out List<string> result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUploadAttachmentBytes(ref Option<string> contentType, ref Option<string> contentType2, ref Option<string> contentId, ref Option<string> filename, ref Option<long> fileSize, ref Option<string> filename2);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="contentType"></param>
        /// <param name="contentType2"></param>
        /// <param name="contentId"></param>
        /// <param name="filename"></param>
        /// <param name="filename2"></param>
        /// <returns></returns>
        private void ValidateUploadAttachmentBytes(Option<string> contentType, Option<string> contentType2, Option<string> contentId, Option<string> filename, Option<string> filename2)
        {
            if (contentType.IsSet && contentType.Value == null)
                throw new ArgumentNullException(nameof(contentType));

            if (contentType2.IsSet && contentType2.Value == null)
                throw new ArgumentNullException(nameof(contentType2));

            if (contentId.IsSet && contentId.Value == null)
                throw new ArgumentNullException(nameof(contentId));

            if (filename.IsSet && filename.Value == null)
                throw new ArgumentNullException(nameof(filename));

            if (filename2.IsSet && filename2.Value == null)
                throw new ArgumentNullException(nameof(filename2));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="contentType"></param>
        /// <param name="contentType2"></param>
        /// <param name="contentId"></param>
        /// <param name="filename"></param>
        /// <param name="fileSize"></param>
        /// <param name="filename2"></param>
        private void AfterUploadAttachmentBytesDefaultImplementation(IUploadAttachmentBytesApiResponse apiResponseLocalVar, Option<string> contentType, Option<string> contentType2, Option<string> contentId, Option<string> filename, Option<long> fileSize, Option<string> filename2)
        {
            bool suppressDefaultLog = false;
            AfterUploadAttachmentBytes(ref suppressDefaultLog, apiResponseLocalVar, contentType, contentType2, contentId, filename, fileSize, filename2);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="contentType"></param>
        /// <param name="contentType2"></param>
        /// <param name="contentId"></param>
        /// <param name="filename"></param>
        /// <param name="fileSize"></param>
        /// <param name="filename2"></param>
        partial void AfterUploadAttachmentBytes(ref bool suppressDefaultLog, IUploadAttachmentBytesApiResponse apiResponseLocalVar, Option<string> contentType, Option<string> contentType2, Option<string> contentId, Option<string> filename, Option<long> fileSize, Option<string> filename2);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="contentType"></param>
        /// <param name="contentType2"></param>
        /// <param name="contentId"></param>
        /// <param name="filename"></param>
        /// <param name="fileSize"></param>
        /// <param name="filename2"></param>
        private void OnErrorUploadAttachmentBytesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> contentType, Option<string> contentType2, Option<string> contentId, Option<string> filename, Option<long> fileSize, Option<string> filename2)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUploadAttachmentBytes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, contentType, contentType2, contentId, filename, fileSize, filename2);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="contentType"></param>
        /// <param name="contentType2"></param>
        /// <param name="contentId"></param>
        /// <param name="filename"></param>
        /// <param name="fileSize"></param>
        /// <param name="filename2"></param>
        partial void OnErrorUploadAttachmentBytes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> contentType, Option<string> contentType2, Option<string> contentId, Option<string> filename, Option<long> fileSize, Option<string> filename2);

        /// <summary>
        /// Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment. 
        /// </summary>
        /// <param name="contentType"> (optional)</param>
        /// <param name="contentType2">Optional contentType for file. For instance &#x60;application/pdf&#x60; (optional)</param>
        /// <param name="contentId">Optional content ID (CID) to save upload with (optional)</param>
        /// <param name="filename">Optional filename to save upload with (optional)</param>
        /// <param name="fileSize">Optional byte length to save upload with (optional)</param>
        /// <param name="filename2"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadAttachmentBytesApiResponse"/>&gt;</returns>
        public async Task<IUploadAttachmentBytesApiResponse> UploadAttachmentBytesOrDefaultAsync(Option<string> contentType = default, Option<string> contentType2 = default, Option<string> contentId = default, Option<string> filename = default, Option<long> fileSize = default, Option<string> filename2 = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UploadAttachmentBytesAsync(contentType, contentType2, contentId, filename, fileSize, filename2, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType"> (optional)</param>
        /// <param name="contentType2">Optional contentType for file. For instance &#x60;application/pdf&#x60; (optional)</param>
        /// <param name="contentId">Optional content ID (CID) to save upload with (optional)</param>
        /// <param name="filename">Optional filename to save upload with (optional)</param>
        /// <param name="fileSize">Optional byte length to save upload with (optional)</param>
        /// <param name="filename2"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadAttachmentBytesApiResponse"/>&gt;</returns>
        public async Task<IUploadAttachmentBytesApiResponse> UploadAttachmentBytesAsync(Option<string> contentType = default, Option<string> contentType2 = default, Option<string> contentId = default, Option<string> filename = default, Option<long> fileSize = default, Option<string> filename2 = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUploadAttachmentBytes(contentType, contentType2, contentId, filename, filename2);

                FormatUploadAttachmentBytes(ref contentType, ref contentType2, ref contentId, ref filename, ref fileSize, ref filename2);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/attachments/bytes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/attachments/bytes");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (contentType2.IsSet)
                        parseQueryStringLocalVar["contentType"] = ClientUtils.ParameterToString(contentType2.Value);

                    if (contentId.IsSet)
                        parseQueryStringLocalVar["contentId"] = ClientUtils.ParameterToString(contentId.Value);

                    if (filename.IsSet)
                        parseQueryStringLocalVar["filename"] = ClientUtils.ParameterToString(filename.Value);

                    if (fileSize.IsSet)
                        parseQueryStringLocalVar["fileSize"] = ClientUtils.ParameterToString(fileSize.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (contentType.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("contentType", ClientUtils.ParameterToString(contentType.Value));

                    if (filename2.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("filename", ClientUtils.ParameterToString(filename2.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UploadAttachmentBytesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UploadAttachmentBytesApiResponse>();

                        UploadAttachmentBytesApiResponse apiResponseLocalVar = new UploadAttachmentBytesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/attachments/bytes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUploadAttachmentBytesDefaultImplementation(apiResponseLocalVar, contentType, contentType2, contentId, filename, fileSize, filename2);

                        Events.ExecuteOnUploadAttachmentBytes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUploadAttachmentBytesDefaultImplementation(e, "/attachments/bytes", uriBuilderLocalVar.Path, contentType, contentType2, contentId, filename, fileSize, filename2);
                Events.ExecuteOnErrorUploadAttachmentBytes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UploadAttachmentBytesApiResponse"/>
        /// </summary>
        public partial class UploadAttachmentBytesApiResponse : mailslurp.Client.ApiResponse, IUploadAttachmentBytesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UploadAttachmentBytesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UploadAttachmentBytesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UploadAttachmentBytesApiResponse(ILogger<UploadAttachmentBytesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public List<string> Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<List<string>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out List<string> result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUploadMultipartForm(ref Option<string> contentId, ref Option<string> contentType, ref Option<string> filename, ref Option<string> contentTypeHeader, ref Option<string> xFilename, ref Option<string> xFilenameRaw, ref Option<long> xFilesize, Option<UploadMultipartFormRequest> uploadMultipartFormRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="contentId"></param>
        /// <param name="contentType"></param>
        /// <param name="filename"></param>
        /// <param name="contentTypeHeader"></param>
        /// <param name="xFilename"></param>
        /// <param name="xFilenameRaw"></param>
        /// <param name="uploadMultipartFormRequest"></param>
        /// <returns></returns>
        private void ValidateUploadMultipartForm(Option<string> contentId, Option<string> contentType, Option<string> filename, Option<string> contentTypeHeader, Option<string> xFilename, Option<string> xFilenameRaw, Option<UploadMultipartFormRequest> uploadMultipartFormRequest)
        {
            if (contentId.IsSet && contentId.Value == null)
                throw new ArgumentNullException(nameof(contentId));

            if (contentType.IsSet && contentType.Value == null)
                throw new ArgumentNullException(nameof(contentType));

            if (filename.IsSet && filename.Value == null)
                throw new ArgumentNullException(nameof(filename));

            if (contentTypeHeader.IsSet && contentTypeHeader.Value == null)
                throw new ArgumentNullException(nameof(contentTypeHeader));

            if (xFilename.IsSet && xFilename.Value == null)
                throw new ArgumentNullException(nameof(xFilename));

            if (xFilenameRaw.IsSet && xFilenameRaw.Value == null)
                throw new ArgumentNullException(nameof(xFilenameRaw));

            if (uploadMultipartFormRequest.IsSet && uploadMultipartFormRequest.Value == null)
                throw new ArgumentNullException(nameof(uploadMultipartFormRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="contentId"></param>
        /// <param name="contentType"></param>
        /// <param name="filename"></param>
        /// <param name="contentTypeHeader"></param>
        /// <param name="xFilename"></param>
        /// <param name="xFilenameRaw"></param>
        /// <param name="xFilesize"></param>
        /// <param name="uploadMultipartFormRequest"></param>
        private void AfterUploadMultipartFormDefaultImplementation(IUploadMultipartFormApiResponse apiResponseLocalVar, Option<string> contentId, Option<string> contentType, Option<string> filename, Option<string> contentTypeHeader, Option<string> xFilename, Option<string> xFilenameRaw, Option<long> xFilesize, Option<UploadMultipartFormRequest> uploadMultipartFormRequest)
        {
            bool suppressDefaultLog = false;
            AfterUploadMultipartForm(ref suppressDefaultLog, apiResponseLocalVar, contentId, contentType, filename, contentTypeHeader, xFilename, xFilenameRaw, xFilesize, uploadMultipartFormRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="contentId"></param>
        /// <param name="contentType"></param>
        /// <param name="filename"></param>
        /// <param name="contentTypeHeader"></param>
        /// <param name="xFilename"></param>
        /// <param name="xFilenameRaw"></param>
        /// <param name="xFilesize"></param>
        /// <param name="uploadMultipartFormRequest"></param>
        partial void AfterUploadMultipartForm(ref bool suppressDefaultLog, IUploadMultipartFormApiResponse apiResponseLocalVar, Option<string> contentId, Option<string> contentType, Option<string> filename, Option<string> contentTypeHeader, Option<string> xFilename, Option<string> xFilenameRaw, Option<long> xFilesize, Option<UploadMultipartFormRequest> uploadMultipartFormRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="contentId"></param>
        /// <param name="contentType"></param>
        /// <param name="filename"></param>
        /// <param name="contentTypeHeader"></param>
        /// <param name="xFilename"></param>
        /// <param name="xFilenameRaw"></param>
        /// <param name="xFilesize"></param>
        /// <param name="uploadMultipartFormRequest"></param>
        private void OnErrorUploadMultipartFormDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> contentId, Option<string> contentType, Option<string> filename, Option<string> contentTypeHeader, Option<string> xFilename, Option<string> xFilenameRaw, Option<long> xFilesize, Option<UploadMultipartFormRequest> uploadMultipartFormRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUploadMultipartForm(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, contentId, contentType, filename, contentTypeHeader, xFilename, xFilenameRaw, xFilesize, uploadMultipartFormRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="contentId"></param>
        /// <param name="contentType"></param>
        /// <param name="filename"></param>
        /// <param name="contentTypeHeader"></param>
        /// <param name="xFilename"></param>
        /// <param name="xFilenameRaw"></param>
        /// <param name="xFilesize"></param>
        /// <param name="uploadMultipartFormRequest"></param>
        partial void OnErrorUploadMultipartForm(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> contentId, Option<string> contentType, Option<string> filename, Option<string> contentTypeHeader, Option<string> xFilename, Option<string> xFilenameRaw, Option<long> xFilesize, Option<UploadMultipartFormRequest> uploadMultipartFormRequest);

        /// <summary>
        /// Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment. 
        /// </summary>
        /// <param name="contentId">Optional content ID of attachment (optional)</param>
        /// <param name="contentType">Optional content type of attachment (optional)</param>
        /// <param name="filename">Optional name of file (optional)</param>
        /// <param name="contentTypeHeader">Optional content type header of attachment (optional)</param>
        /// <param name="xFilename">Optional filename header of attachment (optional)</param>
        /// <param name="xFilenameRaw">Optional raw filename header of attachment that will be converted to punycode (optional)</param>
        /// <param name="xFilesize">Optional content size of attachment (optional)</param>
        /// <param name="uploadMultipartFormRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadMultipartFormApiResponse"/>&gt;</returns>
        public async Task<IUploadMultipartFormApiResponse> UploadMultipartFormOrDefaultAsync(Option<string> contentId = default, Option<string> contentType = default, Option<string> filename = default, Option<string> contentTypeHeader = default, Option<string> xFilename = default, Option<string> xFilenameRaw = default, Option<long> xFilesize = default, Option<UploadMultipartFormRequest> uploadMultipartFormRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UploadMultipartFormAsync(contentId, contentType, filename, contentTypeHeader, xFilename, xFilenameRaw, xFilesize, uploadMultipartFormRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentId">Optional content ID of attachment (optional)</param>
        /// <param name="contentType">Optional content type of attachment (optional)</param>
        /// <param name="filename">Optional name of file (optional)</param>
        /// <param name="contentTypeHeader">Optional content type header of attachment (optional)</param>
        /// <param name="xFilename">Optional filename header of attachment (optional)</param>
        /// <param name="xFilenameRaw">Optional raw filename header of attachment that will be converted to punycode (optional)</param>
        /// <param name="xFilesize">Optional content size of attachment (optional)</param>
        /// <param name="uploadMultipartFormRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadMultipartFormApiResponse"/>&gt;</returns>
        public async Task<IUploadMultipartFormApiResponse> UploadMultipartFormAsync(Option<string> contentId = default, Option<string> contentType = default, Option<string> filename = default, Option<string> contentTypeHeader = default, Option<string> xFilename = default, Option<string> xFilenameRaw = default, Option<long> xFilesize = default, Option<UploadMultipartFormRequest> uploadMultipartFormRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUploadMultipartForm(contentId, contentType, filename, contentTypeHeader, xFilename, xFilenameRaw, uploadMultipartFormRequest);

                FormatUploadMultipartForm(ref contentId, ref contentType, ref filename, ref contentTypeHeader, ref xFilename, ref xFilenameRaw, ref xFilesize, uploadMultipartFormRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/attachments/multipart"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/attachments/multipart");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (contentId.IsSet)
                        parseQueryStringLocalVar["contentId"] = ClientUtils.ParameterToString(contentId.Value);

                    if (contentType.IsSet)
                        parseQueryStringLocalVar["contentType"] = ClientUtils.ParameterToString(contentType.Value);

                    if (filename.IsSet)
                        parseQueryStringLocalVar["filename"] = ClientUtils.ParameterToString(filename.Value);

                    if (contentTypeHeader.IsSet)
                        parseQueryStringLocalVar["contentTypeHeader"] = ClientUtils.ParameterToString(contentTypeHeader.Value);

                    if (xFilename.IsSet)
                        parseQueryStringLocalVar["x-filename"] = ClientUtils.ParameterToString(xFilename.Value);

                    if (xFilenameRaw.IsSet)
                        parseQueryStringLocalVar["x-filename-raw"] = ClientUtils.ParameterToString(xFilenameRaw.Value);

                    if (xFilesize.IsSet)
                        parseQueryStringLocalVar["x-filesize"] = ClientUtils.ParameterToString(xFilesize.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (uploadMultipartFormRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (uploadMultipartFormRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(uploadMultipartFormRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UploadMultipartFormApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UploadMultipartFormApiResponse>();

                        UploadMultipartFormApiResponse apiResponseLocalVar = new UploadMultipartFormApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/attachments/multipart", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUploadMultipartFormDefaultImplementation(apiResponseLocalVar, contentId, contentType, filename, contentTypeHeader, xFilename, xFilenameRaw, xFilesize, uploadMultipartFormRequest);

                        Events.ExecuteOnUploadMultipartForm(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUploadMultipartFormDefaultImplementation(e, "/attachments/multipart", uriBuilderLocalVar.Path, contentId, contentType, filename, contentTypeHeader, xFilename, xFilenameRaw, xFilesize, uploadMultipartFormRequest);
                Events.ExecuteOnErrorUploadMultipartForm(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UploadMultipartFormApiResponse"/>
        /// </summary>
        public partial class UploadMultipartFormApiResponse : mailslurp.Client.ApiResponse, IUploadMultipartFormApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UploadMultipartFormApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UploadMultipartFormApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UploadMultipartFormApiResponse(ILogger<UploadMultipartFormApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public List<string> Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<List<string>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out List<string> result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
