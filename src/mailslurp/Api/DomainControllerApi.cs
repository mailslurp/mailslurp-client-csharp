// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IDomainControllerApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        DomainControllerApiEvents Events { get; }

        /// <summary>
        /// Add catch all wild card inbox to domain
        /// </summary>
        /// <remarks>
        /// Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddDomainWildcardCatchAllApiResponse"/>&gt;</returns>
        Task<IAddDomainWildcardCatchAllApiResponse> AddDomainWildcardCatchAllAsync(Guid id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Add catch all wild card inbox to domain
        /// </summary>
        /// <remarks>
        /// Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddDomainWildcardCatchAllApiResponse"/>&gt;</returns>
        Task<IAddDomainWildcardCatchAllApiResponse> AddDomainWildcardCatchAllOrDefaultAsync(Guid id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Domain
        /// </summary>
        /// <remarks>
        /// Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider&#39;s DNS setup to verify the domain.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createDomainOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateDomainApiResponse"/>&gt;</returns>
        Task<ICreateDomainApiResponse> CreateDomainAsync(CreateDomainOptions createDomainOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Domain
        /// </summary>
        /// <remarks>
        /// Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider&#39;s DNS setup to verify the domain.
        /// </remarks>
        /// <param name="createDomainOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateDomainApiResponse"/>&gt;</returns>
        Task<ICreateDomainApiResponse> CreateDomainOrDefaultAsync(CreateDomainOptions createDomainOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a domain
        /// </summary>
        /// <remarks>
        /// Delete a domain. This will disable any existing inboxes that use this domain.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteDomainApiResponse"/>&gt;</returns>
        Task<IDeleteDomainApiResponse> DeleteDomainAsync(Guid id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a domain
        /// </summary>
        /// <remarks>
        /// Delete a domain. This will disable any existing inboxes that use this domain.
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteDomainApiResponse"/>&gt;</returns>
        Task<IDeleteDomainApiResponse> DeleteDomainOrDefaultAsync(Guid id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all usable domains
        /// </summary>
        /// <remarks>
        /// List all domains available for use with email address creation
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAvailableDomainsApiResponse"/>&gt;</returns>
        Task<IGetAvailableDomainsApiResponse> GetAvailableDomainsAsync(Option<string> inboxType = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all usable domains
        /// </summary>
        /// <remarks>
        /// List all domains available for use with email address creation
        /// </remarks>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAvailableDomainsApiResponse"/>&gt;</returns>
        Task<IGetAvailableDomainsApiResponse> GetAvailableDomainsOrDefaultAsync(Option<string> inboxType = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a domain
        /// </summary>
        /// <remarks>
        /// Returns domain verification status and tokens for a given domain
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="checkForErrors"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainApiResponse"/>&gt;</returns>
        Task<IGetDomainApiResponse> GetDomainAsync(Guid id, Option<bool> checkForErrors = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a domain
        /// </summary>
        /// <remarks>
        /// Returns domain verification status and tokens for a given domain
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="checkForErrors"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainApiResponse"/>&gt;</returns>
        Task<IGetDomainApiResponse> GetDomainOrDefaultAsync(Guid id, Option<bool> checkForErrors = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get domain issues
        /// </summary>
        /// <remarks>
        /// List domain issues for domains you have created
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainIssuesApiResponse"/>&gt;</returns>
        Task<IGetDomainIssuesApiResponse> GetDomainIssuesAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get domain issues
        /// </summary>
        /// <remarks>
        /// List domain issues for domains you have created
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainIssuesApiResponse"/>&gt;</returns>
        Task<IGetDomainIssuesApiResponse> GetDomainIssuesOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get catch all wild card inbox for domain
        /// </summary>
        /// <remarks>
        /// Get the catch all inbox for a domain for missed emails
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainWildcardCatchAllInboxApiResponse"/>&gt;</returns>
        Task<IGetDomainWildcardCatchAllInboxApiResponse> GetDomainWildcardCatchAllInboxAsync(Guid id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get catch all wild card inbox for domain
        /// </summary>
        /// <remarks>
        /// Get the catch all inbox for a domain for missed emails
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainWildcardCatchAllInboxApiResponse"/>&gt;</returns>
        Task<IGetDomainWildcardCatchAllInboxApiResponse> GetDomainWildcardCatchAllInboxOrDefaultAsync(Guid id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get domains
        /// </summary>
        /// <remarks>
        /// List all custom domains you have created
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainsApiResponse"/>&gt;</returns>
        Task<IGetDomainsApiResponse> GetDomainsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get domains
        /// </summary>
        /// <remarks>
        /// List all custom domains you have created
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainsApiResponse"/>&gt;</returns>
        Task<IGetDomainsApiResponse> GetDomainsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get MailSlurp domains
        /// </summary>
        /// <remarks>
        /// List all MailSlurp domains used with non-custom email addresses
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMailSlurpDomainsApiResponse"/>&gt;</returns>
        Task<IGetMailSlurpDomainsApiResponse> GetMailSlurpDomainsAsync(Option<string> inboxType = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get MailSlurp domains
        /// </summary>
        /// <remarks>
        /// List all MailSlurp domains used with non-custom email addresses
        /// </remarks>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMailSlurpDomainsApiResponse"/>&gt;</returns>
        Task<IGetMailSlurpDomainsApiResponse> GetMailSlurpDomainsOrDefaultAsync(Option<string> inboxType = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a domain
        /// </summary>
        /// <remarks>
        /// Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="updateDomainOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateDomainApiResponse"/>&gt;</returns>
        Task<IUpdateDomainApiResponse> UpdateDomainAsync(Guid id, UpdateDomainOptions updateDomainOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a domain
        /// </summary>
        /// <remarks>
        /// Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="updateDomainOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateDomainApiResponse"/>&gt;</returns>
        Task<IUpdateDomainApiResponse> UpdateDomainOrDefaultAsync(Guid id, UpdateDomainOptions updateDomainOptions, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAddDomainWildcardCatchAllApiResponse"/>
    /// </summary>
    public interface IAddDomainWildcardCatchAllApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.DomainDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateDomainApiResponse"/>
    /// </summary>
    public interface ICreateDomainApiResponse : mailslurp.Client.IApiResponse, ICreated<mailslurp.Model.DomainDto>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteDomainApiResponse"/>
    /// </summary>
    public interface IDeleteDomainApiResponse : mailslurp.Client.IApiResponse, INoContent<List<string>>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IGetAvailableDomainsApiResponse"/>
    /// </summary>
    public interface IGetAvailableDomainsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.DomainGroupsDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetDomainApiResponse"/>
    /// </summary>
    public interface IGetDomainApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.DomainDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetDomainIssuesApiResponse"/>
    /// </summary>
    public interface IGetDomainIssuesApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.DomainIssuesDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetDomainWildcardCatchAllInboxApiResponse"/>
    /// </summary>
    public interface IGetDomainWildcardCatchAllInboxApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.InboxDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetDomainsApiResponse"/>
    /// </summary>
    public interface IGetDomainsApiResponse : mailslurp.Client.IApiResponse, IOk<List<DomainPreview>>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetMailSlurpDomainsApiResponse"/>
    /// </summary>
    public interface IGetMailSlurpDomainsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.DomainGroupsDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateDomainApiResponse"/>
    /// </summary>
    public interface IUpdateDomainApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.DomainDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class DomainControllerApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnAddDomainWildcardCatchAll;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorAddDomainWildcardCatchAll;

        internal void ExecuteOnAddDomainWildcardCatchAll(DomainControllerApi.AddDomainWildcardCatchAllApiResponse apiResponse)
        {
            OnAddDomainWildcardCatchAll?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddDomainWildcardCatchAll(Exception exception)
        {
            OnErrorAddDomainWildcardCatchAll?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnCreateDomain;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorCreateDomain;

        internal void ExecuteOnCreateDomain(DomainControllerApi.CreateDomainApiResponse apiResponse)
        {
            OnCreateDomain?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateDomain(Exception exception)
        {
            OnErrorCreateDomain?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnDeleteDomain;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorDeleteDomain;

        internal void ExecuteOnDeleteDomain(DomainControllerApi.DeleteDomainApiResponse apiResponse)
        {
            OnDeleteDomain?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteDomain(Exception exception)
        {
            OnErrorDeleteDomain?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetAvailableDomains;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetAvailableDomains;

        internal void ExecuteOnGetAvailableDomains(DomainControllerApi.GetAvailableDomainsApiResponse apiResponse)
        {
            OnGetAvailableDomains?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAvailableDomains(Exception exception)
        {
            OnErrorGetAvailableDomains?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetDomain;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetDomain;

        internal void ExecuteOnGetDomain(DomainControllerApi.GetDomainApiResponse apiResponse)
        {
            OnGetDomain?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetDomain(Exception exception)
        {
            OnErrorGetDomain?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetDomainIssues;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetDomainIssues;

        internal void ExecuteOnGetDomainIssues(DomainControllerApi.GetDomainIssuesApiResponse apiResponse)
        {
            OnGetDomainIssues?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetDomainIssues(Exception exception)
        {
            OnErrorGetDomainIssues?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetDomainWildcardCatchAllInbox;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetDomainWildcardCatchAllInbox;

        internal void ExecuteOnGetDomainWildcardCatchAllInbox(DomainControllerApi.GetDomainWildcardCatchAllInboxApiResponse apiResponse)
        {
            OnGetDomainWildcardCatchAllInbox?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetDomainWildcardCatchAllInbox(Exception exception)
        {
            OnErrorGetDomainWildcardCatchAllInbox?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetDomains;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetDomains;

        internal void ExecuteOnGetDomains(DomainControllerApi.GetDomainsApiResponse apiResponse)
        {
            OnGetDomains?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetDomains(Exception exception)
        {
            OnErrorGetDomains?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetMailSlurpDomains;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetMailSlurpDomains;

        internal void ExecuteOnGetMailSlurpDomains(DomainControllerApi.GetMailSlurpDomainsApiResponse apiResponse)
        {
            OnGetMailSlurpDomains?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMailSlurpDomains(Exception exception)
        {
            OnErrorGetMailSlurpDomains?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUpdateDomain;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUpdateDomain;

        internal void ExecuteOnUpdateDomain(DomainControllerApi.UpdateDomainApiResponse apiResponse)
        {
            OnUpdateDomain?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateDomain(Exception exception)
        {
            OnErrorUpdateDomain?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class DomainControllerApi : IDomainControllerApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<DomainControllerApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public DomainControllerApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="DomainControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public DomainControllerApi(ILogger<DomainControllerApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, DomainControllerApiEvents domainControllerApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<DomainControllerApi>();
            HttpClient = httpClient;
            Events = domainControllerApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatAddDomainWildcardCatchAll(ref Guid id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterAddDomainWildcardCatchAllDefaultImplementation(IAddDomainWildcardCatchAllApiResponse apiResponseLocalVar, Guid id)
        {
            bool suppressDefaultLog = false;
            AfterAddDomainWildcardCatchAll(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterAddDomainWildcardCatchAll(ref bool suppressDefaultLog, IAddDomainWildcardCatchAllApiResponse apiResponseLocalVar, Guid id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorAddDomainWildcardCatchAllDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddDomainWildcardCatchAll(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorAddDomainWildcardCatchAll(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid id);

        /// <summary>
        /// Add catch all wild card inbox to domain Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
        /// </summary>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddDomainWildcardCatchAllApiResponse"/>&gt;</returns>
        public async Task<IAddDomainWildcardCatchAllApiResponse> AddDomainWildcardCatchAllOrDefaultAsync(Guid id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddDomainWildcardCatchAllAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Add catch all wild card inbox to domain Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddDomainWildcardCatchAllApiResponse"/>&gt;</returns>
        public async Task<IAddDomainWildcardCatchAllApiResponse> AddDomainWildcardCatchAllAsync(Guid id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatAddDomainWildcardCatchAll(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/domains/{id}/wildcard"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/domains/{id}/wildcard");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<AddDomainWildcardCatchAllApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddDomainWildcardCatchAllApiResponse>();

                        AddDomainWildcardCatchAllApiResponse apiResponseLocalVar = new AddDomainWildcardCatchAllApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/domains/{id}/wildcard", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAddDomainWildcardCatchAllDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnAddDomainWildcardCatchAll(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddDomainWildcardCatchAllDefaultImplementation(e, "/domains/{id}/wildcard", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorAddDomainWildcardCatchAll(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddDomainWildcardCatchAllApiResponse"/>
        /// </summary>
        public partial class AddDomainWildcardCatchAllApiResponse : mailslurp.Client.ApiResponse, IAddDomainWildcardCatchAllApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddDomainWildcardCatchAllApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddDomainWildcardCatchAllApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddDomainWildcardCatchAllApiResponse(ILogger<AddDomainWildcardCatchAllApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.DomainDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.DomainDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.DomainDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateDomain(CreateDomainOptions createDomainOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createDomainOptions"></param>
        /// <returns></returns>
        private void ValidateCreateDomain(CreateDomainOptions createDomainOptions)
        {
            if (createDomainOptions == null)
                throw new ArgumentNullException(nameof(createDomainOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createDomainOptions"></param>
        private void AfterCreateDomainDefaultImplementation(ICreateDomainApiResponse apiResponseLocalVar, CreateDomainOptions createDomainOptions)
        {
            bool suppressDefaultLog = false;
            AfterCreateDomain(ref suppressDefaultLog, apiResponseLocalVar, createDomainOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createDomainOptions"></param>
        partial void AfterCreateDomain(ref bool suppressDefaultLog, ICreateDomainApiResponse apiResponseLocalVar, CreateDomainOptions createDomainOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createDomainOptions"></param>
        private void OnErrorCreateDomainDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CreateDomainOptions createDomainOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateDomain(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, createDomainOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createDomainOptions"></param>
        partial void OnErrorCreateDomain(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CreateDomainOptions createDomainOptions);

        /// <summary>
        /// Create Domain Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider&#39;s DNS setup to verify the domain.
        /// </summary>
        /// <param name="createDomainOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateDomainApiResponse"/>&gt;</returns>
        public async Task<ICreateDomainApiResponse> CreateDomainOrDefaultAsync(CreateDomainOptions createDomainOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateDomainAsync(createDomainOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Domain Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider&#39;s DNS setup to verify the domain.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createDomainOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateDomainApiResponse"/>&gt;</returns>
        public async Task<ICreateDomainApiResponse> CreateDomainAsync(CreateDomainOptions createDomainOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateDomain(createDomainOptions);

                FormatCreateDomain(createDomainOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/domains"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/domains");

                    httpRequestMessageLocalVar.Content = (createDomainOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createDomainOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<CreateDomainApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateDomainApiResponse>();

                        CreateDomainApiResponse apiResponseLocalVar = new CreateDomainApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/domains", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateDomainDefaultImplementation(apiResponseLocalVar, createDomainOptions);

                        Events.ExecuteOnCreateDomain(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateDomainDefaultImplementation(e, "/domains", uriBuilderLocalVar.Path, createDomainOptions);
                Events.ExecuteOnErrorCreateDomain(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateDomainApiResponse"/>
        /// </summary>
        public partial class CreateDomainApiResponse : mailslurp.Client.ApiResponse, ICreateDomainApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateDomainApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateDomainApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateDomainApiResponse(ILogger<CreateDomainApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.DomainDto Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.DomainDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated(out mailslurp.Model.DomainDto result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteDomain(ref Guid id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDeleteDomainDefaultImplementation(IDeleteDomainApiResponse apiResponseLocalVar, Guid id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteDomain(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDeleteDomain(ref bool suppressDefaultLog, IDeleteDomainApiResponse apiResponseLocalVar, Guid id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteDomainDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteDomain(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteDomain(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid id);

        /// <summary>
        /// Delete a domain Delete a domain. This will disable any existing inboxes that use this domain.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteDomainApiResponse"/>&gt;</returns>
        public async Task<IDeleteDomainApiResponse> DeleteDomainOrDefaultAsync(Guid id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteDomainAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete a domain Delete a domain. This will disable any existing inboxes that use this domain.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteDomainApiResponse"/>&gt;</returns>
        public async Task<IDeleteDomainApiResponse> DeleteDomainAsync(Guid id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteDomain(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/domains/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/domains/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("DELETE");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<DeleteDomainApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteDomainApiResponse>();

                        DeleteDomainApiResponse apiResponseLocalVar = new DeleteDomainApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/domains/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteDomainDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDeleteDomain(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteDomainDefaultImplementation(e, "/domains/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDeleteDomain(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteDomainApiResponse"/>
        /// </summary>
        public partial class DeleteDomainApiResponse : mailslurp.Client.ApiResponse, IDeleteDomainApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteDomainApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteDomainApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteDomainApiResponse(ILogger<DeleteDomainApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public List<string> NoContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNoContent
                    ? System.Text.Json.JsonSerializer.Deserialize<List<string>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 204 NoContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNoContent(out List<string> result)
            {
                result = null;

                try
                {
                    result = NoContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)204);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAvailableDomains(ref Option<string> inboxType);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="inboxType"></param>
        /// <returns></returns>
        private void ValidateGetAvailableDomains(Option<string> inboxType)
        {
            if (inboxType.IsSet && inboxType.Value == null)
                throw new ArgumentNullException(nameof(inboxType));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxType"></param>
        private void AfterGetAvailableDomainsDefaultImplementation(IGetAvailableDomainsApiResponse apiResponseLocalVar, Option<string> inboxType)
        {
            bool suppressDefaultLog = false;
            AfterGetAvailableDomains(ref suppressDefaultLog, apiResponseLocalVar, inboxType);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxType"></param>
        partial void AfterGetAvailableDomains(ref bool suppressDefaultLog, IGetAvailableDomainsApiResponse apiResponseLocalVar, Option<string> inboxType);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxType"></param>
        private void OnErrorGetAvailableDomainsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> inboxType)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAvailableDomains(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxType);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxType"></param>
        partial void OnErrorGetAvailableDomains(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> inboxType);

        /// <summary>
        /// Get all usable domains List all domains available for use with email address creation
        /// </summary>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAvailableDomainsApiResponse"/>&gt;</returns>
        public async Task<IGetAvailableDomainsApiResponse> GetAvailableDomainsOrDefaultAsync(Option<string> inboxType = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAvailableDomainsAsync(inboxType, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all usable domains List all domains available for use with email address creation
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAvailableDomainsApiResponse"/>&gt;</returns>
        public async Task<IGetAvailableDomainsApiResponse> GetAvailableDomainsAsync(Option<string> inboxType = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAvailableDomains(inboxType);

                FormatGetAvailableDomains(ref inboxType);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/domains/available-domains"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/domains/available-domains");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxType.IsSet)
                        parseQueryStringLocalVar["inboxType"] = ClientUtils.ParameterToString(inboxType.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetAvailableDomainsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAvailableDomainsApiResponse>();

                        GetAvailableDomainsApiResponse apiResponseLocalVar = new GetAvailableDomainsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/domains/available-domains", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAvailableDomainsDefaultImplementation(apiResponseLocalVar, inboxType);

                        Events.ExecuteOnGetAvailableDomains(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAvailableDomainsDefaultImplementation(e, "/domains/available-domains", uriBuilderLocalVar.Path, inboxType);
                Events.ExecuteOnErrorGetAvailableDomains(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAvailableDomainsApiResponse"/>
        /// </summary>
        public partial class GetAvailableDomainsApiResponse : mailslurp.Client.ApiResponse, IGetAvailableDomainsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAvailableDomainsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAvailableDomainsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAvailableDomainsApiResponse(ILogger<GetAvailableDomainsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.DomainGroupsDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.DomainGroupsDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.DomainGroupsDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetDomain(ref Guid id, ref Option<bool> checkForErrors);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="checkForErrors"></param>
        private void AfterGetDomainDefaultImplementation(IGetDomainApiResponse apiResponseLocalVar, Guid id, Option<bool> checkForErrors)
        {
            bool suppressDefaultLog = false;
            AfterGetDomain(ref suppressDefaultLog, apiResponseLocalVar, id, checkForErrors);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="checkForErrors"></param>
        partial void AfterGetDomain(ref bool suppressDefaultLog, IGetDomainApiResponse apiResponseLocalVar, Guid id, Option<bool> checkForErrors);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="checkForErrors"></param>
        private void OnErrorGetDomainDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid id, Option<bool> checkForErrors)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetDomain(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, checkForErrors);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="checkForErrors"></param>
        partial void OnErrorGetDomain(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid id, Option<bool> checkForErrors);

        /// <summary>
        /// Get a domain Returns domain verification status and tokens for a given domain
        /// </summary>
        /// <param name="id"></param>
        /// <param name="checkForErrors"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainApiResponse"/>&gt;</returns>
        public async Task<IGetDomainApiResponse> GetDomainOrDefaultAsync(Guid id, Option<bool> checkForErrors = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetDomainAsync(id, checkForErrors, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get a domain Returns domain verification status and tokens for a given domain
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="checkForErrors"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainApiResponse"/>&gt;</returns>
        public async Task<IGetDomainApiResponse> GetDomainAsync(Guid id, Option<bool> checkForErrors = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetDomain(ref id, ref checkForErrors);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/domains/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/domains/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (checkForErrors.IsSet)
                        parseQueryStringLocalVar["checkForErrors"] = ClientUtils.ParameterToString(checkForErrors.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetDomainApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetDomainApiResponse>();

                        GetDomainApiResponse apiResponseLocalVar = new GetDomainApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/domains/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetDomainDefaultImplementation(apiResponseLocalVar, id, checkForErrors);

                        Events.ExecuteOnGetDomain(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetDomainDefaultImplementation(e, "/domains/{id}", uriBuilderLocalVar.Path, id, checkForErrors);
                Events.ExecuteOnErrorGetDomain(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetDomainApiResponse"/>
        /// </summary>
        public partial class GetDomainApiResponse : mailslurp.Client.ApiResponse, IGetDomainApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetDomainApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetDomainApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetDomainApiResponse(ILogger<GetDomainApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.DomainDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.DomainDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.DomainDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetDomainIssuesDefaultImplementation(IGetDomainIssuesApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetDomainIssues(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetDomainIssues(ref bool suppressDefaultLog, IGetDomainIssuesApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetDomainIssuesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetDomainIssues(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetDomainIssues(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Get domain issues List domain issues for domains you have created
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainIssuesApiResponse"/>&gt;</returns>
        public async Task<IGetDomainIssuesApiResponse> GetDomainIssuesOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetDomainIssuesAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get domain issues List domain issues for domains you have created
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainIssuesApiResponse"/>&gt;</returns>
        public async Task<IGetDomainIssuesApiResponse> GetDomainIssuesAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/domains/issues"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/domains/issues");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetDomainIssuesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetDomainIssuesApiResponse>();

                        GetDomainIssuesApiResponse apiResponseLocalVar = new GetDomainIssuesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/domains/issues", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetDomainIssuesDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetDomainIssues(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetDomainIssuesDefaultImplementation(e, "/domains/issues", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetDomainIssues(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetDomainIssuesApiResponse"/>
        /// </summary>
        public partial class GetDomainIssuesApiResponse : mailslurp.Client.ApiResponse, IGetDomainIssuesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetDomainIssuesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetDomainIssuesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetDomainIssuesApiResponse(ILogger<GetDomainIssuesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.DomainIssuesDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.DomainIssuesDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.DomainIssuesDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetDomainWildcardCatchAllInbox(ref Guid id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetDomainWildcardCatchAllInboxDefaultImplementation(IGetDomainWildcardCatchAllInboxApiResponse apiResponseLocalVar, Guid id)
        {
            bool suppressDefaultLog = false;
            AfterGetDomainWildcardCatchAllInbox(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetDomainWildcardCatchAllInbox(ref bool suppressDefaultLog, IGetDomainWildcardCatchAllInboxApiResponse apiResponseLocalVar, Guid id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetDomainWildcardCatchAllInboxDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetDomainWildcardCatchAllInbox(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetDomainWildcardCatchAllInbox(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid id);

        /// <summary>
        /// Get catch all wild card inbox for domain Get the catch all inbox for a domain for missed emails
        /// </summary>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainWildcardCatchAllInboxApiResponse"/>&gt;</returns>
        public async Task<IGetDomainWildcardCatchAllInboxApiResponse> GetDomainWildcardCatchAllInboxOrDefaultAsync(Guid id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetDomainWildcardCatchAllInboxAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get catch all wild card inbox for domain Get the catch all inbox for a domain for missed emails
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainWildcardCatchAllInboxApiResponse"/>&gt;</returns>
        public async Task<IGetDomainWildcardCatchAllInboxApiResponse> GetDomainWildcardCatchAllInboxAsync(Guid id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetDomainWildcardCatchAllInbox(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/domains/{id}/wildcard"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/domains/{id}/wildcard");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetDomainWildcardCatchAllInboxApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetDomainWildcardCatchAllInboxApiResponse>();

                        GetDomainWildcardCatchAllInboxApiResponse apiResponseLocalVar = new GetDomainWildcardCatchAllInboxApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/domains/{id}/wildcard", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetDomainWildcardCatchAllInboxDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetDomainWildcardCatchAllInbox(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetDomainWildcardCatchAllInboxDefaultImplementation(e, "/domains/{id}/wildcard", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetDomainWildcardCatchAllInbox(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetDomainWildcardCatchAllInboxApiResponse"/>
        /// </summary>
        public partial class GetDomainWildcardCatchAllInboxApiResponse : mailslurp.Client.ApiResponse, IGetDomainWildcardCatchAllInboxApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetDomainWildcardCatchAllInboxApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetDomainWildcardCatchAllInboxApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetDomainWildcardCatchAllInboxApiResponse(ILogger<GetDomainWildcardCatchAllInboxApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.InboxDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.InboxDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.InboxDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetDomainsDefaultImplementation(IGetDomainsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetDomains(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetDomains(ref bool suppressDefaultLog, IGetDomainsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetDomainsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetDomains(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetDomains(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Get domains List all custom domains you have created
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainsApiResponse"/>&gt;</returns>
        public async Task<IGetDomainsApiResponse> GetDomainsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetDomainsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get domains List all custom domains you have created
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDomainsApiResponse"/>&gt;</returns>
        public async Task<IGetDomainsApiResponse> GetDomainsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/domains"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/domains");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetDomainsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetDomainsApiResponse>();

                        GetDomainsApiResponse apiResponseLocalVar = new GetDomainsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/domains", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetDomainsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetDomains(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetDomainsDefaultImplementation(e, "/domains", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetDomains(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetDomainsApiResponse"/>
        /// </summary>
        public partial class GetDomainsApiResponse : mailslurp.Client.ApiResponse, IGetDomainsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetDomainsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetDomainsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetDomainsApiResponse(ILogger<GetDomainsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<DomainPreview> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<DomainPreview>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out List<DomainPreview> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetMailSlurpDomains(ref Option<string> inboxType);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="inboxType"></param>
        /// <returns></returns>
        private void ValidateGetMailSlurpDomains(Option<string> inboxType)
        {
            if (inboxType.IsSet && inboxType.Value == null)
                throw new ArgumentNullException(nameof(inboxType));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxType"></param>
        private void AfterGetMailSlurpDomainsDefaultImplementation(IGetMailSlurpDomainsApiResponse apiResponseLocalVar, Option<string> inboxType)
        {
            bool suppressDefaultLog = false;
            AfterGetMailSlurpDomains(ref suppressDefaultLog, apiResponseLocalVar, inboxType);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxType"></param>
        partial void AfterGetMailSlurpDomains(ref bool suppressDefaultLog, IGetMailSlurpDomainsApiResponse apiResponseLocalVar, Option<string> inboxType);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxType"></param>
        private void OnErrorGetMailSlurpDomainsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> inboxType)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetMailSlurpDomains(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxType);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxType"></param>
        partial void OnErrorGetMailSlurpDomains(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> inboxType);

        /// <summary>
        /// Get MailSlurp domains List all MailSlurp domains used with non-custom email addresses
        /// </summary>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMailSlurpDomainsApiResponse"/>&gt;</returns>
        public async Task<IGetMailSlurpDomainsApiResponse> GetMailSlurpDomainsOrDefaultAsync(Option<string> inboxType = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMailSlurpDomainsAsync(inboxType, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get MailSlurp domains List all MailSlurp domains used with non-custom email addresses
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxType"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMailSlurpDomainsApiResponse"/>&gt;</returns>
        public async Task<IGetMailSlurpDomainsApiResponse> GetMailSlurpDomainsAsync(Option<string> inboxType = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetMailSlurpDomains(inboxType);

                FormatGetMailSlurpDomains(ref inboxType);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/domains/mailslurp-domains"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/domains/mailslurp-domains");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxType.IsSet)
                        parseQueryStringLocalVar["inboxType"] = ClientUtils.ParameterToString(inboxType.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetMailSlurpDomainsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMailSlurpDomainsApiResponse>();

                        GetMailSlurpDomainsApiResponse apiResponseLocalVar = new GetMailSlurpDomainsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/domains/mailslurp-domains", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMailSlurpDomainsDefaultImplementation(apiResponseLocalVar, inboxType);

                        Events.ExecuteOnGetMailSlurpDomains(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMailSlurpDomainsDefaultImplementation(e, "/domains/mailslurp-domains", uriBuilderLocalVar.Path, inboxType);
                Events.ExecuteOnErrorGetMailSlurpDomains(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMailSlurpDomainsApiResponse"/>
        /// </summary>
        public partial class GetMailSlurpDomainsApiResponse : mailslurp.Client.ApiResponse, IGetMailSlurpDomainsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMailSlurpDomainsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMailSlurpDomainsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMailSlurpDomainsApiResponse(ILogger<GetMailSlurpDomainsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.DomainGroupsDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.DomainGroupsDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.DomainGroupsDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateDomain(ref Guid id, UpdateDomainOptions updateDomainOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="updateDomainOptions"></param>
        /// <returns></returns>
        private void ValidateUpdateDomain(UpdateDomainOptions updateDomainOptions)
        {
            if (updateDomainOptions == null)
                throw new ArgumentNullException(nameof(updateDomainOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="updateDomainOptions"></param>
        private void AfterUpdateDomainDefaultImplementation(IUpdateDomainApiResponse apiResponseLocalVar, Guid id, UpdateDomainOptions updateDomainOptions)
        {
            bool suppressDefaultLog = false;
            AfterUpdateDomain(ref suppressDefaultLog, apiResponseLocalVar, id, updateDomainOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="updateDomainOptions"></param>
        partial void AfterUpdateDomain(ref bool suppressDefaultLog, IUpdateDomainApiResponse apiResponseLocalVar, Guid id, UpdateDomainOptions updateDomainOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="updateDomainOptions"></param>
        private void OnErrorUpdateDomainDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid id, UpdateDomainOptions updateDomainOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateDomain(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, updateDomainOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="updateDomainOptions"></param>
        partial void OnErrorUpdateDomain(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid id, UpdateDomainOptions updateDomainOptions);

        /// <summary>
        /// Update a domain Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="updateDomainOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateDomainApiResponse"/>&gt;</returns>
        public async Task<IUpdateDomainApiResponse> UpdateDomainOrDefaultAsync(Guid id, UpdateDomainOptions updateDomainOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateDomainAsync(id, updateDomainOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update a domain Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="updateDomainOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateDomainApiResponse"/>&gt;</returns>
        public async Task<IUpdateDomainApiResponse> UpdateDomainAsync(Guid id, UpdateDomainOptions updateDomainOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateDomain(updateDomainOptions);

                FormatUpdateDomain(ref id, updateDomainOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/domains/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/domains/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    httpRequestMessageLocalVar.Content = (updateDomainOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(updateDomainOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("PUT");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UpdateDomainApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateDomainApiResponse>();

                        UpdateDomainApiResponse apiResponseLocalVar = new UpdateDomainApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/domains/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateDomainDefaultImplementation(apiResponseLocalVar, id, updateDomainOptions);

                        Events.ExecuteOnUpdateDomain(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateDomainDefaultImplementation(e, "/domains/{id}", uriBuilderLocalVar.Path, id, updateDomainOptions);
                Events.ExecuteOnErrorUpdateDomain(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateDomainApiResponse"/>
        /// </summary>
        public partial class UpdateDomainApiResponse : mailslurp.Client.ApiResponse, IUpdateDomainApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateDomainApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateDomainApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateDomainApiResponse(ILogger<UpdateDomainApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.DomainDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.DomainDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.DomainDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
