// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IExpiredControllerApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ExpiredControllerApiEvents Events { get; }

        /// <summary>
        /// Get default expiration settings
        /// </summary>
        /// <remarks>
        /// Return default times used for inbox expiration
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpirationDefaultsApiResponse"/>&gt;</returns>
        Task<IGetExpirationDefaultsApiResponse> GetExpirationDefaultsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get default expiration settings
        /// </summary>
        /// <remarks>
        /// Return default times used for inbox expiration
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpirationDefaultsApiResponse"/>&gt;</returns>
        Task<IGetExpirationDefaultsApiResponse> GetExpirationDefaultsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get expired inbox record for a previously existing inbox
        /// </summary>
        /// <remarks>
        /// Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox you want to retrieve (not the inbox ID)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpiredInboxByInboxIdApiResponse"/>&gt;</returns>
        Task<IGetExpiredInboxByInboxIdApiResponse> GetExpiredInboxByInboxIdAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get expired inbox record for a previously existing inbox
        /// </summary>
        /// <remarks>
        /// Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId
        /// </remarks>
        /// <param name="inboxId">ID of inbox you want to retrieve (not the inbox ID)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpiredInboxByInboxIdApiResponse"/>&gt;</returns>
        Task<IGetExpiredInboxByInboxIdApiResponse> GetExpiredInboxByInboxIdOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an expired inbox record
        /// </summary>
        /// <remarks>
        /// Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="expiredId">ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpiredInboxRecordApiResponse"/>&gt;</returns>
        Task<IGetExpiredInboxRecordApiResponse> GetExpiredInboxRecordAsync(Guid expiredId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an expired inbox record
        /// </summary>
        /// <remarks>
        /// Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties
        /// </remarks>
        /// <param name="expiredId">ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpiredInboxRecordApiResponse"/>&gt;</returns>
        Task<IGetExpiredInboxRecordApiResponse> GetExpiredInboxRecordOrDefaultAsync(Guid expiredId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List records of expired inboxes
        /// </summary>
        /// <remarks>
        /// Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="inboxId">Optionally filter by inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpiredInboxesApiResponse"/>&gt;</returns>
        Task<IGetExpiredInboxesApiResponse> GetExpiredInboxesAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List records of expired inboxes
        /// </summary>
        /// <remarks>
        /// Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties
        /// </remarks>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="inboxId">Optionally filter by inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpiredInboxesApiResponse"/>&gt;</returns>
        Task<IGetExpiredInboxesApiResponse> GetExpiredInboxesOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetExpirationDefaultsApiResponse"/>
    /// </summary>
    public interface IGetExpirationDefaultsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ExpirationDefaults>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetExpiredInboxByInboxIdApiResponse"/>
    /// </summary>
    public interface IGetExpiredInboxByInboxIdApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ExpiredInboxDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetExpiredInboxRecordApiResponse"/>
    /// </summary>
    public interface IGetExpiredInboxRecordApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ExpiredInboxDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetExpiredInboxesApiResponse"/>
    /// </summary>
    public interface IGetExpiredInboxesApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.PageExpiredInboxRecordProjection>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ExpiredControllerApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetExpirationDefaults;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetExpirationDefaults;

        internal void ExecuteOnGetExpirationDefaults(ExpiredControllerApi.GetExpirationDefaultsApiResponse apiResponse)
        {
            OnGetExpirationDefaults?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetExpirationDefaults(Exception exception)
        {
            OnErrorGetExpirationDefaults?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetExpiredInboxByInboxId;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetExpiredInboxByInboxId;

        internal void ExecuteOnGetExpiredInboxByInboxId(ExpiredControllerApi.GetExpiredInboxByInboxIdApiResponse apiResponse)
        {
            OnGetExpiredInboxByInboxId?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetExpiredInboxByInboxId(Exception exception)
        {
            OnErrorGetExpiredInboxByInboxId?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetExpiredInboxRecord;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetExpiredInboxRecord;

        internal void ExecuteOnGetExpiredInboxRecord(ExpiredControllerApi.GetExpiredInboxRecordApiResponse apiResponse)
        {
            OnGetExpiredInboxRecord?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetExpiredInboxRecord(Exception exception)
        {
            OnErrorGetExpiredInboxRecord?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetExpiredInboxes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetExpiredInboxes;

        internal void ExecuteOnGetExpiredInboxes(ExpiredControllerApi.GetExpiredInboxesApiResponse apiResponse)
        {
            OnGetExpiredInboxes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetExpiredInboxes(Exception exception)
        {
            OnErrorGetExpiredInboxes?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ExpiredControllerApi : IExpiredControllerApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ExpiredControllerApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ExpiredControllerApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExpiredControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ExpiredControllerApi(ILogger<ExpiredControllerApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ExpiredControllerApiEvents expiredControllerApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ExpiredControllerApi>();
            HttpClient = httpClient;
            Events = expiredControllerApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetExpirationDefaultsDefaultImplementation(IGetExpirationDefaultsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetExpirationDefaults(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetExpirationDefaults(ref bool suppressDefaultLog, IGetExpirationDefaultsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetExpirationDefaultsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetExpirationDefaults(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetExpirationDefaults(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Get default expiration settings Return default times used for inbox expiration
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpirationDefaultsApiResponse"/>&gt;</returns>
        public async Task<IGetExpirationDefaultsApiResponse> GetExpirationDefaultsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetExpirationDefaultsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get default expiration settings Return default times used for inbox expiration
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpirationDefaultsApiResponse"/>&gt;</returns>
        public async Task<IGetExpirationDefaultsApiResponse> GetExpirationDefaultsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/expired/defaults"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/expired/defaults");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetExpirationDefaultsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetExpirationDefaultsApiResponse>();

                        GetExpirationDefaultsApiResponse apiResponseLocalVar = new GetExpirationDefaultsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/expired/defaults", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetExpirationDefaultsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetExpirationDefaults(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetExpirationDefaultsDefaultImplementation(e, "/expired/defaults", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetExpirationDefaults(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetExpirationDefaultsApiResponse"/>
        /// </summary>
        public partial class GetExpirationDefaultsApiResponse : mailslurp.Client.ApiResponse, IGetExpirationDefaultsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetExpirationDefaultsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetExpirationDefaultsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetExpirationDefaultsApiResponse(ILogger<GetExpirationDefaultsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ExpirationDefaults Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ExpirationDefaults>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ExpirationDefaults result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetExpiredInboxByInboxId(ref Guid inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        private void AfterGetExpiredInboxByInboxIdDefaultImplementation(IGetExpiredInboxByInboxIdApiResponse apiResponseLocalVar, Guid inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetExpiredInboxByInboxId(ref suppressDefaultLog, apiResponseLocalVar, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetExpiredInboxByInboxId(ref bool suppressDefaultLog, IGetExpiredInboxByInboxIdApiResponse apiResponseLocalVar, Guid inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetExpiredInboxByInboxIdDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetExpiredInboxByInboxId(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetExpiredInboxByInboxId(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId);

        /// <summary>
        /// Get expired inbox record for a previously existing inbox Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId
        /// </summary>
        /// <param name="inboxId">ID of inbox you want to retrieve (not the inbox ID)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpiredInboxByInboxIdApiResponse"/>&gt;</returns>
        public async Task<IGetExpiredInboxByInboxIdApiResponse> GetExpiredInboxByInboxIdOrDefaultAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetExpiredInboxByInboxIdAsync(inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get expired inbox record for a previously existing inbox Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">ID of inbox you want to retrieve (not the inbox ID)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpiredInboxByInboxIdApiResponse"/>&gt;</returns>
        public async Task<IGetExpiredInboxByInboxIdApiResponse> GetExpiredInboxByInboxIdAsync(Guid inboxId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetExpiredInboxByInboxId(ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/expired/inbox/{inboxId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/expired/inbox/{inboxId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BinboxId%7D", Uri.EscapeDataString(inboxId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetExpiredInboxByInboxIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetExpiredInboxByInboxIdApiResponse>();

                        GetExpiredInboxByInboxIdApiResponse apiResponseLocalVar = new GetExpiredInboxByInboxIdApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/expired/inbox/{inboxId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetExpiredInboxByInboxIdDefaultImplementation(apiResponseLocalVar, inboxId);

                        Events.ExecuteOnGetExpiredInboxByInboxId(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetExpiredInboxByInboxIdDefaultImplementation(e, "/expired/inbox/{inboxId}", uriBuilderLocalVar.Path, inboxId);
                Events.ExecuteOnErrorGetExpiredInboxByInboxId(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetExpiredInboxByInboxIdApiResponse"/>
        /// </summary>
        public partial class GetExpiredInboxByInboxIdApiResponse : mailslurp.Client.ApiResponse, IGetExpiredInboxByInboxIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetExpiredInboxByInboxIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetExpiredInboxByInboxIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetExpiredInboxByInboxIdApiResponse(ILogger<GetExpiredInboxByInboxIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ExpiredInboxDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ExpiredInboxDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ExpiredInboxDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetExpiredInboxRecord(ref Guid expiredId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="expiredId"></param>
        private void AfterGetExpiredInboxRecordDefaultImplementation(IGetExpiredInboxRecordApiResponse apiResponseLocalVar, Guid expiredId)
        {
            bool suppressDefaultLog = false;
            AfterGetExpiredInboxRecord(ref suppressDefaultLog, apiResponseLocalVar, expiredId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="expiredId"></param>
        partial void AfterGetExpiredInboxRecord(ref bool suppressDefaultLog, IGetExpiredInboxRecordApiResponse apiResponseLocalVar, Guid expiredId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="expiredId"></param>
        private void OnErrorGetExpiredInboxRecordDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid expiredId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetExpiredInboxRecord(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, expiredId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="expiredId"></param>
        partial void OnErrorGetExpiredInboxRecord(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid expiredId);

        /// <summary>
        /// Get an expired inbox record Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties
        /// </summary>
        /// <param name="expiredId">ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpiredInboxRecordApiResponse"/>&gt;</returns>
        public async Task<IGetExpiredInboxRecordApiResponse> GetExpiredInboxRecordOrDefaultAsync(Guid expiredId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetExpiredInboxRecordAsync(expiredId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an expired inbox record Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="expiredId">ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpiredInboxRecordApiResponse"/>&gt;</returns>
        public async Task<IGetExpiredInboxRecordApiResponse> GetExpiredInboxRecordAsync(Guid expiredId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetExpiredInboxRecord(ref expiredId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/expired/{expiredId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/expired/{expiredId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BexpiredId%7D", Uri.EscapeDataString(expiredId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetExpiredInboxRecordApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetExpiredInboxRecordApiResponse>();

                        GetExpiredInboxRecordApiResponse apiResponseLocalVar = new GetExpiredInboxRecordApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/expired/{expiredId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetExpiredInboxRecordDefaultImplementation(apiResponseLocalVar, expiredId);

                        Events.ExecuteOnGetExpiredInboxRecord(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetExpiredInboxRecordDefaultImplementation(e, "/expired/{expiredId}", uriBuilderLocalVar.Path, expiredId);
                Events.ExecuteOnErrorGetExpiredInboxRecord(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetExpiredInboxRecordApiResponse"/>
        /// </summary>
        public partial class GetExpiredInboxRecordApiResponse : mailslurp.Client.ApiResponse, IGetExpiredInboxRecordApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetExpiredInboxRecordApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetExpiredInboxRecordApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetExpiredInboxRecordApiResponse(ILogger<GetExpiredInboxRecordApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ExpiredInboxDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ExpiredInboxDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ExpiredInboxDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetExpiredInboxes(ref Option<int> page, ref Option<int> size, ref Option<string> sort, ref Option<DateTime> since, ref Option<DateTime> before, ref Option<Guid> inboxId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateGetExpiredInboxes(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxId"></param>
        private void AfterGetExpiredInboxesDefaultImplementation(IGetExpiredInboxesApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterGetExpiredInboxes(ref suppressDefaultLog, apiResponseLocalVar, page, size, sort, since, before, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxId"></param>
        partial void AfterGetExpiredInboxes(ref bool suppressDefaultLog, IGetExpiredInboxesApiResponse apiResponseLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxId"></param>
        private void OnErrorGetExpiredInboxesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetExpiredInboxes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, page, size, sort, since, before, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="page"></param>
        /// <param name="size"></param>
        /// <param name="sort"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorGetExpiredInboxes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> page, Option<int> size, Option<string> sort, Option<DateTime> since, Option<DateTime> before, Option<Guid> inboxId);

        /// <summary>
        /// List records of expired inboxes Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties
        /// </summary>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="inboxId">Optionally filter by inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpiredInboxesApiResponse"/>&gt;</returns>
        public async Task<IGetExpiredInboxesApiResponse> GetExpiredInboxesOrDefaultAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetExpiredInboxesAsync(page, size, sort, since, before, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List records of expired inboxes Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Optional page index in inbox sent email list pagination (optional, default to 0)</param>
        /// <param name="size">Optional page size in inbox sent email list pagination (optional, default to 20)</param>
        /// <param name="sort">Optional createdAt sort direction ASC or DESC (optional, default to ASC)</param>
        /// <param name="since">Filter by created at after the given timestamp (optional)</param>
        /// <param name="before">Filter by created at before the given timestamp (optional)</param>
        /// <param name="inboxId">Optionally filter by inbox ID (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExpiredInboxesApiResponse"/>&gt;</returns>
        public async Task<IGetExpiredInboxesApiResponse> GetExpiredInboxesAsync(Option<int> page = default, Option<int> size = default, Option<string> sort = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetExpiredInboxes(sort);

                FormatGetExpiredInboxes(ref page, ref size, ref sort, ref since, ref before, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/expired"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/expired");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<GetExpiredInboxesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetExpiredInboxesApiResponse>();

                        GetExpiredInboxesApiResponse apiResponseLocalVar = new GetExpiredInboxesApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/expired", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetExpiredInboxesDefaultImplementation(apiResponseLocalVar, page, size, sort, since, before, inboxId);

                        Events.ExecuteOnGetExpiredInboxes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetExpiredInboxesDefaultImplementation(e, "/expired", uriBuilderLocalVar.Path, page, size, sort, since, before, inboxId);
                Events.ExecuteOnErrorGetExpiredInboxes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetExpiredInboxesApiResponse"/>
        /// </summary>
        public partial class GetExpiredInboxesApiResponse : mailslurp.Client.ApiResponse, IGetExpiredInboxesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetExpiredInboxesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetExpiredInboxesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetExpiredInboxesApiResponse(ILogger<GetExpiredInboxesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.PageExpiredInboxRecordProjection Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.PageExpiredInboxRecordProjection>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.PageExpiredInboxRecordProjection result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
