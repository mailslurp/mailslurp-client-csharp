// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IWaitForControllerApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        WaitForControllerApiEvents Events { get; }

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForApiResponse"/>&gt;</returns>
        Task<IWaitForApiResponse> WaitForAsync(WaitForConditions waitForConditions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <param name="waitForConditions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForApiResponse"/>&gt;</returns>
        Task<IWaitForApiResponse> WaitForOrDefaultAsync(WaitForConditions waitForConditions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForEmailCountApiResponse"/>&gt;</returns>
        Task<IWaitForEmailCountApiResponse> WaitForEmailCountAsync(Guid inboxId, int count, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> before = default, Option<DateTime> since = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForEmailCountApiResponse"/>&gt;</returns>
        Task<IWaitForEmailCountApiResponse> WaitForEmailCountOrDefaultAsync(Guid inboxId, int count, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> before = default, Option<DateTime> since = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForLatestEmailApiResponse"/>&gt;</returns>
        Task<IWaitForLatestEmailApiResponse> WaitForLatestEmailAsync(Option<Guid> inboxId = default, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> before = default, Option<DateTime> since = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </remarks>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForLatestEmailApiResponse"/>&gt;</returns>
        Task<IWaitForLatestEmailApiResponse> WaitForLatestEmailOrDefaultAsync(Option<Guid> inboxId = default, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> before = default, Option<DateTime> since = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait for the latest SMS message to match the provided filter conditions such as body contains keyword.
        /// </summary>
        /// <remarks>
        /// Wait until a phone number meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForLatestSmsApiResponse"/>&gt;</returns>
        Task<IWaitForLatestSmsApiResponse> WaitForLatestSmsAsync(WaitForSingleSmsOptions waitForSingleSmsOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait for the latest SMS message to match the provided filter conditions such as body contains keyword.
        /// </summary>
        /// <remarks>
        /// Wait until a phone number meets given conditions or return immediately if already met
        /// </remarks>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForLatestSmsApiResponse"/>&gt;</returns>
        Task<IWaitForLatestSmsApiResponse> WaitForLatestSmsOrDefaultAsync(WaitForSingleSmsOptions waitForSingleSmsOptions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForMatchingEmailsApiResponse"/>&gt;</returns>
        Task<IWaitForMatchingEmailsApiResponse> WaitForMatchingEmailsAsync(Guid inboxId, int count, MatchOptions matchOptions, Option<DateTime> before = default, Option<DateTime> since = default, Option<string> sort = default, Option<long> delay = default, Option<long> timeout = default, Option<bool> unreadOnly = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForMatchingEmailsApiResponse"/>&gt;</returns>
        Task<IWaitForMatchingEmailsApiResponse> WaitForMatchingEmailsOrDefaultAsync(Guid inboxId, int count, MatchOptions matchOptions, Option<DateTime> before = default, Option<DateTime> since = default, Option<string> sort = default, Option<long> delay = default, Option<long> timeout = default, Option<bool> unreadOnly = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForMatchingFirstEmailApiResponse"/>&gt;</returns>
        Task<IWaitForMatchingFirstEmailApiResponse> WaitForMatchingFirstEmailAsync(Guid inboxId, MatchOptions matchOptions, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForMatchingFirstEmailApiResponse"/>&gt;</returns>
        Task<IWaitForMatchingFirstEmailApiResponse> WaitForMatchingFirstEmailOrDefaultAsync(Guid inboxId, MatchOptions matchOptions, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur.
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForNthEmailApiResponse"/>&gt;</returns>
        Task<IWaitForNthEmailApiResponse> WaitForNthEmailAsync(Option<Guid> inboxId = default, Option<int> index = default, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur.
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForNthEmailApiResponse"/>&gt;</returns>
        Task<IWaitForNthEmailApiResponse> WaitForNthEmailOrDefaultAsync(Option<Guid> inboxId = default, Option<int> index = default, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait for an SMS message to match the provided filter conditions such as body contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSmsConditions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForSmsApiResponse"/>&gt;</returns>
        Task<IWaitForSmsApiResponse> WaitForSmsAsync(WaitForSmsConditions waitForSmsConditions, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Wait for an SMS message to match the provided filter conditions such as body contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
        /// </remarks>
        /// <param name="waitForSmsConditions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForSmsApiResponse"/>&gt;</returns>
        Task<IWaitForSmsApiResponse> WaitForSmsOrDefaultAsync(WaitForSmsConditions waitForSmsConditions, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IWaitForApiResponse"/>
    /// </summary>
    public interface IWaitForApiResponse : mailslurp.Client.IApiResponse, IOk<List<EmailPreview>>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IWaitForEmailCountApiResponse"/>
    /// </summary>
    public interface IWaitForEmailCountApiResponse : mailslurp.Client.IApiResponse, IOk<List<EmailPreview>>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IWaitForLatestEmailApiResponse"/>
    /// </summary>
    public interface IWaitForLatestEmailApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.Email>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IWaitForLatestSmsApiResponse"/>
    /// </summary>
    public interface IWaitForLatestSmsApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.SmsDto>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IWaitForMatchingEmailsApiResponse"/>
    /// </summary>
    public interface IWaitForMatchingEmailsApiResponse : mailslurp.Client.IApiResponse, IOk<List<EmailPreview>>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IWaitForMatchingFirstEmailApiResponse"/>
    /// </summary>
    public interface IWaitForMatchingFirstEmailApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.Email>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IWaitForNthEmailApiResponse"/>
    /// </summary>
    public interface IWaitForNthEmailApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.Email>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IWaitForSmsApiResponse"/>
    /// </summary>
    public interface IWaitForSmsApiResponse : mailslurp.Client.IApiResponse, IOk<List<SmsPreview>>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class WaitForControllerApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnWaitFor;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorWaitFor;

        internal void ExecuteOnWaitFor(WaitForControllerApi.WaitForApiResponse apiResponse)
        {
            OnWaitFor?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorWaitFor(Exception exception)
        {
            OnErrorWaitFor?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnWaitForEmailCount;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorWaitForEmailCount;

        internal void ExecuteOnWaitForEmailCount(WaitForControllerApi.WaitForEmailCountApiResponse apiResponse)
        {
            OnWaitForEmailCount?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorWaitForEmailCount(Exception exception)
        {
            OnErrorWaitForEmailCount?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnWaitForLatestEmail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorWaitForLatestEmail;

        internal void ExecuteOnWaitForLatestEmail(WaitForControllerApi.WaitForLatestEmailApiResponse apiResponse)
        {
            OnWaitForLatestEmail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorWaitForLatestEmail(Exception exception)
        {
            OnErrorWaitForLatestEmail?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnWaitForLatestSms;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorWaitForLatestSms;

        internal void ExecuteOnWaitForLatestSms(WaitForControllerApi.WaitForLatestSmsApiResponse apiResponse)
        {
            OnWaitForLatestSms?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorWaitForLatestSms(Exception exception)
        {
            OnErrorWaitForLatestSms?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnWaitForMatchingEmails;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorWaitForMatchingEmails;

        internal void ExecuteOnWaitForMatchingEmails(WaitForControllerApi.WaitForMatchingEmailsApiResponse apiResponse)
        {
            OnWaitForMatchingEmails?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorWaitForMatchingEmails(Exception exception)
        {
            OnErrorWaitForMatchingEmails?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnWaitForMatchingFirstEmail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorWaitForMatchingFirstEmail;

        internal void ExecuteOnWaitForMatchingFirstEmail(WaitForControllerApi.WaitForMatchingFirstEmailApiResponse apiResponse)
        {
            OnWaitForMatchingFirstEmail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorWaitForMatchingFirstEmail(Exception exception)
        {
            OnErrorWaitForMatchingFirstEmail?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnWaitForNthEmail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorWaitForNthEmail;

        internal void ExecuteOnWaitForNthEmail(WaitForControllerApi.WaitForNthEmailApiResponse apiResponse)
        {
            OnWaitForNthEmail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorWaitForNthEmail(Exception exception)
        {
            OnErrorWaitForNthEmail?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnWaitForSms;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorWaitForSms;

        internal void ExecuteOnWaitForSms(WaitForControllerApi.WaitForSmsApiResponse apiResponse)
        {
            OnWaitForSms?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorWaitForSms(Exception exception)
        {
            OnErrorWaitForSms?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class WaitForControllerApi : IWaitForControllerApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<WaitForControllerApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public WaitForControllerApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="WaitForControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public WaitForControllerApi(ILogger<WaitForControllerApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, WaitForControllerApiEvents waitForControllerApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<WaitForControllerApi>();
            HttpClient = httpClient;
            Events = waitForControllerApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatWaitFor(WaitForConditions waitForConditions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="waitForConditions"></param>
        /// <returns></returns>
        private void ValidateWaitFor(WaitForConditions waitForConditions)
        {
            if (waitForConditions == null)
                throw new ArgumentNullException(nameof(waitForConditions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="waitForConditions"></param>
        private void AfterWaitForDefaultImplementation(IWaitForApiResponse apiResponseLocalVar, WaitForConditions waitForConditions)
        {
            bool suppressDefaultLog = false;
            AfterWaitFor(ref suppressDefaultLog, apiResponseLocalVar, waitForConditions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="waitForConditions"></param>
        partial void AfterWaitFor(ref bool suppressDefaultLog, IWaitForApiResponse apiResponseLocalVar, WaitForConditions waitForConditions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="waitForConditions"></param>
        private void OnErrorWaitForDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, WaitForConditions waitForConditions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorWaitFor(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, waitForConditions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="waitForConditions"></param>
        partial void OnErrorWaitFor(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, WaitForConditions waitForConditions);

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword. Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <param name="waitForConditions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForApiResponse"/>&gt;</returns>
        public async Task<IWaitForApiResponse> WaitForOrDefaultAsync(WaitForConditions waitForConditions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await WaitForAsync(waitForConditions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword. Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForApiResponse"/>&gt;</returns>
        public async Task<IWaitForApiResponse> WaitForAsync(WaitForConditions waitForConditions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateWaitFor(waitForConditions);

                FormatWaitFor(waitForConditions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/waitFor"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/waitFor");

                    httpRequestMessageLocalVar.Content = (waitForConditions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(waitForConditions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<WaitForApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<WaitForApiResponse>();

                        WaitForApiResponse apiResponseLocalVar = new WaitForApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/waitFor", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterWaitForDefaultImplementation(apiResponseLocalVar, waitForConditions);

                        Events.ExecuteOnWaitFor(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorWaitForDefaultImplementation(e, "/waitFor", uriBuilderLocalVar.Path, waitForConditions);
                Events.ExecuteOnErrorWaitFor(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="WaitForApiResponse"/>
        /// </summary>
        public partial class WaitForApiResponse : mailslurp.Client.ApiResponse, IWaitForApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<WaitForApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="WaitForApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public WaitForApiResponse(ILogger<WaitForApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<EmailPreview> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<EmailPreview>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out List<EmailPreview> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatWaitForEmailCount(ref Guid inboxId, ref int count, ref Option<long> timeout, ref Option<bool> unreadOnly, ref Option<DateTime> before, ref Option<DateTime> since, ref Option<string> sort, ref Option<long> delay);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateWaitForEmailCount(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="count"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        private void AfterWaitForEmailCountDefaultImplementation(IWaitForEmailCountApiResponse apiResponseLocalVar, Guid inboxId, int count, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> before, Option<DateTime> since, Option<string> sort, Option<long> delay)
        {
            bool suppressDefaultLog = false;
            AfterWaitForEmailCount(ref suppressDefaultLog, apiResponseLocalVar, inboxId, count, timeout, unreadOnly, before, since, sort, delay);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="count"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        partial void AfterWaitForEmailCount(ref bool suppressDefaultLog, IWaitForEmailCountApiResponse apiResponseLocalVar, Guid inboxId, int count, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> before, Option<DateTime> since, Option<string> sort, Option<long> delay);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="count"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        private void OnErrorWaitForEmailCountDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, int count, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> before, Option<DateTime> since, Option<string> sort, Option<long> delay)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorWaitForEmailCount(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, count, timeout, unreadOnly, before, since, sort, delay);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="count"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        partial void OnErrorWaitForEmailCount(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, int count, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> before, Option<DateTime> since, Option<string> sort, Option<long> delay);

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForEmailCountApiResponse"/>&gt;</returns>
        public async Task<IWaitForEmailCountApiResponse> WaitForEmailCountOrDefaultAsync(Guid inboxId, int count, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> before = default, Option<DateTime> since = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await WaitForEmailCountAsync(inboxId, count, timeout, unreadOnly, before, since, sort, delay, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForEmailCountApiResponse"/>&gt;</returns>
        public async Task<IWaitForEmailCountApiResponse> WaitForEmailCountAsync(Guid inboxId, int count, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> before = default, Option<DateTime> since = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateWaitForEmailCount(sort);

                FormatWaitForEmailCount(ref inboxId, ref count, ref timeout, ref unreadOnly, ref before, ref since, ref sort, ref delay);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/waitForEmailCount"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/waitForEmailCount");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId);
                    parseQueryStringLocalVar["count"] = ClientUtils.ParameterToString(count);

                    if (timeout.IsSet)
                        parseQueryStringLocalVar["timeout"] = ClientUtils.ParameterToString(timeout.Value);

                    if (unreadOnly.IsSet)
                        parseQueryStringLocalVar["unreadOnly"] = ClientUtils.ParameterToString(unreadOnly.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (delay.IsSet)
                        parseQueryStringLocalVar["delay"] = ClientUtils.ParameterToString(delay.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<WaitForEmailCountApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<WaitForEmailCountApiResponse>();

                        WaitForEmailCountApiResponse apiResponseLocalVar = new WaitForEmailCountApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/waitForEmailCount", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterWaitForEmailCountDefaultImplementation(apiResponseLocalVar, inboxId, count, timeout, unreadOnly, before, since, sort, delay);

                        Events.ExecuteOnWaitForEmailCount(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorWaitForEmailCountDefaultImplementation(e, "/waitForEmailCount", uriBuilderLocalVar.Path, inboxId, count, timeout, unreadOnly, before, since, sort, delay);
                Events.ExecuteOnErrorWaitForEmailCount(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="WaitForEmailCountApiResponse"/>
        /// </summary>
        public partial class WaitForEmailCountApiResponse : mailslurp.Client.ApiResponse, IWaitForEmailCountApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<WaitForEmailCountApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="WaitForEmailCountApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public WaitForEmailCountApiResponse(ILogger<WaitForEmailCountApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<EmailPreview> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<EmailPreview>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out List<EmailPreview> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatWaitForLatestEmail(ref Option<Guid> inboxId, ref Option<long> timeout, ref Option<bool> unreadOnly, ref Option<DateTime> before, ref Option<DateTime> since, ref Option<string> sort, ref Option<long> delay);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateWaitForLatestEmail(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        private void AfterWaitForLatestEmailDefaultImplementation(IWaitForLatestEmailApiResponse apiResponseLocalVar, Option<Guid> inboxId, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> before, Option<DateTime> since, Option<string> sort, Option<long> delay)
        {
            bool suppressDefaultLog = false;
            AfterWaitForLatestEmail(ref suppressDefaultLog, apiResponseLocalVar, inboxId, timeout, unreadOnly, before, since, sort, delay);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        partial void AfterWaitForLatestEmail(ref bool suppressDefaultLog, IWaitForLatestEmailApiResponse apiResponseLocalVar, Option<Guid> inboxId, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> before, Option<DateTime> since, Option<string> sort, Option<long> delay);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        private void OnErrorWaitForLatestEmailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> before, Option<DateTime> since, Option<string> sort, Option<long> delay)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorWaitForLatestEmail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, timeout, unreadOnly, before, since, sort, delay);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        partial void OnErrorWaitForLatestEmail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> before, Option<DateTime> since, Option<string> sort, Option<long> delay);

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </summary>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForLatestEmailApiResponse"/>&gt;</returns>
        public async Task<IWaitForLatestEmailApiResponse> WaitForLatestEmailOrDefaultAsync(Option<Guid> inboxId = default, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> before = default, Option<DateTime> since = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await WaitForLatestEmailAsync(inboxId, timeout, unreadOnly, before, since, sort, delay, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForLatestEmailApiResponse"/>&gt;</returns>
        public async Task<IWaitForLatestEmailApiResponse> WaitForLatestEmailAsync(Option<Guid> inboxId = default, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> before = default, Option<DateTime> since = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateWaitForLatestEmail(sort);

                FormatWaitForLatestEmail(ref inboxId, ref timeout, ref unreadOnly, ref before, ref since, ref sort, ref delay);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/waitForLatestEmail"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/waitForLatestEmail");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    if (timeout.IsSet)
                        parseQueryStringLocalVar["timeout"] = ClientUtils.ParameterToString(timeout.Value);

                    if (unreadOnly.IsSet)
                        parseQueryStringLocalVar["unreadOnly"] = ClientUtils.ParameterToString(unreadOnly.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (delay.IsSet)
                        parseQueryStringLocalVar["delay"] = ClientUtils.ParameterToString(delay.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<WaitForLatestEmailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<WaitForLatestEmailApiResponse>();

                        WaitForLatestEmailApiResponse apiResponseLocalVar = new WaitForLatestEmailApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/waitForLatestEmail", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterWaitForLatestEmailDefaultImplementation(apiResponseLocalVar, inboxId, timeout, unreadOnly, before, since, sort, delay);

                        Events.ExecuteOnWaitForLatestEmail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorWaitForLatestEmailDefaultImplementation(e, "/waitForLatestEmail", uriBuilderLocalVar.Path, inboxId, timeout, unreadOnly, before, since, sort, delay);
                Events.ExecuteOnErrorWaitForLatestEmail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="WaitForLatestEmailApiResponse"/>
        /// </summary>
        public partial class WaitForLatestEmailApiResponse : mailslurp.Client.ApiResponse, IWaitForLatestEmailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<WaitForLatestEmailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="WaitForLatestEmailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public WaitForLatestEmailApiResponse(ILogger<WaitForLatestEmailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.Email Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.Email>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.Email result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatWaitForLatestSms(WaitForSingleSmsOptions waitForSingleSmsOptions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <returns></returns>
        private void ValidateWaitForLatestSms(WaitForSingleSmsOptions waitForSingleSmsOptions)
        {
            if (waitForSingleSmsOptions == null)
                throw new ArgumentNullException(nameof(waitForSingleSmsOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="waitForSingleSmsOptions"></param>
        private void AfterWaitForLatestSmsDefaultImplementation(IWaitForLatestSmsApiResponse apiResponseLocalVar, WaitForSingleSmsOptions waitForSingleSmsOptions)
        {
            bool suppressDefaultLog = false;
            AfterWaitForLatestSms(ref suppressDefaultLog, apiResponseLocalVar, waitForSingleSmsOptions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="waitForSingleSmsOptions"></param>
        partial void AfterWaitForLatestSms(ref bool suppressDefaultLog, IWaitForLatestSmsApiResponse apiResponseLocalVar, WaitForSingleSmsOptions waitForSingleSmsOptions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="waitForSingleSmsOptions"></param>
        private void OnErrorWaitForLatestSmsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, WaitForSingleSmsOptions waitForSingleSmsOptions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorWaitForLatestSms(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, waitForSingleSmsOptions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="waitForSingleSmsOptions"></param>
        partial void OnErrorWaitForLatestSms(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, WaitForSingleSmsOptions waitForSingleSmsOptions);

        /// <summary>
        /// Wait for the latest SMS message to match the provided filter conditions such as body contains keyword. Wait until a phone number meets given conditions or return immediately if already met
        /// </summary>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForLatestSmsApiResponse"/>&gt;</returns>
        public async Task<IWaitForLatestSmsApiResponse> WaitForLatestSmsOrDefaultAsync(WaitForSingleSmsOptions waitForSingleSmsOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await WaitForLatestSmsAsync(waitForSingleSmsOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Wait for the latest SMS message to match the provided filter conditions such as body contains keyword. Wait until a phone number meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForLatestSmsApiResponse"/>&gt;</returns>
        public async Task<IWaitForLatestSmsApiResponse> WaitForLatestSmsAsync(WaitForSingleSmsOptions waitForSingleSmsOptions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateWaitForLatestSms(waitForSingleSmsOptions);

                FormatWaitForLatestSms(waitForSingleSmsOptions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/waitForLatestSms"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/waitForLatestSms");

                    httpRequestMessageLocalVar.Content = (waitForSingleSmsOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(waitForSingleSmsOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<WaitForLatestSmsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<WaitForLatestSmsApiResponse>();

                        WaitForLatestSmsApiResponse apiResponseLocalVar = new WaitForLatestSmsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/waitForLatestSms", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterWaitForLatestSmsDefaultImplementation(apiResponseLocalVar, waitForSingleSmsOptions);

                        Events.ExecuteOnWaitForLatestSms(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorWaitForLatestSmsDefaultImplementation(e, "/waitForLatestSms", uriBuilderLocalVar.Path, waitForSingleSmsOptions);
                Events.ExecuteOnErrorWaitForLatestSms(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="WaitForLatestSmsApiResponse"/>
        /// </summary>
        public partial class WaitForLatestSmsApiResponse : mailslurp.Client.ApiResponse, IWaitForLatestSmsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<WaitForLatestSmsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="WaitForLatestSmsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public WaitForLatestSmsApiResponse(ILogger<WaitForLatestSmsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.SmsDto Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.SmsDto>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.SmsDto result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatWaitForMatchingEmails(ref Guid inboxId, ref int count, MatchOptions matchOptions, ref Option<DateTime> before, ref Option<DateTime> since, ref Option<string> sort, ref Option<long> delay, ref Option<long> timeout, ref Option<bool> unreadOnly);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="matchOptions"></param>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateWaitForMatchingEmails(MatchOptions matchOptions, Option<string> sort)
        {
            if (matchOptions == null)
                throw new ArgumentNullException(nameof(matchOptions));

            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="count"></param>
        /// <param name="matchOptions"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        private void AfterWaitForMatchingEmailsDefaultImplementation(IWaitForMatchingEmailsApiResponse apiResponseLocalVar, Guid inboxId, int count, MatchOptions matchOptions, Option<DateTime> before, Option<DateTime> since, Option<string> sort, Option<long> delay, Option<long> timeout, Option<bool> unreadOnly)
        {
            bool suppressDefaultLog = false;
            AfterWaitForMatchingEmails(ref suppressDefaultLog, apiResponseLocalVar, inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="count"></param>
        /// <param name="matchOptions"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        partial void AfterWaitForMatchingEmails(ref bool suppressDefaultLog, IWaitForMatchingEmailsApiResponse apiResponseLocalVar, Guid inboxId, int count, MatchOptions matchOptions, Option<DateTime> before, Option<DateTime> since, Option<string> sort, Option<long> delay, Option<long> timeout, Option<bool> unreadOnly);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="count"></param>
        /// <param name="matchOptions"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        private void OnErrorWaitForMatchingEmailsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, int count, MatchOptions matchOptions, Option<DateTime> before, Option<DateTime> since, Option<string> sort, Option<long> delay, Option<long> timeout, Option<bool> unreadOnly)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorWaitForMatchingEmails(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="count"></param>
        /// <param name="matchOptions"></param>
        /// <param name="before"></param>
        /// <param name="since"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        partial void OnErrorWaitForMatchingEmails(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, int count, MatchOptions matchOptions, Option<DateTime> before, Option<DateTime> since, Option<string> sort, Option<long> delay, Option<long> timeout, Option<bool> unreadOnly);

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForMatchingEmailsApiResponse"/>&gt;</returns>
        public async Task<IWaitForMatchingEmailsApiResponse> WaitForMatchingEmailsOrDefaultAsync(Guid inboxId, int count, MatchOptions matchOptions, Option<DateTime> before = default, Option<DateTime> since = default, Option<string> sort = default, Option<long> delay = default, Option<long> timeout = default, Option<bool> unreadOnly = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await WaitForMatchingEmailsAsync(inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForMatchingEmailsApiResponse"/>&gt;</returns>
        public async Task<IWaitForMatchingEmailsApiResponse> WaitForMatchingEmailsAsync(Guid inboxId, int count, MatchOptions matchOptions, Option<DateTime> before = default, Option<DateTime> since = default, Option<string> sort = default, Option<long> delay = default, Option<long> timeout = default, Option<bool> unreadOnly = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateWaitForMatchingEmails(matchOptions, sort);

                FormatWaitForMatchingEmails(ref inboxId, ref count, matchOptions, ref before, ref since, ref sort, ref delay, ref timeout, ref unreadOnly);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/waitForMatchingEmails"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/waitForMatchingEmails");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId);
                    parseQueryStringLocalVar["count"] = ClientUtils.ParameterToString(count);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (delay.IsSet)
                        parseQueryStringLocalVar["delay"] = ClientUtils.ParameterToString(delay.Value);

                    if (timeout.IsSet)
                        parseQueryStringLocalVar["timeout"] = ClientUtils.ParameterToString(timeout.Value);

                    if (unreadOnly.IsSet)
                        parseQueryStringLocalVar["unreadOnly"] = ClientUtils.ParameterToString(unreadOnly.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (matchOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(matchOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<WaitForMatchingEmailsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<WaitForMatchingEmailsApiResponse>();

                        WaitForMatchingEmailsApiResponse apiResponseLocalVar = new WaitForMatchingEmailsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/waitForMatchingEmails", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterWaitForMatchingEmailsDefaultImplementation(apiResponseLocalVar, inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly);

                        Events.ExecuteOnWaitForMatchingEmails(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorWaitForMatchingEmailsDefaultImplementation(e, "/waitForMatchingEmails", uriBuilderLocalVar.Path, inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly);
                Events.ExecuteOnErrorWaitForMatchingEmails(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="WaitForMatchingEmailsApiResponse"/>
        /// </summary>
        public partial class WaitForMatchingEmailsApiResponse : mailslurp.Client.ApiResponse, IWaitForMatchingEmailsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<WaitForMatchingEmailsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="WaitForMatchingEmailsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public WaitForMatchingEmailsApiResponse(ILogger<WaitForMatchingEmailsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<EmailPreview> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<EmailPreview>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out List<EmailPreview> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatWaitForMatchingFirstEmail(ref Guid inboxId, MatchOptions matchOptions, ref Option<long> timeout, ref Option<bool> unreadOnly, ref Option<DateTime> since, ref Option<DateTime> before, ref Option<string> sort, ref Option<long> delay);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="matchOptions"></param>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateWaitForMatchingFirstEmail(MatchOptions matchOptions, Option<string> sort)
        {
            if (matchOptions == null)
                throw new ArgumentNullException(nameof(matchOptions));

            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        private void AfterWaitForMatchingFirstEmailDefaultImplementation(IWaitForMatchingFirstEmailApiResponse apiResponseLocalVar, Guid inboxId, MatchOptions matchOptions, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> since, Option<DateTime> before, Option<string> sort, Option<long> delay)
        {
            bool suppressDefaultLog = false;
            AfterWaitForMatchingFirstEmail(ref suppressDefaultLog, apiResponseLocalVar, inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        partial void AfterWaitForMatchingFirstEmail(ref bool suppressDefaultLog, IWaitForMatchingFirstEmailApiResponse apiResponseLocalVar, Guid inboxId, MatchOptions matchOptions, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> since, Option<DateTime> before, Option<string> sort, Option<long> delay);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        private void OnErrorWaitForMatchingFirstEmailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, MatchOptions matchOptions, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> since, Option<DateTime> before, Option<string> sort, Option<long> delay)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorWaitForMatchingFirstEmail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        partial void OnErrorWaitForMatchingFirstEmail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid inboxId, MatchOptions matchOptions, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> since, Option<DateTime> before, Option<string> sort, Option<long> delay);

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForMatchingFirstEmailApiResponse"/>&gt;</returns>
        public async Task<IWaitForMatchingFirstEmailApiResponse> WaitForMatchingFirstEmailOrDefaultAsync(Guid inboxId, MatchOptions matchOptions, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await WaitForMatchingFirstEmailAsync(inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForMatchingFirstEmailApiResponse"/>&gt;</returns>
        public async Task<IWaitForMatchingFirstEmailApiResponse> WaitForMatchingFirstEmailAsync(Guid inboxId, MatchOptions matchOptions, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateWaitForMatchingFirstEmail(matchOptions, sort);

                FormatWaitForMatchingFirstEmail(ref inboxId, matchOptions, ref timeout, ref unreadOnly, ref since, ref before, ref sort, ref delay);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/waitForMatchingFirstEmail"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/waitForMatchingFirstEmail");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId);

                    if (timeout.IsSet)
                        parseQueryStringLocalVar["timeout"] = ClientUtils.ParameterToString(timeout.Value);

                    if (unreadOnly.IsSet)
                        parseQueryStringLocalVar["unreadOnly"] = ClientUtils.ParameterToString(unreadOnly.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (delay.IsSet)
                        parseQueryStringLocalVar["delay"] = ClientUtils.ParameterToString(delay.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (matchOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(matchOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<WaitForMatchingFirstEmailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<WaitForMatchingFirstEmailApiResponse>();

                        WaitForMatchingFirstEmailApiResponse apiResponseLocalVar = new WaitForMatchingFirstEmailApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/waitForMatchingFirstEmail", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterWaitForMatchingFirstEmailDefaultImplementation(apiResponseLocalVar, inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay);

                        Events.ExecuteOnWaitForMatchingFirstEmail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorWaitForMatchingFirstEmailDefaultImplementation(e, "/waitForMatchingFirstEmail", uriBuilderLocalVar.Path, inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay);
                Events.ExecuteOnErrorWaitForMatchingFirstEmail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="WaitForMatchingFirstEmailApiResponse"/>
        /// </summary>
        public partial class WaitForMatchingFirstEmailApiResponse : mailslurp.Client.ApiResponse, IWaitForMatchingFirstEmailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<WaitForMatchingFirstEmailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="WaitForMatchingFirstEmailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public WaitForMatchingFirstEmailApiResponse(ILogger<WaitForMatchingFirstEmailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.Email Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.Email>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.Email result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatWaitForNthEmail(ref Option<Guid> inboxId, ref Option<int> index, ref Option<long> timeout, ref Option<bool> unreadOnly, ref Option<DateTime> since, ref Option<DateTime> before, ref Option<string> sort, ref Option<long> delay);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateWaitForNthEmail(Option<string> sort)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="index"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        private void AfterWaitForNthEmailDefaultImplementation(IWaitForNthEmailApiResponse apiResponseLocalVar, Option<Guid> inboxId, Option<int> index, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> since, Option<DateTime> before, Option<string> sort, Option<long> delay)
        {
            bool suppressDefaultLog = false;
            AfterWaitForNthEmail(ref suppressDefaultLog, apiResponseLocalVar, inboxId, index, timeout, unreadOnly, since, before, sort, delay);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="index"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        partial void AfterWaitForNthEmail(ref bool suppressDefaultLog, IWaitForNthEmailApiResponse apiResponseLocalVar, Option<Guid> inboxId, Option<int> index, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> since, Option<DateTime> before, Option<string> sort, Option<long> delay);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="index"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        private void OnErrorWaitForNthEmailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId, Option<int> index, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> since, Option<DateTime> before, Option<string> sort, Option<long> delay)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorWaitForNthEmail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, inboxId, index, timeout, unreadOnly, since, before, sort, delay);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="inboxId"></param>
        /// <param name="index"></param>
        /// <param name="timeout"></param>
        /// <param name="unreadOnly"></param>
        /// <param name="since"></param>
        /// <param name="before"></param>
        /// <param name="sort"></param>
        /// <param name="delay"></param>
        partial void OnErrorWaitForNthEmail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> inboxId, Option<int> index, Option<long> timeout, Option<bool> unreadOnly, Option<DateTime> since, Option<DateTime> before, Option<string> sort, Option<long> delay);

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur. If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForNthEmailApiResponse"/>&gt;</returns>
        public async Task<IWaitForNthEmailApiResponse> WaitForNthEmailOrDefaultAsync(Option<Guid> inboxId = default, Option<int> index = default, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await WaitForNthEmailAsync(inboxId, index, timeout, unreadOnly, since, before, sort, delay, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur. If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForNthEmailApiResponse"/>&gt;</returns>
        public async Task<IWaitForNthEmailApiResponse> WaitForNthEmailAsync(Option<Guid> inboxId = default, Option<int> index = default, Option<long> timeout = default, Option<bool> unreadOnly = default, Option<DateTime> since = default, Option<DateTime> before = default, Option<string> sort = default, Option<long> delay = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateWaitForNthEmail(sort);

                FormatWaitForNthEmail(ref inboxId, ref index, ref timeout, ref unreadOnly, ref since, ref before, ref sort, ref delay);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/waitForNthEmail"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/waitForNthEmail");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    if (index.IsSet)
                        parseQueryStringLocalVar["index"] = ClientUtils.ParameterToString(index.Value);

                    if (timeout.IsSet)
                        parseQueryStringLocalVar["timeout"] = ClientUtils.ParameterToString(timeout.Value);

                    if (unreadOnly.IsSet)
                        parseQueryStringLocalVar["unreadOnly"] = ClientUtils.ParameterToString(unreadOnly.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (delay.IsSet)
                        parseQueryStringLocalVar["delay"] = ClientUtils.ParameterToString(delay.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("GET");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<WaitForNthEmailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<WaitForNthEmailApiResponse>();

                        WaitForNthEmailApiResponse apiResponseLocalVar = new WaitForNthEmailApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/waitForNthEmail", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterWaitForNthEmailDefaultImplementation(apiResponseLocalVar, inboxId, index, timeout, unreadOnly, since, before, sort, delay);

                        Events.ExecuteOnWaitForNthEmail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorWaitForNthEmailDefaultImplementation(e, "/waitForNthEmail", uriBuilderLocalVar.Path, inboxId, index, timeout, unreadOnly, since, before, sort, delay);
                Events.ExecuteOnErrorWaitForNthEmail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="WaitForNthEmailApiResponse"/>
        /// </summary>
        public partial class WaitForNthEmailApiResponse : mailslurp.Client.ApiResponse, IWaitForNthEmailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<WaitForNthEmailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="WaitForNthEmailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public WaitForNthEmailApiResponse(ILogger<WaitForNthEmailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.Email Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.Email>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.Email result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatWaitForSms(WaitForSmsConditions waitForSmsConditions);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="waitForSmsConditions"></param>
        /// <returns></returns>
        private void ValidateWaitForSms(WaitForSmsConditions waitForSmsConditions)
        {
            if (waitForSmsConditions == null)
                throw new ArgumentNullException(nameof(waitForSmsConditions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="waitForSmsConditions"></param>
        private void AfterWaitForSmsDefaultImplementation(IWaitForSmsApiResponse apiResponseLocalVar, WaitForSmsConditions waitForSmsConditions)
        {
            bool suppressDefaultLog = false;
            AfterWaitForSms(ref suppressDefaultLog, apiResponseLocalVar, waitForSmsConditions);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="waitForSmsConditions"></param>
        partial void AfterWaitForSms(ref bool suppressDefaultLog, IWaitForSmsApiResponse apiResponseLocalVar, WaitForSmsConditions waitForSmsConditions);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="waitForSmsConditions"></param>
        private void OnErrorWaitForSmsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, WaitForSmsConditions waitForSmsConditions)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorWaitForSms(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, waitForSmsConditions);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="waitForSmsConditions"></param>
        partial void OnErrorWaitForSms(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, WaitForSmsConditions waitForSmsConditions);

        /// <summary>
        /// Wait for an SMS message to match the provided filter conditions such as body contains keyword. Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
        /// </summary>
        /// <param name="waitForSmsConditions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForSmsApiResponse"/>&gt;</returns>
        public async Task<IWaitForSmsApiResponse> WaitForSmsOrDefaultAsync(WaitForSmsConditions waitForSmsConditions, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await WaitForSmsAsync(waitForSmsConditions, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Wait for an SMS message to match the provided filter conditions such as body contains keyword. Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSmsConditions"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWaitForSmsApiResponse"/>&gt;</returns>
        public async Task<IWaitForSmsApiResponse> WaitForSmsAsync(WaitForSmsConditions waitForSmsConditions, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateWaitForSms(waitForSmsConditions);

                FormatWaitForSms(waitForSmsConditions);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/waitForSms"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/waitForSms");

                    httpRequestMessageLocalVar.Content = (waitForSmsConditions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(waitForSmsConditions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<WaitForSmsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<WaitForSmsApiResponse>();

                        WaitForSmsApiResponse apiResponseLocalVar = new WaitForSmsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/waitForSms", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterWaitForSmsDefaultImplementation(apiResponseLocalVar, waitForSmsConditions);

                        Events.ExecuteOnWaitForSms(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorWaitForSmsDefaultImplementation(e, "/waitForSms", uriBuilderLocalVar.Path, waitForSmsConditions);
                Events.ExecuteOnErrorWaitForSms(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="WaitForSmsApiResponse"/>
        /// </summary>
        public partial class WaitForSmsApiResponse : mailslurp.Client.ApiResponse, IWaitForSmsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<WaitForSmsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="WaitForSmsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public WaitForSmsApiResponse(ILogger<WaitForSmsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<SmsPreview> Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<SmsPreview>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out List<SmsPreview> result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
