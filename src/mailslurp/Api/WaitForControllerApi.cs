/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IWaitForControllerApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        List<EmailPreview> WaitFor(WaitForConditions waitForConditions, int operationIndex = 0);

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        ApiResponse<List<EmailPreview>> WaitForWithHttpInfo(WaitForConditions waitForConditions, int operationIndex = 0);
        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        List<EmailPreview> WaitForEmailCount(Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0);

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        ApiResponse<List<EmailPreview>> WaitForEmailCountWithHttpInfo(Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0);
        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        Email WaitForLatestEmail(Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0);

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        ApiResponse<Email> WaitForLatestEmailWithHttpInfo(Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0);
        /// <summary>
        /// Wait for the latest SMS message to match the provided filter conditions such as body contains keyword.
        /// </summary>
        /// <remarks>
        /// Wait until a phone number meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SmsDto</returns>
        SmsDto WaitForLatestSms(WaitForSingleSmsOptions waitForSingleSmsOptions, int operationIndex = 0);

        /// <summary>
        /// Wait for the latest SMS message to match the provided filter conditions such as body contains keyword.
        /// </summary>
        /// <remarks>
        /// Wait until a phone number meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SmsDto</returns>
        ApiResponse<SmsDto> WaitForLatestSmsWithHttpInfo(WaitForSingleSmsOptions waitForSingleSmsOptions, int operationIndex = 0);
        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        List<EmailPreview> WaitForMatchingEmails(Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?), int operationIndex = 0);

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        ApiResponse<List<EmailPreview>> WaitForMatchingEmailsWithHttpInfo(Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?), int operationIndex = 0);
        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        Email WaitForMatchingFirstEmail(Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0);

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        ApiResponse<Email> WaitForMatchingFirstEmailWithHttpInfo(Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0);
        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur.
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        Email WaitForNthEmail(Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0);

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur.
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        ApiResponse<Email> WaitForNthEmailWithHttpInfo(Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0);
        /// <summary>
        /// Wait for an SMS message to match the provided filter conditions such as body contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSmsConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;SmsPreview&gt;</returns>
        List<SmsPreview> WaitForSms(WaitForSmsConditions waitForSmsConditions, int operationIndex = 0);

        /// <summary>
        /// Wait for an SMS message to match the provided filter conditions such as body contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSmsConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;SmsPreview&gt;</returns>
        ApiResponse<List<SmsPreview>> WaitForSmsWithHttpInfo(WaitForSmsConditions waitForSmsConditions, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IWaitForControllerApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        System.Threading.Tasks.Task<List<EmailPreview>> WaitForAsync(WaitForConditions waitForConditions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> WaitForWithHttpInfoAsync(WaitForConditions waitForConditions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        System.Threading.Tasks.Task<List<EmailPreview>> WaitForEmailCountAsync(Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> WaitForEmailCountWithHttpInfoAsync(Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        System.Threading.Tasks.Task<Email> WaitForLatestEmailAsync(Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        System.Threading.Tasks.Task<ApiResponse<Email>> WaitForLatestEmailWithHttpInfoAsync(Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Wait for the latest SMS message to match the provided filter conditions such as body contains keyword.
        /// </summary>
        /// <remarks>
        /// Wait until a phone number meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SmsDto</returns>
        System.Threading.Tasks.Task<SmsDto> WaitForLatestSmsAsync(WaitForSingleSmsOptions waitForSingleSmsOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Wait for the latest SMS message to match the provided filter conditions such as body contains keyword.
        /// </summary>
        /// <remarks>
        /// Wait until a phone number meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SmsDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<SmsDto>> WaitForLatestSmsWithHttpInfoAsync(WaitForSingleSmsOptions waitForSingleSmsOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        System.Threading.Tasks.Task<List<EmailPreview>> WaitForMatchingEmailsAsync(Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> WaitForMatchingEmailsWithHttpInfoAsync(Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        System.Threading.Tasks.Task<Email> WaitForMatchingFirstEmailAsync(Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        System.Threading.Tasks.Task<ApiResponse<Email>> WaitForMatchingFirstEmailWithHttpInfoAsync(Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur.
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        System.Threading.Tasks.Task<Email> WaitForNthEmailAsync(Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur.
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        System.Threading.Tasks.Task<ApiResponse<Email>> WaitForNthEmailWithHttpInfoAsync(Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Wait for an SMS message to match the provided filter conditions such as body contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSmsConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;SmsPreview&gt;</returns>
        System.Threading.Tasks.Task<List<SmsPreview>> WaitForSmsAsync(WaitForSmsConditions waitForSmsConditions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Wait for an SMS message to match the provided filter conditions such as body contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSmsConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;SmsPreview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<SmsPreview>>> WaitForSmsWithHttpInfoAsync(WaitForSmsConditions waitForSmsConditions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IWaitForControllerApi : IWaitForControllerApiSync, IWaitForControllerApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class WaitForControllerApi : IWaitForControllerApi
    {
        private mailslurp.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="WaitForControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public WaitForControllerApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WaitForControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public WaitForControllerApi(string basePath)
        {
            this.Configuration = mailslurp.Client.Configuration.MergeConfigurations(
                mailslurp.Client.GlobalConfiguration.Instance,
                new mailslurp.Client.Configuration { BasePath = basePath }
            );
            this.Client = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WaitForControllerApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public WaitForControllerApi(mailslurp.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = mailslurp.Client.Configuration.MergeConfigurations(
                mailslurp.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WaitForControllerApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public WaitForControllerApi(mailslurp.Client.ISynchronousClient client, mailslurp.Client.IAsynchronousClient asyncClient, mailslurp.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public mailslurp.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public mailslurp.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public mailslurp.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public mailslurp.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword. Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        public List<EmailPreview> WaitFor(WaitForConditions waitForConditions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = WaitForWithHttpInfo(waitForConditions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword. Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        public mailslurp.Client.ApiResponse<List<EmailPreview>> WaitForWithHttpInfo(WaitForConditions waitForConditions, int operationIndex = 0)
        {
            // verify the required parameter 'waitForConditions' is set
            if (waitForConditions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'waitForConditions' when calling WaitForControllerApi->WaitFor");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = waitForConditions;

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitFor";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<EmailPreview>>("/waitFor", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitFor", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword. Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        public async System.Threading.Tasks.Task<List<EmailPreview>> WaitForAsync(WaitForConditions waitForConditions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = await WaitForWithHttpInfoAsync(waitForConditions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword. Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<List<EmailPreview>>> WaitForWithHttpInfoAsync(WaitForConditions waitForConditions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'waitForConditions' is set
            if (waitForConditions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'waitForConditions' when calling WaitForControllerApi->WaitFor");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = waitForConditions;

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitFor";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<List<EmailPreview>>("/waitFor", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitFor", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        public List<EmailPreview> WaitForEmailCount(Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = WaitForEmailCountWithHttpInfo(inboxId, count, timeout, unreadOnly, before, since, sort, delay);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        public mailslurp.Client.ApiResponse<List<EmailPreview>> WaitForEmailCountWithHttpInfo(Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForEmailCount";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<EmailPreview>>("/waitForEmailCount", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForEmailCount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        public async System.Threading.Tasks.Task<List<EmailPreview>> WaitForEmailCountAsync(Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = await WaitForEmailCountWithHttpInfoAsync(inboxId, count, timeout, unreadOnly, before, since, sort, delay, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<List<EmailPreview>>> WaitForEmailCountWithHttpInfoAsync(Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForEmailCount";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<EmailPreview>>("/waitForEmailCount", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForEmailCount", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        public Email WaitForLatestEmail(Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = WaitForLatestEmailWithHttpInfo(inboxId, timeout, unreadOnly, before, since, sort, delay);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        public mailslurp.Client.ApiResponse<Email> WaitForLatestEmailWithHttpInfo(Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForLatestEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Email>("/waitForLatestEmail", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForLatestEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        public async System.Threading.Tasks.Task<Email> WaitForLatestEmailAsync(Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = await WaitForLatestEmailWithHttpInfoAsync(inboxId, timeout, unreadOnly, before, since, sort, delay, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Email>> WaitForLatestEmailWithHttpInfoAsync(Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForLatestEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Email>("/waitForLatestEmail", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForLatestEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for the latest SMS message to match the provided filter conditions such as body contains keyword. Wait until a phone number meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SmsDto</returns>
        public SmsDto WaitForLatestSms(WaitForSingleSmsOptions waitForSingleSmsOptions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<SmsDto> localVarResponse = WaitForLatestSmsWithHttpInfo(waitForSingleSmsOptions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for the latest SMS message to match the provided filter conditions such as body contains keyword. Wait until a phone number meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SmsDto</returns>
        public mailslurp.Client.ApiResponse<SmsDto> WaitForLatestSmsWithHttpInfo(WaitForSingleSmsOptions waitForSingleSmsOptions, int operationIndex = 0)
        {
            // verify the required parameter 'waitForSingleSmsOptions' is set
            if (waitForSingleSmsOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'waitForSingleSmsOptions' when calling WaitForControllerApi->WaitForLatestSms");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = waitForSingleSmsOptions;

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForLatestSms";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SmsDto>("/waitForLatestSms", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForLatestSms", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for the latest SMS message to match the provided filter conditions such as body contains keyword. Wait until a phone number meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SmsDto</returns>
        public async System.Threading.Tasks.Task<SmsDto> WaitForLatestSmsAsync(WaitForSingleSmsOptions waitForSingleSmsOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<SmsDto> localVarResponse = await WaitForLatestSmsWithHttpInfoAsync(waitForSingleSmsOptions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for the latest SMS message to match the provided filter conditions such as body contains keyword. Wait until a phone number meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSingleSmsOptions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SmsDto)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<SmsDto>> WaitForLatestSmsWithHttpInfoAsync(WaitForSingleSmsOptions waitForSingleSmsOptions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'waitForSingleSmsOptions' is set
            if (waitForSingleSmsOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'waitForSingleSmsOptions' when calling WaitForControllerApi->WaitForLatestSms");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = waitForSingleSmsOptions;

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForLatestSms";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SmsDto>("/waitForLatestSms", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForLatestSms", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        public List<EmailPreview> WaitForMatchingEmails(Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = WaitForMatchingEmailsWithHttpInfo(inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        public mailslurp.Client.ApiResponse<List<EmailPreview>> WaitForMatchingEmailsWithHttpInfo(Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?), int operationIndex = 0)
        {
            // verify the required parameter 'matchOptions' is set
            if (matchOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'matchOptions' when calling WaitForControllerApi->WaitForMatchingEmails");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            localVarRequestOptions.Data = matchOptions;

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForMatchingEmails";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<EmailPreview>>("/waitForMatchingEmails", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForMatchingEmails", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        public async System.Threading.Tasks.Task<List<EmailPreview>> WaitForMatchingEmailsAsync(Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = await WaitForMatchingEmailsWithHttpInfoAsync(inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<List<EmailPreview>>> WaitForMatchingEmailsWithHttpInfoAsync(Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'matchOptions' is set
            if (matchOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'matchOptions' when calling WaitForControllerApi->WaitForMatchingEmails");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            localVarRequestOptions.Data = matchOptions;

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForMatchingEmails";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<List<EmailPreview>>("/waitForMatchingEmails", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForMatchingEmails", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        public Email WaitForMatchingFirstEmail(Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = WaitForMatchingFirstEmailWithHttpInfo(inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        public mailslurp.Client.ApiResponse<Email> WaitForMatchingFirstEmailWithHttpInfo(Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0)
        {
            // verify the required parameter 'matchOptions' is set
            if (matchOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'matchOptions' when calling WaitForControllerApi->WaitForMatchingFirstEmail");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }
            localVarRequestOptions.Data = matchOptions;

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForMatchingFirstEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Email>("/waitForMatchingFirstEmail", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForMatchingFirstEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        public async System.Threading.Tasks.Task<Email> WaitForMatchingFirstEmailAsync(Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = await WaitForMatchingFirstEmailWithHttpInfoAsync(inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Email>> WaitForMatchingFirstEmailWithHttpInfoAsync(Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'matchOptions' is set
            if (matchOptions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'matchOptions' when calling WaitForControllerApi->WaitForMatchingFirstEmail");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }
            localVarRequestOptions.Data = matchOptions;

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForMatchingFirstEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Email>("/waitForMatchingFirstEmail", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForMatchingFirstEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur. If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Email</returns>
        public Email WaitForNthEmail(Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = WaitForNthEmailWithHttpInfo(inboxId, index, timeout, unreadOnly, since, before, sort, delay);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur. If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Email</returns>
        public mailslurp.Client.ApiResponse<Email> WaitForNthEmailWithHttpInfo(Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0)
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }
            if (index != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "index", index));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForNthEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Email>("/waitForNthEmail", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForNthEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur. If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Email</returns>
        public async System.Threading.Tasks.Task<Email> WaitForNthEmailAsync(Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<Email> localVarResponse = await WaitForNthEmailWithHttpInfoAsync(inboxId, index, timeout, unreadOnly, since, before, sort, delay, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur. If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Email>> WaitForNthEmailWithHttpInfoAsync(Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }
            if (index != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "index", index));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForNthEmail";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Email>("/waitForNthEmail", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForNthEmail", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for an SMS message to match the provided filter conditions such as body contains keyword. Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSmsConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;SmsPreview&gt;</returns>
        public List<SmsPreview> WaitForSms(WaitForSmsConditions waitForSmsConditions, int operationIndex = 0)
        {
            mailslurp.Client.ApiResponse<List<SmsPreview>> localVarResponse = WaitForSmsWithHttpInfo(waitForSmsConditions);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for an SMS message to match the provided filter conditions such as body contains keyword. Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSmsConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;SmsPreview&gt;</returns>
        public mailslurp.Client.ApiResponse<List<SmsPreview>> WaitForSmsWithHttpInfo(WaitForSmsConditions waitForSmsConditions, int operationIndex = 0)
        {
            // verify the required parameter 'waitForSmsConditions' is set
            if (waitForSmsConditions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'waitForSmsConditions' when calling WaitForControllerApi->WaitForSms");
            }

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = waitForSmsConditions;

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForSms";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<SmsPreview>>("/waitForSms", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForSms", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for an SMS message to match the provided filter conditions such as body contains keyword. Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSmsConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;SmsPreview&gt;</returns>
        public async System.Threading.Tasks.Task<List<SmsPreview>> WaitForSmsAsync(WaitForSmsConditions waitForSmsConditions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            mailslurp.Client.ApiResponse<List<SmsPreview>> localVarResponse = await WaitForSmsWithHttpInfoAsync(waitForSmsConditions, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for an SMS message to match the provided filter conditions such as body contains keyword. Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForSmsConditions"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;SmsPreview&gt;)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<List<SmsPreview>>> WaitForSmsWithHttpInfoAsync(WaitForSmsConditions waitForSmsConditions, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'waitForSmsConditions' is set
            if (waitForSmsConditions == null)
            {
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'waitForSmsConditions' when calling WaitForControllerApi->WaitForSms");
            }


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = waitForSmsConditions;

            localVarRequestOptions.Operation = "WaitForControllerApi.WaitForSms";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (API_KEY) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<List<SmsPreview>>("/waitForSms", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForSms", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
