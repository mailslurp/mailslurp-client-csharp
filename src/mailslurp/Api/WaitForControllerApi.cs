/* 
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository 
 *
 * The version of the OpenAPI document: 67c9a1eda264be4cfe0bb2c76151f0aadf0862bc
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp.Portable;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IWaitForControllerApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Wait for conditions to be met
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions">Conditions to wait for (optional)</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        List<EmailPreview> WaitFor (WaitForConditions waitForConditions = default(WaitForConditions));

        /// <summary>
        /// Wait for conditions to be met
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions">Conditions to wait for (optional)</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        ApiResponse<List<EmailPreview>> WaitForWithHttpInfo (WaitForConditions waitForConditions = default(WaitForConditions));
        /// <summary>
        /// Wait for and return count number of emails 
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        List<EmailPreview> WaitForEmailCount (int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool));

        /// <summary>
        /// Wait for and return count number of emails 
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        ApiResponse<List<EmailPreview>> WaitForEmailCountWithHttpInfo (int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool));
        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods such as waitForNthEmail or waitForEmailCount.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Email</returns>
        Email WaitForLatestEmail (Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool));

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods such as waitForNthEmail or waitForEmailCount.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>ApiResponse of Email</returns>
        ApiResponse<Email> WaitForLatestEmailWithHttpInfo (Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool));
        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchOptions">matchOptions</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        List<EmailPreview> WaitForMatchingEmail (MatchOptions matchOptions, int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool));

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchOptions">matchOptions</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        ApiResponse<List<EmailPreview>> WaitForMatchingEmailWithHttpInfo (MatchOptions matchOptions, int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool));
        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Email</returns>
        Email WaitForNthEmail (Guid inboxId = default(Guid), int index = default(int), long timeout = default(long), bool unreadOnly = default(bool));

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>ApiResponse of Email</returns>
        ApiResponse<Email> WaitForNthEmailWithHttpInfo (Guid inboxId = default(Guid), int index = default(int), long timeout = default(long), bool unreadOnly = default(bool));
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Wait for conditions to be met
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions">Conditions to wait for (optional)</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        System.Threading.Tasks.Task<List<EmailPreview>> WaitForAsync (WaitForConditions waitForConditions = default(WaitForConditions));

        /// <summary>
        /// Wait for conditions to be met
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions">Conditions to wait for (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> WaitForAsyncWithHttpInfo (WaitForConditions waitForConditions = default(WaitForConditions));
        /// <summary>
        /// Wait for and return count number of emails 
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        System.Threading.Tasks.Task<List<EmailPreview>> WaitForEmailCountAsync (int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool));

        /// <summary>
        /// Wait for and return count number of emails 
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> WaitForEmailCountAsyncWithHttpInfo (int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool));
        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods such as waitForNthEmail or waitForEmailCount.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of Email</returns>
        System.Threading.Tasks.Task<Email> WaitForLatestEmailAsync (Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool));

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods such as waitForNthEmail or waitForEmailCount.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        System.Threading.Tasks.Task<ApiResponse<Email>> WaitForLatestEmailAsyncWithHttpInfo (Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool));
        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchOptions">matchOptions</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        System.Threading.Tasks.Task<List<EmailPreview>> WaitForMatchingEmailAsync (MatchOptions matchOptions, int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool));

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchOptions">matchOptions</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> WaitForMatchingEmailAsyncWithHttpInfo (MatchOptions matchOptions, int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool));
        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of Email</returns>
        System.Threading.Tasks.Task<Email> WaitForNthEmailAsync (Guid inboxId = default(Guid), int index = default(int), long timeout = default(long), bool unreadOnly = default(bool));

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        System.Threading.Tasks.Task<ApiResponse<Email>> WaitForNthEmailAsyncWithHttpInfo (Guid inboxId = default(Guid), int index = default(int), long timeout = default(long), bool unreadOnly = default(bool));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class WaitForControllerApi : IWaitForControllerApi
    {
        private mailslurp.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="WaitForControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public WaitForControllerApi(String basePath)
        {
            this.Configuration = new mailslurp.Client.Configuration { BasePath = basePath };

            ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WaitForControllerApi"/> class
        /// </summary>
        /// <returns></returns>
        public WaitForControllerApi()
        {
            this.Configuration = mailslurp.Client.Configuration.Default;

            ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WaitForControllerApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public WaitForControllerApi(mailslurp.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = mailslurp.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public mailslurp.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public mailslurp.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Wait for conditions to be met Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions">Conditions to wait for (optional)</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        public List<EmailPreview> WaitFor (WaitForConditions waitForConditions = default(WaitForConditions))
        {
             ApiResponse<List<EmailPreview>> localVarResponse = WaitForWithHttpInfo(waitForConditions);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for conditions to be met Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions">Conditions to wait for (optional)</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        public ApiResponse<List<EmailPreview>> WaitForWithHttpInfo (WaitForConditions waitForConditions = default(WaitForConditions))
        {

            var localVarPath = "./waitFor";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (waitForConditions != null && waitForConditions.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(waitForConditions); // http body (model) parameter
            }
            else
            {
                localVarPostBody = waitForConditions; // byte array
            }

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarHeaderParams["x-api-key"] = this.Configuration.GetApiKeyWithPrefix("x-api-key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("WaitFor", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<EmailPreview>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (List<EmailPreview>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<EmailPreview>)));
        }

        /// <summary>
        /// Wait for conditions to be met Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions">Conditions to wait for (optional)</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        public async System.Threading.Tasks.Task<List<EmailPreview>> WaitForAsync (WaitForConditions waitForConditions = default(WaitForConditions))
        {
             ApiResponse<List<EmailPreview>> localVarResponse = await WaitForAsyncWithHttpInfo(waitForConditions);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Wait for conditions to be met Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions">Conditions to wait for (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> WaitForAsyncWithHttpInfo (WaitForConditions waitForConditions = default(WaitForConditions))
        {

            var localVarPath = "./waitFor";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (waitForConditions != null && waitForConditions.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(waitForConditions); // http body (model) parameter
            }
            else
            {
                localVarPostBody = waitForConditions; // byte array
            }

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarHeaderParams["x-api-key"] = this.Configuration.GetApiKeyWithPrefix("x-api-key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("WaitFor", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<EmailPreview>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (List<EmailPreview>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<EmailPreview>)));
        }

        /// <summary>
        /// Wait for and return count number of emails  If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        public List<EmailPreview> WaitForEmailCount (int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool))
        {
             ApiResponse<List<EmailPreview>> localVarResponse = WaitForEmailCountWithHttpInfo(count, inboxId, timeout, unreadOnly);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for and return count number of emails  If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        public ApiResponse<List<EmailPreview>> WaitForEmailCountWithHttpInfo (int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool))
        {

            var localVarPath = "./waitForEmailCount";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (count != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "count", count)); // query parameter
            if (inboxId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inboxId", inboxId)); // query parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (unreadOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "unreadOnly", unreadOnly)); // query parameter

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarHeaderParams["x-api-key"] = this.Configuration.GetApiKeyWithPrefix("x-api-key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("WaitForEmailCount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<EmailPreview>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (List<EmailPreview>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<EmailPreview>)));
        }

        /// <summary>
        /// Wait for and return count number of emails  If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        public async System.Threading.Tasks.Task<List<EmailPreview>> WaitForEmailCountAsync (int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool))
        {
             ApiResponse<List<EmailPreview>> localVarResponse = await WaitForEmailCountAsyncWithHttpInfo(count, inboxId, timeout, unreadOnly);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Wait for and return count number of emails  If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> WaitForEmailCountAsyncWithHttpInfo (int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool))
        {

            var localVarPath = "./waitForEmailCount";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (count != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "count", count)); // query parameter
            if (inboxId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inboxId", inboxId)); // query parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (unreadOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "unreadOnly", unreadOnly)); // query parameter

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarHeaderParams["x-api-key"] = this.Configuration.GetApiKeyWithPrefix("x-api-key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("WaitForEmailCount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<EmailPreview>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (List<EmailPreview>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<EmailPreview>)));
        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods such as waitForNthEmail or waitForEmailCount.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Email</returns>
        public Email WaitForLatestEmail (Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool))
        {
             ApiResponse<Email> localVarResponse = WaitForLatestEmailWithHttpInfo(inboxId, timeout, unreadOnly);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods such as waitForNthEmail or waitForEmailCount.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>ApiResponse of Email</returns>
        public ApiResponse<Email> WaitForLatestEmailWithHttpInfo (Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool))
        {

            var localVarPath = "./waitForLatestEmail";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (inboxId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inboxId", inboxId)); // query parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (unreadOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "unreadOnly", unreadOnly)); // query parameter

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarHeaderParams["x-api-key"] = this.Configuration.GetApiKeyWithPrefix("x-api-key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("WaitForLatestEmail", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Email>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Email) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Email)));
        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods such as waitForNthEmail or waitForEmailCount.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of Email</returns>
        public async System.Threading.Tasks.Task<Email> WaitForLatestEmailAsync (Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool))
        {
             ApiResponse<Email> localVarResponse = await WaitForLatestEmailAsyncWithHttpInfo(inboxId, timeout, unreadOnly);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods such as waitForNthEmail or waitForEmailCount.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Email>> WaitForLatestEmailAsyncWithHttpInfo (Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool))
        {

            var localVarPath = "./waitForLatestEmail";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (inboxId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inboxId", inboxId)); // query parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (unreadOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "unreadOnly", unreadOnly)); // query parameter

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarHeaderParams["x-api-key"] = this.Configuration.GetApiKeyWithPrefix("x-api-key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("WaitForLatestEmail", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Email>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Email) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Email)));
        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchOptions">matchOptions</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        public List<EmailPreview> WaitForMatchingEmail (MatchOptions matchOptions, int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool))
        {
             ApiResponse<List<EmailPreview>> localVarResponse = WaitForMatchingEmailWithHttpInfo(matchOptions, count, inboxId, timeout, unreadOnly);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchOptions">matchOptions</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        public ApiResponse<List<EmailPreview>> WaitForMatchingEmailWithHttpInfo (MatchOptions matchOptions, int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool))
        {
            // verify the required parameter 'matchOptions' is set
            if (matchOptions == null)
                throw new ApiException(400, "Missing required parameter 'matchOptions' when calling WaitForControllerApi->WaitForMatchingEmail");

            var localVarPath = "./waitForMatchingEmails";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (count != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "count", count)); // query parameter
            if (inboxId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inboxId", inboxId)); // query parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (unreadOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "unreadOnly", unreadOnly)); // query parameter
            if (matchOptions != null && matchOptions.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(matchOptions); // http body (model) parameter
            }
            else
            {
                localVarPostBody = matchOptions; // byte array
            }

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarHeaderParams["x-api-key"] = this.Configuration.GetApiKeyWithPrefix("x-api-key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("WaitForMatchingEmail", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<EmailPreview>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (List<EmailPreview>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<EmailPreview>)));
        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchOptions">matchOptions</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        public async System.Threading.Tasks.Task<List<EmailPreview>> WaitForMatchingEmailAsync (MatchOptions matchOptions, int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool))
        {
             ApiResponse<List<EmailPreview>> localVarResponse = await WaitForMatchingEmailAsyncWithHttpInfo(matchOptions, count, inboxId, timeout, unreadOnly);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchOptions">matchOptions</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1 (optional)</param>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> WaitForMatchingEmailAsyncWithHttpInfo (MatchOptions matchOptions, int count = default(int), Guid inboxId = default(Guid), long timeout = default(long), bool unreadOnly = default(bool))
        {
            // verify the required parameter 'matchOptions' is set
            if (matchOptions == null)
                throw new ApiException(400, "Missing required parameter 'matchOptions' when calling WaitForControllerApi->WaitForMatchingEmail");

            var localVarPath = "./waitForMatchingEmails";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (count != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "count", count)); // query parameter
            if (inboxId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inboxId", inboxId)); // query parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (unreadOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "unreadOnly", unreadOnly)); // query parameter
            if (matchOptions != null && matchOptions.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(matchOptions); // http body (model) parameter
            }
            else
            {
                localVarPostBody = matchOptions; // byte array
            }

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarHeaderParams["x-api-key"] = this.Configuration.GetApiKeyWithPrefix("x-api-key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("WaitForMatchingEmail", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<EmailPreview>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (List<EmailPreview>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<EmailPreview>)));
        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Email</returns>
        public Email WaitForNthEmail (Guid inboxId = default(Guid), int index = default(int), long timeout = default(long), bool unreadOnly = default(bool))
        {
             ApiResponse<Email> localVarResponse = WaitForNthEmailWithHttpInfo(inboxId, index, timeout, unreadOnly);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>ApiResponse of Email</returns>
        public ApiResponse<Email> WaitForNthEmailWithHttpInfo (Guid inboxId = default(Guid), int index = default(int), long timeout = default(long), bool unreadOnly = default(bool))
        {

            var localVarPath = "./waitForNthEmail";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (inboxId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inboxId", inboxId)); // query parameter
            if (index != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "index", index)); // query parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (unreadOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "unreadOnly", unreadOnly)); // query parameter

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarHeaderParams["x-api-key"] = this.Configuration.GetApiKeyWithPrefix("x-api-key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("WaitForNthEmail", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Email>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Email) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Email)));
        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of Email</returns>
        public async System.Threading.Tasks.Task<Email> WaitForNthEmailAsync (Guid inboxId = default(Guid), int index = default(int), long timeout = default(long), bool unreadOnly = default(bool))
        {
             ApiResponse<Email> localVarResponse = await WaitForNthEmailAsyncWithHttpInfo(inboxId, index, timeout, unreadOnly);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Email>> WaitForNthEmailAsyncWithHttpInfo (Guid inboxId = default(Guid), int index = default(int), long timeout = default(long), bool unreadOnly = default(bool))
        {

            var localVarPath = "./waitForNthEmail";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (inboxId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inboxId", inboxId)); // query parameter
            if (index != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "index", index)); // query parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (unreadOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "unreadOnly", unreadOnly)); // query parameter

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarHeaderParams["x-api-key"] = this.Configuration.GetApiKeyWithPrefix("x-api-key");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("WaitForNthEmail", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Email>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => string.Join(",", x.Value)),
                (Email) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Email)));
        }

    }
}
