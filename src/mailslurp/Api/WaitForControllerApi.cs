/* 
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IWaitForControllerApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        List<EmailPreview> WaitFor (WaitForConditions waitForConditions);

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        ApiResponse<List<EmailPreview>> WaitForWithHttpInfo (WaitForConditions waitForConditions);
        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        List<EmailPreview> WaitForEmailCount (Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?));

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        ApiResponse<List<EmailPreview>> WaitForEmailCountWithHttpInfo (Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?));
        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Email</returns>
        Email WaitForLatestEmail (Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?));

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>ApiResponse of Email</returns>
        ApiResponse<Email> WaitForLatestEmailWithHttpInfo (Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?));
        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        List<EmailPreview> WaitForMatchingEmails (Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?));

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        ApiResponse<List<EmailPreview>> WaitForMatchingEmailsWithHttpInfo (Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?));
        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Email</returns>
        Email WaitForMatchingFirstEmail (Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?));

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>ApiResponse of Email</returns>
        ApiResponse<Email> WaitForMatchingFirstEmailWithHttpInfo (Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?));
        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur.
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Email</returns>
        Email WaitForNthEmail (Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?));

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur.
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>ApiResponse of Email</returns>
        ApiResponse<Email> WaitForNthEmailWithHttpInfo (Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IWaitForControllerApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        System.Threading.Tasks.Task<List<EmailPreview>> WaitForAsync (WaitForConditions waitForConditions);

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword.
        /// </summary>
        /// <remarks>
        /// Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> WaitForAsyncWithHttpInfo (WaitForConditions waitForConditions);
        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        System.Threading.Tasks.Task<List<EmailPreview>> WaitForEmailCountAsync (Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?));

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
        /// </summary>
        /// <remarks>
        /// If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> WaitForEmailCountAsyncWithHttpInfo (Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?));
        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of Email</returns>
        System.Threading.Tasks.Task<Email> WaitForLatestEmailAsync (Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?));

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive
        /// </summary>
        /// <remarks>
        /// Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        System.Threading.Tasks.Task<ApiResponse<Email>> WaitForLatestEmailAsyncWithHttpInfo (Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?));
        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        System.Threading.Tasks.Task<List<EmailPreview>> WaitForMatchingEmailsAsync (Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?));

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<EmailPreview>>> WaitForMatchingEmailsAsyncWithHttpInfo (Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?));
        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of Email</returns>
        System.Threading.Tasks.Task<Email> WaitForMatchingFirstEmailAsync (Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?));

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array
        /// </summary>
        /// <remarks>
        /// Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        System.Threading.Tasks.Task<ApiResponse<Email>> WaitForMatchingFirstEmailAsyncWithHttpInfo (Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?));
        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur.
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of Email</returns>
        System.Threading.Tasks.Task<Email> WaitForNthEmailAsync (Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?));

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur.
        /// </summary>
        /// <remarks>
        /// If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </remarks>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        System.Threading.Tasks.Task<ApiResponse<Email>> WaitForNthEmailAsyncWithHttpInfo (Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IWaitForControllerApi : IWaitForControllerApiSync, IWaitForControllerApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class WaitForControllerApi : IWaitForControllerApi
    {
        private mailslurp.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="WaitForControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public WaitForControllerApi() : this((string) null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WaitForControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public WaitForControllerApi(String basePath)
        {
            this.Configuration = mailslurp.Client.Configuration.MergeConfigurations(
                mailslurp.Client.GlobalConfiguration.Instance,
                new mailslurp.Client.Configuration { BasePath = basePath }
            );
            this.Client = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WaitForControllerApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public WaitForControllerApi(mailslurp.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = mailslurp.Client.Configuration.MergeConfigurations(
                mailslurp.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new mailslurp.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WaitForControllerApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public WaitForControllerApi(mailslurp.Client.ISynchronousClient client,mailslurp.Client.IAsynchronousClient asyncClient, mailslurp.Client.IReadableConfiguration configuration)
        {
            if(client == null) throw new ArgumentNullException("client");
            if(asyncClient == null) throw new ArgumentNullException("asyncClient");
            if(configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = mailslurp.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public mailslurp.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public mailslurp.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public mailslurp.Client.IReadableConfiguration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public mailslurp.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword. Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        public List<EmailPreview> WaitFor (WaitForConditions waitForConditions)
        {
             mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = WaitForWithHttpInfo(waitForConditions);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword. Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        public mailslurp.Client.ApiResponse< List<EmailPreview> > WaitForWithHttpInfo (WaitForConditions waitForConditions)
        {
            // verify the required parameter 'waitForConditions' is set
            if (waitForConditions == null)
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'waitForConditions' when calling WaitForControllerApi->WaitFor");

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = waitForConditions;

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post< List<EmailPreview> >("/waitFor", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitFor", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword. Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        public async System.Threading.Tasks.Task<List<EmailPreview>> WaitForAsync (WaitForConditions waitForConditions)
        {
             mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = await WaitForAsyncWithHttpInfo(waitForConditions);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Wait for an email to match the provided filter conditions such as subject contains keyword. Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waitForConditions"></param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<List<EmailPreview>>> WaitForAsyncWithHttpInfo (WaitForConditions waitForConditions)
        {
            // verify the required parameter 'waitForConditions' is set
            if (waitForConditions == null)
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'waitForConditions' when calling WaitForControllerApi->WaitFor");


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "*/*"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.Data = waitForConditions;

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<EmailPreview>>("/waitFor", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitFor", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        public List<EmailPreview> WaitForEmailCount (Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
             mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = WaitForEmailCountWithHttpInfo(inboxId, count, timeout, unreadOnly, before, since, sort, delay);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        public mailslurp.Client.ApiResponse< List<EmailPreview> > WaitForEmailCountWithHttpInfo (Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< List<EmailPreview> >("/waitForEmailCount", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForEmailCount", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        public async System.Threading.Tasks.Task<List<EmailPreview>> WaitForEmailCountAsync (Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
             mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = await WaitForEmailCountAsyncWithHttpInfo(inboxId, count, timeout, unreadOnly, before, since, sort, delay);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater that 1</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<List<EmailPreview>>> WaitForEmailCountAsyncWithHttpInfo (Guid inboxId, int count, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "*/*"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<EmailPreview>>("/waitForEmailCount", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForEmailCount", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Email</returns>
        public Email WaitForLatestEmail (Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
             mailslurp.Client.ApiResponse<Email> localVarResponse = WaitForLatestEmailWithHttpInfo(inboxId, timeout, unreadOnly, before, since, sort, delay);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>ApiResponse of Email</returns>
        public mailslurp.Client.ApiResponse< Email > WaitForLatestEmailWithHttpInfo (Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< Email >("/waitForLatestEmail", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForLatestEmail", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of Email</returns>
        public async System.Threading.Tasks.Task<Email> WaitForLatestEmailAsync (Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
             mailslurp.Client.ApiResponse<Email> localVarResponse = await WaitForLatestEmailAsyncWithHttpInfo(inboxId, timeout, unreadOnly, before, since, sort, delay);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Fetch inbox&#39;s latest email or if empty wait for an email to arrive Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only. (optional, default to false)</param>
        /// <param name="before">Filter for emails that were before after the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Email>> WaitForLatestEmailAsyncWithHttpInfo (Guid? inboxId = default(Guid?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "*/*"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Email>("/waitForLatestEmail", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForLatestEmail", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>List&lt;EmailPreview&gt;</returns>
        public List<EmailPreview> WaitForMatchingEmails (Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?))
        {
             mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = WaitForMatchingEmailsWithHttpInfo(inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>ApiResponse of List&lt;EmailPreview&gt;</returns>
        public mailslurp.Client.ApiResponse< List<EmailPreview> > WaitForMatchingEmailsWithHttpInfo (Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?))
        {
            // verify the required parameter 'matchOptions' is set
            if (matchOptions == null)
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'matchOptions' when calling WaitForControllerApi->WaitForMatchingEmails");

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            localVarRequestOptions.Data = matchOptions;

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post< List<EmailPreview> >("/waitForMatchingEmails", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForMatchingEmails", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of List&lt;EmailPreview&gt;</returns>
        public async System.Threading.Tasks.Task<List<EmailPreview>> WaitForMatchingEmailsAsync (Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?))
        {
             mailslurp.Client.ApiResponse<List<EmailPreview>> localVarResponse = await WaitForMatchingEmailsAsyncWithHttpInfo(inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Wait or return list of emails that match simple matching patterns Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are fetching emails from</param>
        /// <param name="count">Number of emails to wait for. Must be greater or equal to 1</param>
        /// <param name="matchOptions"></param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <returns>Task of ApiResponse (List&lt;EmailPreview&gt;)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<List<EmailPreview>>> WaitForMatchingEmailsAsyncWithHttpInfo (Guid inboxId, int count, MatchOptions matchOptions, DateTime? before = default(DateTime?), DateTime? since = default(DateTime?), string sort = default(string), long? delay = default(long?), long? timeout = default(long?), bool? unreadOnly = default(bool?))
        {
            // verify the required parameter 'matchOptions' is set
            if (matchOptions == null)
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'matchOptions' when calling WaitForControllerApi->WaitForMatchingEmails");


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "*/*"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            localVarRequestOptions.Data = matchOptions;

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<EmailPreview>>("/waitForMatchingEmails", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForMatchingEmails", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Email</returns>
        public Email WaitForMatchingFirstEmail (Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
             mailslurp.Client.ApiResponse<Email> localVarResponse = WaitForMatchingFirstEmailWithHttpInfo(inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>ApiResponse of Email</returns>
        public mailslurp.Client.ApiResponse< Email > WaitForMatchingFirstEmailWithHttpInfo (Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
            // verify the required parameter 'matchOptions' is set
            if (matchOptions == null)
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'matchOptions' when calling WaitForControllerApi->WaitForMatchingFirstEmail");

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }
            localVarRequestOptions.Data = matchOptions;

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post< Email >("/waitForMatchingFirstEmail", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForMatchingFirstEmail", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of Email</returns>
        public async System.Threading.Tasks.Task<Email> WaitForMatchingFirstEmailAsync (Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
             mailslurp.Client.ApiResponse<Email> localVarResponse = await WaitForMatchingFirstEmailAsyncWithHttpInfo(inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Wait for or return the first email that matches provided MatchOptions array Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox we are matching an email for</param>
        /// <param name="matchOptions"></param>
        /// <param name="timeout">Max milliseconds to wait (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Email>> WaitForMatchingFirstEmailAsyncWithHttpInfo (Guid inboxId, MatchOptions matchOptions, long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
            // verify the required parameter 'matchOptions' is set
            if (matchOptions == null)
                throw new mailslurp.Client.ApiException(400, "Missing required parameter 'matchOptions' when calling WaitForControllerApi->WaitForMatchingFirstEmail");


            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "*/*"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }
            localVarRequestOptions.Data = matchOptions;

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Email>("/waitForMatchingFirstEmail", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForMatchingFirstEmail", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur. If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Email</returns>
        public Email WaitForNthEmail (Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
             mailslurp.Client.ApiResponse<Email> localVarResponse = WaitForNthEmailWithHttpInfo(inboxId, index, timeout, unreadOnly, since, before, sort, delay);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur. If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>ApiResponse of Email</returns>
        public mailslurp.Client.ApiResponse< Email > WaitForNthEmailWithHttpInfo (Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "*/*"
            };

            var localVarContentType = mailslurp.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = mailslurp.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }
            if (index != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "index", index));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< Email >("/waitForNthEmail", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForNthEmail", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur. If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of Email</returns>
        public async System.Threading.Tasks.Task<Email> WaitForNthEmailAsync (Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {
             mailslurp.Client.ApiResponse<Email> localVarResponse = await WaitForNthEmailAsyncWithHttpInfo(inboxId, index, timeout, unreadOnly, since, before, sort, delay);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur. If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
        /// </summary>
        /// <exception cref="mailslurp.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inboxId">Id of the inbox you are fetching emails from (optional)</param>
        /// <param name="index">Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)</param>
        /// <param name="timeout">Max milliseconds to wait for the nth email if not already present (optional)</param>
        /// <param name="unreadOnly">Optional filter for unread only (optional, default to false)</param>
        /// <param name="since">Filter for emails that were received after the given timestamp (optional)</param>
        /// <param name="before">Filter for emails that were received before the given timestamp (optional)</param>
        /// <param name="sort">Sort direction (optional)</param>
        /// <param name="delay">Max milliseconds delay between calls (optional)</param>
        /// <returns>Task of ApiResponse (Email)</returns>
        public async System.Threading.Tasks.Task<mailslurp.Client.ApiResponse<Email>> WaitForNthEmailAsyncWithHttpInfo (Guid? inboxId = default(Guid?), int? index = default(int?), long? timeout = default(long?), bool? unreadOnly = default(bool?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), string sort = default(string), long? delay = default(long?))
        {

            mailslurp.Client.RequestOptions localVarRequestOptions = new mailslurp.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "*/*"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (inboxId != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "inboxId", inboxId));
            }
            if (index != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "index", index));
            }
            if (timeout != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "timeout", timeout));
            }
            if (unreadOnly != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "unreadOnly", unreadOnly));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (delay != null)
            {
                localVarRequestOptions.QueryParameters.Add(mailslurp.Client.ClientUtils.ParameterToMultiMap("", "delay", delay));
            }

            // authentication (API_KEY) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", this.Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Email>("/waitForNthEmail", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("WaitForNthEmail", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
