// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using mailslurp.Client;
using mailslurp.Model;

namespace mailslurp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IImapControllerApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ImapControllerApiEvents Events { get; }

        /// <summary>
        /// Fetch message in an inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="seqNum"></param>
        /// <param name="inboxId">Inbox ID to search (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerFetchApiResponse"/>&gt;</returns>
        Task<IImapServerFetchApiResponse> ImapServerFetchAsync(long seqNum, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Fetch message in an inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="seqNum"></param>
        /// <param name="inboxId">Inbox ID to search (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerFetchApiResponse"/>&gt;</returns>
        Task<IImapServerFetchApiResponse> ImapServerFetchOrDefaultAsync(long seqNum, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a message by email ID
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">Email ID to get</param>
        /// <param name="inboxId">Inbox ID to search (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerGetApiResponse"/>&gt;</returns>
        Task<IImapServerGetApiResponse> ImapServerGetAsync(Guid emailId, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a message by email ID
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="emailId">Email ID to get</param>
        /// <param name="inboxId">Inbox ID to search (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerGetApiResponse"/>&gt;</returns>
        Task<IImapServerGetApiResponse> ImapServerGetOrDefaultAsync(Guid emailId, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List messages in an inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="imapServerListOptions"></param>
        /// <param name="inboxId">Inbox ID to list (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerListApiResponse"/>&gt;</returns>
        Task<IImapServerListApiResponse> ImapServerListAsync(ImapServerListOptions imapServerListOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List messages in an inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="imapServerListOptions"></param>
        /// <param name="inboxId">Inbox ID to list (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerListApiResponse"/>&gt;</returns>
        Task<IImapServerListApiResponse> ImapServerListOrDefaultAsync(ImapServerListOptions imapServerListOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a new mailbox if possible
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Inbox email address to create</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerMailboxApiResponse"/>&gt;</returns>
        Task<IImapServerMailboxApiResponse> ImapServerMailboxAsync(string name, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a new mailbox if possible
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="name">Inbox email address to create</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerMailboxApiResponse"/>&gt;</returns>
        Task<IImapServerMailboxApiResponse> ImapServerMailboxOrDefaultAsync(string name, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search messages in an inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="imapServerSearchOptions"></param>
        /// <param name="inboxId">Inbox ID to search (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerSearchApiResponse"/>&gt;</returns>
        Task<IImapServerSearchApiResponse> ImapServerSearchAsync(ImapServerSearchOptions imapServerSearchOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search messages in an inbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="imapServerSearchOptions"></param>
        /// <param name="inboxId">Inbox ID to search (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerSearchApiResponse"/>&gt;</returns>
        Task<IImapServerSearchApiResponse> ImapServerSearchOrDefaultAsync(ImapServerSearchOptions imapServerSearchOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get status for mailbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="imapServerStatusOptions"></param>
        /// <param name="inboxId">Inbox ID to list (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerStatusApiResponse"/>&gt;</returns>
        Task<IImapServerStatusApiResponse> ImapServerStatusAsync(ImapServerStatusOptions imapServerStatusOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get status for mailbox
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="imapServerStatusOptions"></param>
        /// <param name="inboxId">Inbox ID to list (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerStatusApiResponse"/>&gt;</returns>
        Task<IImapServerStatusApiResponse> ImapServerStatusOrDefaultAsync(ImapServerStatusOptions imapServerStatusOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Update message flags
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="imapUpdateFlagsOptions"></param>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerUpdateFlagsApiResponse"/>&gt;</returns>
        Task<IImapServerUpdateFlagsApiResponse> ImapServerUpdateFlagsAsync(ImapUpdateFlagsOptions imapUpdateFlagsOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Update message flags
        /// </remarks>
        /// <param name="imapUpdateFlagsOptions"></param>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerUpdateFlagsApiResponse"/>&gt;</returns>
        Task<IImapServerUpdateFlagsApiResponse> ImapServerUpdateFlagsOrDefaultAsync(ImapUpdateFlagsOptions imapUpdateFlagsOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IImapServerFetchApiResponse"/>
    /// </summary>
    public interface IImapServerFetchApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ImapServerFetchResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IImapServerGetApiResponse"/>
    /// </summary>
    public interface IImapServerGetApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ImapServerGetResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IImapServerListApiResponse"/>
    /// </summary>
    public interface IImapServerListApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ImapServerListResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IImapServerMailboxApiResponse"/>
    /// </summary>
    public interface IImapServerMailboxApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ImapServerMailboxResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IImapServerSearchApiResponse"/>
    /// </summary>
    public interface IImapServerSearchApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ImapServerSearchResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IImapServerStatusApiResponse"/>
    /// </summary>
    public interface IImapServerStatusApiResponse : mailslurp.Client.IApiResponse, IOk<mailslurp.Model.ImapServerStatusResult>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IImapServerUpdateFlagsApiResponse"/>
    /// </summary>
    public interface IImapServerUpdateFlagsApiResponse : mailslurp.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ImapControllerApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnImapServerFetch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorImapServerFetch;

        internal void ExecuteOnImapServerFetch(ImapControllerApi.ImapServerFetchApiResponse apiResponse)
        {
            OnImapServerFetch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorImapServerFetch(Exception exception)
        {
            OnErrorImapServerFetch?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnImapServerGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorImapServerGet;

        internal void ExecuteOnImapServerGet(ImapControllerApi.ImapServerGetApiResponse apiResponse)
        {
            OnImapServerGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorImapServerGet(Exception exception)
        {
            OnErrorImapServerGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnImapServerList;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorImapServerList;

        internal void ExecuteOnImapServerList(ImapControllerApi.ImapServerListApiResponse apiResponse)
        {
            OnImapServerList?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorImapServerList(Exception exception)
        {
            OnErrorImapServerList?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnImapServerMailbox;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorImapServerMailbox;

        internal void ExecuteOnImapServerMailbox(ImapControllerApi.ImapServerMailboxApiResponse apiResponse)
        {
            OnImapServerMailbox?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorImapServerMailbox(Exception exception)
        {
            OnErrorImapServerMailbox?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnImapServerSearch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorImapServerSearch;

        internal void ExecuteOnImapServerSearch(ImapControllerApi.ImapServerSearchApiResponse apiResponse)
        {
            OnImapServerSearch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorImapServerSearch(Exception exception)
        {
            OnErrorImapServerSearch?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnImapServerStatus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorImapServerStatus;

        internal void ExecuteOnImapServerStatus(ImapControllerApi.ImapServerStatusApiResponse apiResponse)
        {
            OnImapServerStatus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorImapServerStatus(Exception exception)
        {
            OnErrorImapServerStatus?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnImapServerUpdateFlags;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorImapServerUpdateFlags;

        internal void ExecuteOnImapServerUpdateFlags(ImapControllerApi.ImapServerUpdateFlagsApiResponse apiResponse)
        {
            OnImapServerUpdateFlags?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorImapServerUpdateFlags(Exception exception)
        {
            OnErrorImapServerUpdateFlags?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ImapControllerApi : IImapControllerApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ImapControllerApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ImapControllerApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ImapControllerApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ImapControllerApi(ILogger<ImapControllerApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ImapControllerApiEvents imapControllerApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ImapControllerApi>();
            HttpClient = httpClient;
            Events = imapControllerApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatImapServerFetch(ref long seqNum, ref Option<Guid> inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="seqNum"></param>
        /// <param name="inboxId"></param>
        private void AfterImapServerFetchDefaultImplementation(IImapServerFetchApiResponse apiResponseLocalVar, long seqNum, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterImapServerFetch(ref suppressDefaultLog, apiResponseLocalVar, seqNum, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="seqNum"></param>
        /// <param name="inboxId"></param>
        partial void AfterImapServerFetch(ref bool suppressDefaultLog, IImapServerFetchApiResponse apiResponseLocalVar, long seqNum, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="seqNum"></param>
        /// <param name="inboxId"></param>
        private void OnErrorImapServerFetchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long seqNum, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorImapServerFetch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, seqNum, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="seqNum"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorImapServerFetch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long seqNum, Option<Guid> inboxId);

        /// <summary>
        /// Fetch message in an inbox 
        /// </summary>
        /// <param name="seqNum"></param>
        /// <param name="inboxId">Inbox ID to search (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerFetchApiResponse"/>&gt;</returns>
        public async Task<IImapServerFetchApiResponse> ImapServerFetchOrDefaultAsync(long seqNum, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ImapServerFetchAsync(seqNum, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Fetch message in an inbox 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="seqNum"></param>
        /// <param name="inboxId">Inbox ID to search (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerFetchApiResponse"/>&gt;</returns>
        public async Task<IImapServerFetchApiResponse> ImapServerFetchAsync(long seqNum, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatImapServerFetch(ref seqNum, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/imap/server/fetch"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/imap/server/fetch");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["seqNum"] = ClientUtils.ParameterToString(seqNum);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ImapServerFetchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ImapServerFetchApiResponse>();

                        ImapServerFetchApiResponse apiResponseLocalVar = new ImapServerFetchApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/imap/server/fetch", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterImapServerFetchDefaultImplementation(apiResponseLocalVar, seqNum, inboxId);

                        Events.ExecuteOnImapServerFetch(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorImapServerFetchDefaultImplementation(e, "/imap/server/fetch", uriBuilderLocalVar.Path, seqNum, inboxId);
                Events.ExecuteOnErrorImapServerFetch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ImapServerFetchApiResponse"/>
        /// </summary>
        public partial class ImapServerFetchApiResponse : mailslurp.Client.ApiResponse, IImapServerFetchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ImapServerFetchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ImapServerFetchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ImapServerFetchApiResponse(ILogger<ImapServerFetchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ImapServerFetchResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ImapServerFetchResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ImapServerFetchResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatImapServerGet(ref Guid emailId, ref Option<Guid> inboxId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="inboxId"></param>
        private void AfterImapServerGetDefaultImplementation(IImapServerGetApiResponse apiResponseLocalVar, Guid emailId, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterImapServerGet(ref suppressDefaultLog, apiResponseLocalVar, emailId, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="inboxId"></param>
        partial void AfterImapServerGet(ref bool suppressDefaultLog, IImapServerGetApiResponse apiResponseLocalVar, Guid emailId, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="inboxId"></param>
        private void OnErrorImapServerGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorImapServerGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emailId, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emailId"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorImapServerGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Guid emailId, Option<Guid> inboxId);

        /// <summary>
        /// Get a message by email ID 
        /// </summary>
        /// <param name="emailId">Email ID to get</param>
        /// <param name="inboxId">Inbox ID to search (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerGetApiResponse"/>&gt;</returns>
        public async Task<IImapServerGetApiResponse> ImapServerGetOrDefaultAsync(Guid emailId, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ImapServerGetAsync(emailId, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get a message by email ID 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emailId">Email ID to get</param>
        /// <param name="inboxId">Inbox ID to search (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerGetApiResponse"/>&gt;</returns>
        public async Task<IImapServerGetApiResponse> ImapServerGetAsync(Guid emailId, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatImapServerGet(ref emailId, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/imap/server/get"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/imap/server/get");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["emailId"] = ClientUtils.ParameterToString(emailId);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ImapServerGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ImapServerGetApiResponse>();

                        ImapServerGetApiResponse apiResponseLocalVar = new ImapServerGetApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/imap/server/get", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterImapServerGetDefaultImplementation(apiResponseLocalVar, emailId, inboxId);

                        Events.ExecuteOnImapServerGet(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorImapServerGetDefaultImplementation(e, "/imap/server/get", uriBuilderLocalVar.Path, emailId, inboxId);
                Events.ExecuteOnErrorImapServerGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ImapServerGetApiResponse"/>
        /// </summary>
        public partial class ImapServerGetApiResponse : mailslurp.Client.ApiResponse, IImapServerGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ImapServerGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ImapServerGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ImapServerGetApiResponse(ILogger<ImapServerGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ImapServerGetResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ImapServerGetResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ImapServerGetResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatImapServerList(ImapServerListOptions imapServerListOptions, ref Option<Guid> inboxId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="imapServerListOptions"></param>
        /// <returns></returns>
        private void ValidateImapServerList(ImapServerListOptions imapServerListOptions)
        {
            if (imapServerListOptions == null)
                throw new ArgumentNullException(nameof(imapServerListOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="imapServerListOptions"></param>
        /// <param name="inboxId"></param>
        private void AfterImapServerListDefaultImplementation(IImapServerListApiResponse apiResponseLocalVar, ImapServerListOptions imapServerListOptions, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterImapServerList(ref suppressDefaultLog, apiResponseLocalVar, imapServerListOptions, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="imapServerListOptions"></param>
        /// <param name="inboxId"></param>
        partial void AfterImapServerList(ref bool suppressDefaultLog, IImapServerListApiResponse apiResponseLocalVar, ImapServerListOptions imapServerListOptions, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="imapServerListOptions"></param>
        /// <param name="inboxId"></param>
        private void OnErrorImapServerListDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ImapServerListOptions imapServerListOptions, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorImapServerList(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, imapServerListOptions, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="imapServerListOptions"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorImapServerList(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ImapServerListOptions imapServerListOptions, Option<Guid> inboxId);

        /// <summary>
        /// List messages in an inbox 
        /// </summary>
        /// <param name="imapServerListOptions"></param>
        /// <param name="inboxId">Inbox ID to list (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerListApiResponse"/>&gt;</returns>
        public async Task<IImapServerListApiResponse> ImapServerListOrDefaultAsync(ImapServerListOptions imapServerListOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ImapServerListAsync(imapServerListOptions, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List messages in an inbox 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="imapServerListOptions"></param>
        /// <param name="inboxId">Inbox ID to list (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerListApiResponse"/>&gt;</returns>
        public async Task<IImapServerListApiResponse> ImapServerListAsync(ImapServerListOptions imapServerListOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateImapServerList(imapServerListOptions);

                FormatImapServerList(imapServerListOptions, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/imap/server/list"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/imap/server/list");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (imapServerListOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(imapServerListOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ImapServerListApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ImapServerListApiResponse>();

                        ImapServerListApiResponse apiResponseLocalVar = new ImapServerListApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/imap/server/list", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterImapServerListDefaultImplementation(apiResponseLocalVar, imapServerListOptions, inboxId);

                        Events.ExecuteOnImapServerList(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorImapServerListDefaultImplementation(e, "/imap/server/list", uriBuilderLocalVar.Path, imapServerListOptions, inboxId);
                Events.ExecuteOnErrorImapServerList(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ImapServerListApiResponse"/>
        /// </summary>
        public partial class ImapServerListApiResponse : mailslurp.Client.ApiResponse, IImapServerListApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ImapServerListApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ImapServerListApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ImapServerListApiResponse(ILogger<ImapServerListApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ImapServerListResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ImapServerListResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ImapServerListResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatImapServerMailbox(ref string name);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        private void ValidateImapServerMailbox(string name)
        {
            if (name == null)
                throw new ArgumentNullException(nameof(name));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        private void AfterImapServerMailboxDefaultImplementation(IImapServerMailboxApiResponse apiResponseLocalVar, string name)
        {
            bool suppressDefaultLog = false;
            AfterImapServerMailbox(ref suppressDefaultLog, apiResponseLocalVar, name);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        partial void AfterImapServerMailbox(ref bool suppressDefaultLog, IImapServerMailboxApiResponse apiResponseLocalVar, string name);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        private void OnErrorImapServerMailboxDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string name)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorImapServerMailbox(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, name);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        partial void OnErrorImapServerMailbox(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string name);

        /// <summary>
        /// Create a new mailbox if possible 
        /// </summary>
        /// <param name="name">Inbox email address to create</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerMailboxApiResponse"/>&gt;</returns>
        public async Task<IImapServerMailboxApiResponse> ImapServerMailboxOrDefaultAsync(string name, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ImapServerMailboxAsync(name, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a new mailbox if possible 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Inbox email address to create</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerMailboxApiResponse"/>&gt;</returns>
        public async Task<IImapServerMailboxApiResponse> ImapServerMailboxAsync(string name, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateImapServerMailbox(name);

                FormatImapServerMailbox(ref name);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/imap/server/mailbox"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/imap/server/mailbox");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ImapServerMailboxApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ImapServerMailboxApiResponse>();

                        ImapServerMailboxApiResponse apiResponseLocalVar = new ImapServerMailboxApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/imap/server/mailbox", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterImapServerMailboxDefaultImplementation(apiResponseLocalVar, name);

                        Events.ExecuteOnImapServerMailbox(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorImapServerMailboxDefaultImplementation(e, "/imap/server/mailbox", uriBuilderLocalVar.Path, name);
                Events.ExecuteOnErrorImapServerMailbox(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ImapServerMailboxApiResponse"/>
        /// </summary>
        public partial class ImapServerMailboxApiResponse : mailslurp.Client.ApiResponse, IImapServerMailboxApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ImapServerMailboxApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ImapServerMailboxApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ImapServerMailboxApiResponse(ILogger<ImapServerMailboxApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ImapServerMailboxResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ImapServerMailboxResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ImapServerMailboxResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatImapServerSearch(ImapServerSearchOptions imapServerSearchOptions, ref Option<Guid> inboxId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="imapServerSearchOptions"></param>
        /// <returns></returns>
        private void ValidateImapServerSearch(ImapServerSearchOptions imapServerSearchOptions)
        {
            if (imapServerSearchOptions == null)
                throw new ArgumentNullException(nameof(imapServerSearchOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="imapServerSearchOptions"></param>
        /// <param name="inboxId"></param>
        private void AfterImapServerSearchDefaultImplementation(IImapServerSearchApiResponse apiResponseLocalVar, ImapServerSearchOptions imapServerSearchOptions, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterImapServerSearch(ref suppressDefaultLog, apiResponseLocalVar, imapServerSearchOptions, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="imapServerSearchOptions"></param>
        /// <param name="inboxId"></param>
        partial void AfterImapServerSearch(ref bool suppressDefaultLog, IImapServerSearchApiResponse apiResponseLocalVar, ImapServerSearchOptions imapServerSearchOptions, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="imapServerSearchOptions"></param>
        /// <param name="inboxId"></param>
        private void OnErrorImapServerSearchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ImapServerSearchOptions imapServerSearchOptions, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorImapServerSearch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, imapServerSearchOptions, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="imapServerSearchOptions"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorImapServerSearch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ImapServerSearchOptions imapServerSearchOptions, Option<Guid> inboxId);

        /// <summary>
        /// Search messages in an inbox 
        /// </summary>
        /// <param name="imapServerSearchOptions"></param>
        /// <param name="inboxId">Inbox ID to search (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerSearchApiResponse"/>&gt;</returns>
        public async Task<IImapServerSearchApiResponse> ImapServerSearchOrDefaultAsync(ImapServerSearchOptions imapServerSearchOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ImapServerSearchAsync(imapServerSearchOptions, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search messages in an inbox 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="imapServerSearchOptions"></param>
        /// <param name="inboxId">Inbox ID to search (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerSearchApiResponse"/>&gt;</returns>
        public async Task<IImapServerSearchApiResponse> ImapServerSearchAsync(ImapServerSearchOptions imapServerSearchOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateImapServerSearch(imapServerSearchOptions);

                FormatImapServerSearch(imapServerSearchOptions, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/imap/server/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/imap/server/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (imapServerSearchOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(imapServerSearchOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ImapServerSearchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ImapServerSearchApiResponse>();

                        ImapServerSearchApiResponse apiResponseLocalVar = new ImapServerSearchApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/imap/server/search", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterImapServerSearchDefaultImplementation(apiResponseLocalVar, imapServerSearchOptions, inboxId);

                        Events.ExecuteOnImapServerSearch(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorImapServerSearchDefaultImplementation(e, "/imap/server/search", uriBuilderLocalVar.Path, imapServerSearchOptions, inboxId);
                Events.ExecuteOnErrorImapServerSearch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ImapServerSearchApiResponse"/>
        /// </summary>
        public partial class ImapServerSearchApiResponse : mailslurp.Client.ApiResponse, IImapServerSearchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ImapServerSearchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ImapServerSearchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ImapServerSearchApiResponse(ILogger<ImapServerSearchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ImapServerSearchResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ImapServerSearchResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ImapServerSearchResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatImapServerStatus(ImapServerStatusOptions imapServerStatusOptions, ref Option<Guid> inboxId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="imapServerStatusOptions"></param>
        /// <returns></returns>
        private void ValidateImapServerStatus(ImapServerStatusOptions imapServerStatusOptions)
        {
            if (imapServerStatusOptions == null)
                throw new ArgumentNullException(nameof(imapServerStatusOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="imapServerStatusOptions"></param>
        /// <param name="inboxId"></param>
        private void AfterImapServerStatusDefaultImplementation(IImapServerStatusApiResponse apiResponseLocalVar, ImapServerStatusOptions imapServerStatusOptions, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterImapServerStatus(ref suppressDefaultLog, apiResponseLocalVar, imapServerStatusOptions, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="imapServerStatusOptions"></param>
        /// <param name="inboxId"></param>
        partial void AfterImapServerStatus(ref bool suppressDefaultLog, IImapServerStatusApiResponse apiResponseLocalVar, ImapServerStatusOptions imapServerStatusOptions, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="imapServerStatusOptions"></param>
        /// <param name="inboxId"></param>
        private void OnErrorImapServerStatusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ImapServerStatusOptions imapServerStatusOptions, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorImapServerStatus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, imapServerStatusOptions, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="imapServerStatusOptions"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorImapServerStatus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ImapServerStatusOptions imapServerStatusOptions, Option<Guid> inboxId);

        /// <summary>
        /// Get status for mailbox 
        /// </summary>
        /// <param name="imapServerStatusOptions"></param>
        /// <param name="inboxId">Inbox ID to list (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerStatusApiResponse"/>&gt;</returns>
        public async Task<IImapServerStatusApiResponse> ImapServerStatusOrDefaultAsync(ImapServerStatusOptions imapServerStatusOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ImapServerStatusAsync(imapServerStatusOptions, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get status for mailbox 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="imapServerStatusOptions"></param>
        /// <param name="inboxId">Inbox ID to list (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerStatusApiResponse"/>&gt;</returns>
        public async Task<IImapServerStatusApiResponse> ImapServerStatusAsync(ImapServerStatusOptions imapServerStatusOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateImapServerStatus(imapServerStatusOptions);

                FormatImapServerStatus(imapServerStatusOptions, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/imap/server/status"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/imap/server/status");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (imapServerStatusOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(imapServerStatusOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ImapServerStatusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ImapServerStatusApiResponse>();

                        ImapServerStatusApiResponse apiResponseLocalVar = new ImapServerStatusApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/imap/server/status", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterImapServerStatusDefaultImplementation(apiResponseLocalVar, imapServerStatusOptions, inboxId);

                        Events.ExecuteOnImapServerStatus(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorImapServerStatusDefaultImplementation(e, "/imap/server/status", uriBuilderLocalVar.Path, imapServerStatusOptions, inboxId);
                Events.ExecuteOnErrorImapServerStatus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ImapServerStatusApiResponse"/>
        /// </summary>
        public partial class ImapServerStatusApiResponse : mailslurp.Client.ApiResponse, IImapServerStatusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ImapServerStatusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ImapServerStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ImapServerStatusApiResponse(ILogger<ImapServerStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public mailslurp.Model.ImapServerStatusResult Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<mailslurp.Model.ImapServerStatusResult>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out mailslurp.Model.ImapServerStatusResult result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatImapServerUpdateFlags(ImapUpdateFlagsOptions imapUpdateFlagsOptions, ref Option<Guid> inboxId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="imapUpdateFlagsOptions"></param>
        /// <returns></returns>
        private void ValidateImapServerUpdateFlags(ImapUpdateFlagsOptions imapUpdateFlagsOptions)
        {
            if (imapUpdateFlagsOptions == null)
                throw new ArgumentNullException(nameof(imapUpdateFlagsOptions));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="imapUpdateFlagsOptions"></param>
        /// <param name="inboxId"></param>
        private void AfterImapServerUpdateFlagsDefaultImplementation(IImapServerUpdateFlagsApiResponse apiResponseLocalVar, ImapUpdateFlagsOptions imapUpdateFlagsOptions, Option<Guid> inboxId)
        {
            bool suppressDefaultLog = false;
            AfterImapServerUpdateFlags(ref suppressDefaultLog, apiResponseLocalVar, imapUpdateFlagsOptions, inboxId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="imapUpdateFlagsOptions"></param>
        /// <param name="inboxId"></param>
        partial void AfterImapServerUpdateFlags(ref bool suppressDefaultLog, IImapServerUpdateFlagsApiResponse apiResponseLocalVar, ImapUpdateFlagsOptions imapUpdateFlagsOptions, Option<Guid> inboxId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="imapUpdateFlagsOptions"></param>
        /// <param name="inboxId"></param>
        private void OnErrorImapServerUpdateFlagsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ImapUpdateFlagsOptions imapUpdateFlagsOptions, Option<Guid> inboxId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorImapServerUpdateFlags(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, imapUpdateFlagsOptions, inboxId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="imapUpdateFlagsOptions"></param>
        /// <param name="inboxId"></param>
        partial void OnErrorImapServerUpdateFlags(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ImapUpdateFlagsOptions imapUpdateFlagsOptions, Option<Guid> inboxId);

        /// <summary>
        ///  Update message flags
        /// </summary>
        /// <param name="imapUpdateFlagsOptions"></param>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerUpdateFlagsApiResponse"/>&gt;</returns>
        public async Task<IImapServerUpdateFlagsApiResponse> ImapServerUpdateFlagsOrDefaultAsync(ImapUpdateFlagsOptions imapUpdateFlagsOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ImapServerUpdateFlagsAsync(imapUpdateFlagsOptions, inboxId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        ///  Update message flags
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="imapUpdateFlagsOptions"></param>
        /// <param name="inboxId"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IImapServerUpdateFlagsApiResponse"/>&gt;</returns>
        public async Task<IImapServerUpdateFlagsApiResponse> ImapServerUpdateFlagsAsync(ImapUpdateFlagsOptions imapUpdateFlagsOptions, Option<Guid> inboxId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateImapServerUpdateFlags(imapUpdateFlagsOptions);

                FormatImapServerUpdateFlags(imapUpdateFlagsOptions, ref inboxId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/imap/server/update-flags"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/imap/server/update-flags");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (inboxId.IsSet)
                        parseQueryStringLocalVar["inboxId"] = ClientUtils.ParameterToString(inboxId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.Content = (imapUpdateFlagsOptions as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(imapUpdateFlagsOptions, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("x-api-key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<ImapServerUpdateFlagsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ImapServerUpdateFlagsApiResponse>();

                        ImapServerUpdateFlagsApiResponse apiResponseLocalVar = new ImapServerUpdateFlagsApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/imap/server/update-flags", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterImapServerUpdateFlagsDefaultImplementation(apiResponseLocalVar, imapUpdateFlagsOptions, inboxId);

                        Events.ExecuteOnImapServerUpdateFlags(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorImapServerUpdateFlagsDefaultImplementation(e, "/imap/server/update-flags", uriBuilderLocalVar.Path, imapUpdateFlagsOptions, inboxId);
                Events.ExecuteOnErrorImapServerUpdateFlags(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ImapServerUpdateFlagsApiResponse"/>
        /// </summary>
        public partial class ImapServerUpdateFlagsApiResponse : mailslurp.Client.ApiResponse, IImapServerUpdateFlagsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ImapServerUpdateFlagsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ImapServerUpdateFlagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ImapServerUpdateFlagsApiResponse(ILogger<ImapServerUpdateFlagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
