// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using mailslurp.Client;

namespace mailslurp.Model
{
    /// <summary>
    /// JSON output schema for structured content repsonses. This schema dictates the format that an AI should use when responding to your instructions.
    /// </summary>
    public partial class StructuredOutputSchema : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StructuredOutputSchema" /> class.
        /// </summary>
        /// <param name="anyOf">anyOf</param>
        /// <param name="default">default</param>
        /// <param name="description">Provide a description of the schema to help the AI understand the schema.</param>
        /// <param name="enum">When using type string and format enum pass a collection of enum values here.</param>
        /// <param name="example">example</param>
        /// <param name="format">Format for string types. Can be null, date-time or enum.</param>
        /// <param name="items">items</param>
        /// <param name="maxItems">maxItems</param>
        /// <param name="minItems">minItems</param>
        /// <param name="maxLength">maxLength</param>
        /// <param name="minLength">minLength</param>
        /// <param name="pattern">pattern</param>
        /// <param name="properties">Properties of an OBJECT schema. These are key value pairs where the key is the property name and the value is the schema for that property.</param>
        /// <param name="propertyOrdering">Pass an array of property names to specify the order of properties in the generated JSON object if required.</param>
        /// <param name="required">required</param>
        /// <param name="maxProperties">maxProperties</param>
        /// <param name="minProperties">minProperties</param>
        /// <param name="maximum">maximum</param>
        /// <param name="minimum">minimum</param>
        /// <param name="nullable">nullable</param>
        /// <param name="title">title</param>
        /// <param name="type">Primitive JSON schema types with a fallback CUSTOM for unknown values.</param>
        [JsonConstructor]
        public StructuredOutputSchema(Option<List<StructuredOutputSchema>> anyOf = default, Option<Object> @default = default, Option<string> description = default, Option<List<string>> @enum = default, Option<Object> example = default, Option<string> format = default, Option<StructuredOutputSchema> items = default, Option<long?> maxItems = default, Option<long?> minItems = default, Option<long?> maxLength = default, Option<long?> minLength = default, Option<string> pattern = default, Option<Dictionary<string, StructuredOutputSchema>> properties = default, Option<List<string>> propertyOrdering = default, Option<List<string>> required = default, Option<long?> maxProperties = default, Option<long?> minProperties = default, Option<decimal?> maximum = default, Option<decimal?> minimum = default, Option<bool?> nullable = default, Option<string> title = default, Option<TypeEnum?> type = default)
        {
            AnyOfOption = anyOf;
            DefaultOption = @default;
            DescriptionOption = description;
            EnumOption = @enum;
            ExampleOption = example;
            FormatOption = format;
            ItemsOption = items;
            MaxItemsOption = maxItems;
            MinItemsOption = minItems;
            MaxLengthOption = maxLength;
            MinLengthOption = minLength;
            PatternOption = pattern;
            PropertiesOption = properties;
            PropertyOrderingOption = propertyOrdering;
            RequiredOption = required;
            MaxPropertiesOption = maxProperties;
            MinPropertiesOption = minProperties;
            MaximumOption = maximum;
            MinimumOption = minimum;
            NullableOption = nullable;
            TitleOption = title;
            TypeOption = type;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Primitive JSON schema types with a fallback CUSTOM for unknown values.
        /// </summary>
        /// <value>Primitive JSON schema types with a fallback CUSTOM for unknown values.</value>
        public enum TypeEnum
        {
            /// <summary>
            /// Enum String for value: string
            /// </summary>
            String = 1,

            /// <summary>
            /// Enum Number for value: number
            /// </summary>
            Number = 2,

            /// <summary>
            /// Enum Integer for value: integer
            /// </summary>
            Integer = 3,

            /// <summary>
            /// Enum Boolean for value: boolean
            /// </summary>
            Boolean = 4,

            /// <summary>
            /// Enum Object for value: object
            /// </summary>
            Object = 5,

            /// <summary>
            /// Enum Array for value: array
            /// </summary>
            Array = 6,

            /// <summary>
            /// Enum Null for value: null
            /// </summary>
            Null = 7
        }

        /// <summary>
        /// Returns a <see cref="TypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static TypeEnum TypeEnumFromString(string value)
        {
            if (value.Equals("string"))
                return TypeEnum.String;

            if (value.Equals("number"))
                return TypeEnum.Number;

            if (value.Equals("integer"))
                return TypeEnum.Integer;

            if (value.Equals("boolean"))
                return TypeEnum.Boolean;

            if (value.Equals("object"))
                return TypeEnum.Object;

            if (value.Equals("array"))
                return TypeEnum.Array;

            if (value.Equals("null"))
                return TypeEnum.Null;

            throw new NotImplementedException($"Could not convert value to type TypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="TypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static TypeEnum? TypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("string"))
                return TypeEnum.String;

            if (value.Equals("number"))
                return TypeEnum.Number;

            if (value.Equals("integer"))
                return TypeEnum.Integer;

            if (value.Equals("boolean"))
                return TypeEnum.Boolean;

            if (value.Equals("object"))
                return TypeEnum.Object;

            if (value.Equals("array"))
                return TypeEnum.Array;

            if (value.Equals("null"))
                return TypeEnum.Null;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="TypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string TypeEnumToJsonValue(TypeEnum? value)
        {
            if (value == null)
                return null;

            if (value == TypeEnum.String)
                return "string";

            if (value == TypeEnum.Number)
                return "number";

            if (value == TypeEnum.Integer)
                return "integer";

            if (value == TypeEnum.Boolean)
                return "boolean";

            if (value == TypeEnum.Object)
                return "object";

            if (value == TypeEnum.Array)
                return "array";

            if (value == TypeEnum.Null)
                return "null";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of Type
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<TypeEnum?> TypeOption { get; private set; }

        /// <summary>
        /// Primitive JSON schema types with a fallback CUSTOM for unknown values.
        /// </summary>
        /// <value>Primitive JSON schema types with a fallback CUSTOM for unknown values.</value>
        [JsonPropertyName("type")]
        public TypeEnum? Type { get { return this.TypeOption; } set { this.TypeOption = new Option<TypeEnum?>(value); } }

        /// <summary>
        /// Used to track the state of AnyOf
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<StructuredOutputSchema>> AnyOfOption { get; private set; }

        /// <summary>
        /// Gets or Sets AnyOf
        /// </summary>
        [JsonPropertyName("anyOf")]
        public List<StructuredOutputSchema> AnyOf { get { return this.AnyOfOption; } set { this.AnyOfOption = new Option<List<StructuredOutputSchema>>(value); } }

        /// <summary>
        /// Used to track the state of Default
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Object> DefaultOption { get; private set; }

        /// <summary>
        /// Gets or Sets Default
        /// </summary>
        [JsonPropertyName("default")]
        public Object Default { get { return this.DefaultOption; } set { this.DefaultOption = new Option<Object>(value); } }

        /// <summary>
        /// Used to track the state of Description
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> DescriptionOption { get; private set; }

        /// <summary>
        /// Provide a description of the schema to help the AI understand the schema.
        /// </summary>
        /// <value>Provide a description of the schema to help the AI understand the schema.</value>
        [JsonPropertyName("description")]
        public string Description { get { return this.DescriptionOption; } set { this.DescriptionOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of Enum
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>> EnumOption { get; private set; }

        /// <summary>
        /// When using type string and format enum pass a collection of enum values here.
        /// </summary>
        /// <value>When using type string and format enum pass a collection of enum values here.</value>
        [JsonPropertyName("enum")]
        public List<string> Enum { get { return this.EnumOption; } set { this.EnumOption = new Option<List<string>>(value); } }

        /// <summary>
        /// Used to track the state of Example
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Object> ExampleOption { get; private set; }

        /// <summary>
        /// Gets or Sets Example
        /// </summary>
        [JsonPropertyName("example")]
        public Object Example { get { return this.ExampleOption; } set { this.ExampleOption = new Option<Object>(value); } }

        /// <summary>
        /// Used to track the state of Format
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> FormatOption { get; private set; }

        /// <summary>
        /// Format for string types. Can be null, date-time or enum.
        /// </summary>
        /// <value>Format for string types. Can be null, date-time or enum.</value>
        [JsonPropertyName("format")]
        public string Format { get { return this.FormatOption; } set { this.FormatOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of Items
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<StructuredOutputSchema> ItemsOption { get; private set; }

        /// <summary>
        /// Gets or Sets Items
        /// </summary>
        [JsonPropertyName("items")]
        public StructuredOutputSchema Items { get { return this.ItemsOption; } set { this.ItemsOption = new Option<StructuredOutputSchema>(value); } }

        /// <summary>
        /// Used to track the state of MaxItems
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> MaxItemsOption { get; private set; }

        /// <summary>
        /// Gets or Sets MaxItems
        /// </summary>
        [JsonPropertyName("maxItems")]
        public long? MaxItems { get { return this.MaxItemsOption; } set { this.MaxItemsOption = new Option<long?>(value); } }

        /// <summary>
        /// Used to track the state of MinItems
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> MinItemsOption { get; private set; }

        /// <summary>
        /// Gets or Sets MinItems
        /// </summary>
        [JsonPropertyName("minItems")]
        public long? MinItems { get { return this.MinItemsOption; } set { this.MinItemsOption = new Option<long?>(value); } }

        /// <summary>
        /// Used to track the state of MaxLength
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> MaxLengthOption { get; private set; }

        /// <summary>
        /// Gets or Sets MaxLength
        /// </summary>
        [JsonPropertyName("maxLength")]
        public long? MaxLength { get { return this.MaxLengthOption; } set { this.MaxLengthOption = new Option<long?>(value); } }

        /// <summary>
        /// Used to track the state of MinLength
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> MinLengthOption { get; private set; }

        /// <summary>
        /// Gets or Sets MinLength
        /// </summary>
        [JsonPropertyName("minLength")]
        public long? MinLength { get { return this.MinLengthOption; } set { this.MinLengthOption = new Option<long?>(value); } }

        /// <summary>
        /// Used to track the state of Pattern
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> PatternOption { get; private set; }

        /// <summary>
        /// Gets or Sets Pattern
        /// </summary>
        [JsonPropertyName("pattern")]
        public string Pattern { get { return this.PatternOption; } set { this.PatternOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of Properties
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, StructuredOutputSchema>> PropertiesOption { get; private set; }

        /// <summary>
        /// Properties of an OBJECT schema. These are key value pairs where the key is the property name and the value is the schema for that property.
        /// </summary>
        /// <value>Properties of an OBJECT schema. These are key value pairs where the key is the property name and the value is the schema for that property.</value>
        [JsonPropertyName("properties")]
        public Dictionary<string, StructuredOutputSchema> Properties { get { return this.PropertiesOption; } set { this.PropertiesOption = new Option<Dictionary<string, StructuredOutputSchema>>(value); } }

        /// <summary>
        /// Used to track the state of PropertyOrdering
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>> PropertyOrderingOption { get; private set; }

        /// <summary>
        /// Pass an array of property names to specify the order of properties in the generated JSON object if required.
        /// </summary>
        /// <value>Pass an array of property names to specify the order of properties in the generated JSON object if required.</value>
        [JsonPropertyName("propertyOrdering")]
        public List<string> PropertyOrdering { get { return this.PropertyOrderingOption; } set { this.PropertyOrderingOption = new Option<List<string>>(value); } }

        /// <summary>
        /// Used to track the state of Required
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>> RequiredOption { get; private set; }

        /// <summary>
        /// Gets or Sets Required
        /// </summary>
        [JsonPropertyName("required")]
        public List<string> Required { get { return this.RequiredOption; } set { this.RequiredOption = new Option<List<string>>(value); } }

        /// <summary>
        /// Used to track the state of MaxProperties
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> MaxPropertiesOption { get; private set; }

        /// <summary>
        /// Gets or Sets MaxProperties
        /// </summary>
        [JsonPropertyName("maxProperties")]
        public long? MaxProperties { get { return this.MaxPropertiesOption; } set { this.MaxPropertiesOption = new Option<long?>(value); } }

        /// <summary>
        /// Used to track the state of MinProperties
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> MinPropertiesOption { get; private set; }

        /// <summary>
        /// Gets or Sets MinProperties
        /// </summary>
        [JsonPropertyName("minProperties")]
        public long? MinProperties { get { return this.MinPropertiesOption; } set { this.MinPropertiesOption = new Option<long?>(value); } }

        /// <summary>
        /// Used to track the state of Maximum
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<decimal?> MaximumOption { get; private set; }

        /// <summary>
        /// Gets or Sets Maximum
        /// </summary>
        [JsonPropertyName("maximum")]
        public decimal? Maximum { get { return this.MaximumOption; } set { this.MaximumOption = new Option<decimal?>(value); } }

        /// <summary>
        /// Used to track the state of Minimum
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<decimal?> MinimumOption { get; private set; }

        /// <summary>
        /// Gets or Sets Minimum
        /// </summary>
        [JsonPropertyName("minimum")]
        public decimal? Minimum { get { return this.MinimumOption; } set { this.MinimumOption = new Option<decimal?>(value); } }

        /// <summary>
        /// Used to track the state of Nullable
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> NullableOption { get; private set; }

        /// <summary>
        /// Gets or Sets Nullable
        /// </summary>
        [JsonPropertyName("nullable")]
        public bool? Nullable { get { return this.NullableOption; } set { this.NullableOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of Title
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> TitleOption { get; private set; }

        /// <summary>
        /// Gets or Sets Title
        /// </summary>
        [JsonPropertyName("title")]
        public string Title { get { return this.TitleOption; } set { this.TitleOption = new Option<string>(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class StructuredOutputSchema {\n");
            sb.Append("  AnyOf: ").Append(AnyOf).Append("\n");
            sb.Append("  Default: ").Append(Default).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  Enum: ").Append(Enum).Append("\n");
            sb.Append("  Example: ").Append(Example).Append("\n");
            sb.Append("  Format: ").Append(Format).Append("\n");
            sb.Append("  Items: ").Append(Items).Append("\n");
            sb.Append("  MaxItems: ").Append(MaxItems).Append("\n");
            sb.Append("  MinItems: ").Append(MinItems).Append("\n");
            sb.Append("  MaxLength: ").Append(MaxLength).Append("\n");
            sb.Append("  MinLength: ").Append(MinLength).Append("\n");
            sb.Append("  Pattern: ").Append(Pattern).Append("\n");
            sb.Append("  Properties: ").Append(Properties).Append("\n");
            sb.Append("  PropertyOrdering: ").Append(PropertyOrdering).Append("\n");
            sb.Append("  Required: ").Append(Required).Append("\n");
            sb.Append("  MaxProperties: ").Append(MaxProperties).Append("\n");
            sb.Append("  MinProperties: ").Append(MinProperties).Append("\n");
            sb.Append("  Maximum: ").Append(Maximum).Append("\n");
            sb.Append("  Minimum: ").Append(Minimum).Append("\n");
            sb.Append("  Nullable: ").Append(Nullable).Append("\n");
            sb.Append("  Title: ").Append(Title).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // MaxItems (long) minimum
            if (this.MaxItemsOption.IsSet && this.MaxItemsOption.Value < (long)0)
            {
                yield return new ValidationResult("Invalid value for MaxItems, must be a value greater than or equal to 0.", new [] { "MaxItems" });
            }

            // MinItems (long) minimum
            if (this.MinItemsOption.IsSet && this.MinItemsOption.Value < (long)0)
            {
                yield return new ValidationResult("Invalid value for MinItems, must be a value greater than or equal to 0.", new [] { "MinItems" });
            }

            // MaxLength (long) minimum
            if (this.MaxLengthOption.IsSet && this.MaxLengthOption.Value < (long)0)
            {
                yield return new ValidationResult("Invalid value for MaxLength, must be a value greater than or equal to 0.", new [] { "MaxLength" });
            }

            // MinLength (long) minimum
            if (this.MinLengthOption.IsSet && this.MinLengthOption.Value < (long)0)
            {
                yield return new ValidationResult("Invalid value for MinLength, must be a value greater than or equal to 0.", new [] { "MinLength" });
            }

            // MaxProperties (long) minimum
            if (this.MaxPropertiesOption.IsSet && this.MaxPropertiesOption.Value < (long)0)
            {
                yield return new ValidationResult("Invalid value for MaxProperties, must be a value greater than or equal to 0.", new [] { "MaxProperties" });
            }

            // MinProperties (long) minimum
            if (this.MinPropertiesOption.IsSet && this.MinPropertiesOption.Value < (long)0)
            {
                yield return new ValidationResult("Invalid value for MinProperties, must be a value greater than or equal to 0.", new [] { "MinProperties" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="StructuredOutputSchema" />
    /// </summary>
    public class StructuredOutputSchemaJsonConverter : JsonConverter<StructuredOutputSchema>
    {
        /// <summary>
        /// Deserializes json to <see cref="StructuredOutputSchema" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override StructuredOutputSchema Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<List<StructuredOutputSchema>> anyOf = default;
            Option<Object> varDefault = default;
            Option<string> description = default;
            Option<List<string>> varEnum = default;
            Option<Object> example = default;
            Option<string> format = default;
            Option<StructuredOutputSchema> items = default;
            Option<long?> maxItems = default;
            Option<long?> minItems = default;
            Option<long?> maxLength = default;
            Option<long?> minLength = default;
            Option<string> pattern = default;
            Option<Dictionary<string, StructuredOutputSchema>> properties = default;
            Option<List<string>> propertyOrdering = default;
            Option<List<string>> required = default;
            Option<long?> maxProperties = default;
            Option<long?> minProperties = default;
            Option<decimal?> maximum = default;
            Option<decimal?> minimum = default;
            Option<bool?> nullable = default;
            Option<string> title = default;
            Option<StructuredOutputSchema.TypeEnum?> type = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "anyOf":
                            anyOf = new Option<List<StructuredOutputSchema>>(JsonSerializer.Deserialize<List<StructuredOutputSchema>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "default":
                            varDefault = new Option<Object>(JsonSerializer.Deserialize<Object>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "description":
                            description = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "enum":
                            varEnum = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "example":
                            example = new Option<Object>(JsonSerializer.Deserialize<Object>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "format":
                            format = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "items":
                            items = new Option<StructuredOutputSchema>(JsonSerializer.Deserialize<StructuredOutputSchema>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "maxItems":
                            maxItems = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "minItems":
                            minItems = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "maxLength":
                            maxLength = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "minLength":
                            minLength = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "pattern":
                            pattern = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "properties":
                            properties = new Option<Dictionary<string, StructuredOutputSchema>>(JsonSerializer.Deserialize<Dictionary<string, StructuredOutputSchema>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "propertyOrdering":
                            propertyOrdering = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "required":
                            required = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "maxProperties":
                            maxProperties = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "minProperties":
                            minProperties = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "maximum":
                            maximum = new Option<decimal?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (decimal?)null : utf8JsonReader.GetDecimal());
                            break;
                        case "minimum":
                            minimum = new Option<decimal?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (decimal?)null : utf8JsonReader.GetDecimal());
                            break;
                        case "nullable":
                            nullable = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "title":
                            title = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "type":
                            string typeRawValue = utf8JsonReader.GetString();
                            if (typeRawValue != null)
                                type = new Option<StructuredOutputSchema.TypeEnum?>(StructuredOutputSchema.TypeEnumFromStringOrDefault(typeRawValue));
                            break;
                        default:
                            break;
                    }
                }
            }

            if (items.IsSet && items.Value == null)
                throw new ArgumentNullException(nameof(items), "Property is not nullable for class StructuredOutputSchema.");

            return new StructuredOutputSchema(anyOf, varDefault, description, varEnum, example, format, items, maxItems, minItems, maxLength, minLength, pattern, properties, propertyOrdering, required, maxProperties, minProperties, maximum, minimum, nullable, title, type);
        }

        /// <summary>
        /// Serializes a <see cref="StructuredOutputSchema" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="structuredOutputSchema"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, StructuredOutputSchema structuredOutputSchema, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, structuredOutputSchema, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="StructuredOutputSchema" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="structuredOutputSchema"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, StructuredOutputSchema structuredOutputSchema, JsonSerializerOptions jsonSerializerOptions)
        {
            if (structuredOutputSchema.ItemsOption.IsSet && structuredOutputSchema.Items == null)
                throw new ArgumentNullException(nameof(structuredOutputSchema.Items), "Property is required for class StructuredOutputSchema.");

            if (structuredOutputSchema.AnyOfOption.IsSet)
                if (structuredOutputSchema.AnyOfOption.Value != null)
                {
                    writer.WritePropertyName("anyOf");
                    JsonSerializer.Serialize(writer, structuredOutputSchema.AnyOf, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("anyOf");
            if (structuredOutputSchema.DefaultOption.IsSet)
                if (structuredOutputSchema.DefaultOption.Value != null)
                {
                    writer.WritePropertyName("default");
                    JsonSerializer.Serialize(writer, structuredOutputSchema.Default, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("default");
            if (structuredOutputSchema.DescriptionOption.IsSet)
                if (structuredOutputSchema.DescriptionOption.Value != null)
                    writer.WriteString("description", structuredOutputSchema.Description);
                else
                    writer.WriteNull("description");

            if (structuredOutputSchema.EnumOption.IsSet)
                if (structuredOutputSchema.EnumOption.Value != null)
                {
                    writer.WritePropertyName("enum");
                    JsonSerializer.Serialize(writer, structuredOutputSchema.Enum, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("enum");
            if (structuredOutputSchema.ExampleOption.IsSet)
                if (structuredOutputSchema.ExampleOption.Value != null)
                {
                    writer.WritePropertyName("example");
                    JsonSerializer.Serialize(writer, structuredOutputSchema.Example, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("example");
            if (structuredOutputSchema.FormatOption.IsSet)
                if (structuredOutputSchema.FormatOption.Value != null)
                    writer.WriteString("format", structuredOutputSchema.Format);
                else
                    writer.WriteNull("format");

            if (structuredOutputSchema.ItemsOption.IsSet)
            {
                writer.WritePropertyName("items");
                JsonSerializer.Serialize(writer, structuredOutputSchema.Items, jsonSerializerOptions);
            }
            if (structuredOutputSchema.MaxItemsOption.IsSet)
                if (structuredOutputSchema.MaxItemsOption.Value != null)
                    writer.WriteNumber("maxItems", structuredOutputSchema.MaxItemsOption.Value.Value);
                else
                    writer.WriteNull("maxItems");

            if (structuredOutputSchema.MinItemsOption.IsSet)
                if (structuredOutputSchema.MinItemsOption.Value != null)
                    writer.WriteNumber("minItems", structuredOutputSchema.MinItemsOption.Value.Value);
                else
                    writer.WriteNull("minItems");

            if (structuredOutputSchema.MaxLengthOption.IsSet)
                if (structuredOutputSchema.MaxLengthOption.Value != null)
                    writer.WriteNumber("maxLength", structuredOutputSchema.MaxLengthOption.Value.Value);
                else
                    writer.WriteNull("maxLength");

            if (structuredOutputSchema.MinLengthOption.IsSet)
                if (structuredOutputSchema.MinLengthOption.Value != null)
                    writer.WriteNumber("minLength", structuredOutputSchema.MinLengthOption.Value.Value);
                else
                    writer.WriteNull("minLength");

            if (structuredOutputSchema.PatternOption.IsSet)
                if (structuredOutputSchema.PatternOption.Value != null)
                    writer.WriteString("pattern", structuredOutputSchema.Pattern);
                else
                    writer.WriteNull("pattern");

            if (structuredOutputSchema.PropertiesOption.IsSet)
                if (structuredOutputSchema.PropertiesOption.Value != null)
                {
                    writer.WritePropertyName("properties");
                    JsonSerializer.Serialize(writer, structuredOutputSchema.Properties, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("properties");
            if (structuredOutputSchema.PropertyOrderingOption.IsSet)
                if (structuredOutputSchema.PropertyOrderingOption.Value != null)
                {
                    writer.WritePropertyName("propertyOrdering");
                    JsonSerializer.Serialize(writer, structuredOutputSchema.PropertyOrdering, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("propertyOrdering");
            if (structuredOutputSchema.RequiredOption.IsSet)
                if (structuredOutputSchema.RequiredOption.Value != null)
                {
                    writer.WritePropertyName("required");
                    JsonSerializer.Serialize(writer, structuredOutputSchema.Required, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("required");
            if (structuredOutputSchema.MaxPropertiesOption.IsSet)
                if (structuredOutputSchema.MaxPropertiesOption.Value != null)
                    writer.WriteNumber("maxProperties", structuredOutputSchema.MaxPropertiesOption.Value.Value);
                else
                    writer.WriteNull("maxProperties");

            if (structuredOutputSchema.MinPropertiesOption.IsSet)
                if (structuredOutputSchema.MinPropertiesOption.Value != null)
                    writer.WriteNumber("minProperties", structuredOutputSchema.MinPropertiesOption.Value.Value);
                else
                    writer.WriteNull("minProperties");

            if (structuredOutputSchema.MaximumOption.IsSet)
                if (structuredOutputSchema.MaximumOption.Value != null)
                    writer.WriteNumber("maximum", structuredOutputSchema.MaximumOption.Value.Value);
                else
                    writer.WriteNull("maximum");

            if (structuredOutputSchema.MinimumOption.IsSet)
                if (structuredOutputSchema.MinimumOption.Value != null)
                    writer.WriteNumber("minimum", structuredOutputSchema.MinimumOption.Value.Value);
                else
                    writer.WriteNull("minimum");

            if (structuredOutputSchema.NullableOption.IsSet)
                if (structuredOutputSchema.NullableOption.Value != null)
                    writer.WriteBoolean("nullable", structuredOutputSchema.NullableOption.Value.Value);
                else
                    writer.WriteNull("nullable");

            if (structuredOutputSchema.TitleOption.IsSet)
                if (structuredOutputSchema.TitleOption.Value != null)
                    writer.WriteString("title", structuredOutputSchema.Title);
                else
                    writer.WriteNull("title");

            var typeRawValue = StructuredOutputSchema.TypeEnumToJsonValue(structuredOutputSchema.TypeOption.Value.Value);
            if (typeRawValue != null)
                writer.WriteString("type", typeRawValue);
            else
                writer.WriteNull("type");
        }
    }
}
