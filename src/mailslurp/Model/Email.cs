// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using mailslurp.Client;

namespace mailslurp.Model
{
    /// <summary>
    /// Email entity (also known as EmailDto). When an SMTP email message is received by MailSlurp it is parsed. The body and attachments are written to disk and the fields such as to, from, subject etc are stored in a database. The &#x60;body&#x60; contains the email content. If you want the original SMTP message see the &#x60;getRawEmail&#x60; endpoints. The attachments can be fetched using the AttachmentController
    /// </summary>
    public partial class Email : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Email" /> class.
        /// </summary>
        /// <param name="id">ID of the email entity</param>
        /// <param name="userId">ID of user that email belongs to</param>
        /// <param name="inboxId">ID of the inbox that received the email</param>
        /// <param name="to">List of &#x60;To&#x60; recipient email addresses that the email was addressed to. See recipients object for names.</param>
        /// <param name="createdAt">When was the email received by MailSlurp</param>
        /// <param name="updatedAt">When was the email last updated</param>
        /// <param name="read">Read flag. Has the email ever been viewed in the dashboard or fetched via the API with a hydrated body? If so the email is marked as read. Paginated results do not affect read status. Read status is different to email opened event as it depends on your own account accessing the email. Email opened is determined by tracking pixels sent to other uses if enable during sending. You can listened for both email read and email opened events using webhooks.</param>
        /// <param name="teamAccess">Can the email be accessed by organization team members</param>
        /// <param name="domainId">ID of the domain that received the email</param>
        /// <param name="from">Who the email was sent from. An email address - see fromName for the sender name.</param>
        /// <param name="sender">sender</param>
        /// <param name="recipients">recipients</param>
        /// <param name="replyTo">The &#x60;replyTo&#x60; field on the received email message</param>
        /// <param name="cc">List of &#x60;CC&#x60; recipients email addresses that the email was addressed to. See recipients object for names.</param>
        /// <param name="bcc">List of &#x60;BCC&#x60; recipients email addresses that the email was addressed to. See recipients object for names.</param>
        /// <param name="headers">Collection of SMTP headers attached to email</param>
        /// <param name="headersMap">Multi-value map of SMTP headers attached to email</param>
        /// <param name="attachments">List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension.</param>
        /// <param name="subject">The subject line of the email message as specified by SMTP subject header</param>
        /// <param name="body">The body of the email message as text parsed from the SMTP message body (does not include attachments). Fetch the raw content to access the SMTP message and use the attachments property to access attachments. The body is stored separately to the email entity so the body is not returned in paginated results only in full single email or wait requests.</param>
        /// <param name="bodyExcerpt">An excerpt of the body of the email message for quick preview. Takes HTML content part if exists falls back to TEXT content part if not</param>
        /// <param name="textExcerpt">An excerpt of the body of the email message for quick preview. Takes TEXT content part if exists</param>
        /// <param name="bodyMD5Hash">A hash signature of the email message using MD5. Useful for comparing emails without fetching full body.</param>
        /// <param name="isHTML">Is the email body content type HTML?</param>
        /// <param name="charset">Detected character set of the email body such as UTF-8</param>
        /// <param name="analysis">analysis</param>
        /// <param name="isXAmpHtml">Is the email body content type x-amp-html Amp4Email?</param>
        /// <param name="bodyPartContentTypes">A list of detected multipart mime message body part content types such as text/plain and text/html. Can be used with email bodyPart endpoints to fetch individual body parts.</param>
        /// <param name="externalId">UID used by external IMAP server to identify email</param>
        /// <param name="messageId">RFC 5322 Message-ID header value without angle brackets.</param>
        /// <param name="threadId">MailSlurp thread ID for email chain that enables lookup for In-Reply-To and References fields.</param>
        /// <param name="inReplyTo">Parsed value of In-Reply-To header. A Message-ID in a thread.</param>
        /// <param name="favourite">Is email favourited</param>
        /// <param name="sizeBytes">Size of raw email message in bytes</param>
        /// <param name="html">html</param>
        /// <param name="xampHtml">xampHtml</param>
        [JsonConstructor]
        public Email(Guid id, Guid userId, Guid inboxId, List<string> to, DateTime createdAt, DateTime updatedAt, bool read, bool teamAccess, Option<Guid?> domainId = default, Option<string> from = default, Option<Sender> sender = default, Option<EmailRecipients> recipients = default, Option<string> replyTo = default, Option<List<string>> cc = default, Option<List<string>> bcc = default, Option<Dictionary<string, string>> headers = default, Option<Dictionary<string, List<string>>> headersMap = default, Option<List<string>> attachments = default, Option<string> subject = default, Option<string> body = default, Option<string> bodyExcerpt = default, Option<string> textExcerpt = default, Option<string> bodyMD5Hash = default, Option<bool?> isHTML = default, Option<string> charset = default, Option<EmailAnalysis> analysis = default, Option<bool?> isXAmpHtml = default, Option<List<string>> bodyPartContentTypes = default, Option<string> externalId = default, Option<string> messageId = default, Option<Guid?> threadId = default, Option<string> inReplyTo = default, Option<bool?> favourite = default, Option<long?> sizeBytes = default, Option<bool?> html = default, Option<bool?> xampHtml = default)
        {
            Id = id;
            UserId = userId;
            InboxId = inboxId;
            To = to;
            CreatedAt = createdAt;
            UpdatedAt = updatedAt;
            Read = read;
            TeamAccess = teamAccess;
            DomainIdOption = domainId;
            FromOption = from;
            SenderOption = sender;
            RecipientsOption = recipients;
            ReplyToOption = replyTo;
            CcOption = cc;
            BccOption = bcc;
            HeadersOption = headers;
            HeadersMapOption = headersMap;
            AttachmentsOption = attachments;
            SubjectOption = subject;
            BodyOption = body;
            BodyExcerptOption = bodyExcerpt;
            TextExcerptOption = textExcerpt;
            BodyMD5HashOption = bodyMD5Hash;
            IsHTMLOption = isHTML;
            CharsetOption = charset;
            AnalysisOption = analysis;
            IsXAmpHtmlOption = isXAmpHtml;
            BodyPartContentTypesOption = bodyPartContentTypes;
            ExternalIdOption = externalId;
            MessageIdOption = messageId;
            ThreadIdOption = threadId;
            InReplyToOption = inReplyTo;
            FavouriteOption = favourite;
            SizeBytesOption = sizeBytes;
            HtmlOption = html;
            XampHtmlOption = xampHtml;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// ID of the email entity
        /// </summary>
        /// <value>ID of the email entity</value>
        [JsonPropertyName("id")]
        public Guid Id { get; set; }

        /// <summary>
        /// ID of user that email belongs to
        /// </summary>
        /// <value>ID of user that email belongs to</value>
        [JsonPropertyName("userId")]
        public Guid UserId { get; set; }

        /// <summary>
        /// ID of the inbox that received the email
        /// </summary>
        /// <value>ID of the inbox that received the email</value>
        [JsonPropertyName("inboxId")]
        public Guid InboxId { get; set; }

        /// <summary>
        /// List of &#x60;To&#x60; recipient email addresses that the email was addressed to. See recipients object for names.
        /// </summary>
        /// <value>List of &#x60;To&#x60; recipient email addresses that the email was addressed to. See recipients object for names.</value>
        [JsonPropertyName("to")]
        public List<string> To { get; set; }

        /// <summary>
        /// When was the email received by MailSlurp
        /// </summary>
        /// <value>When was the email received by MailSlurp</value>
        [JsonPropertyName("createdAt")]
        public DateTime CreatedAt { get; set; }

        /// <summary>
        /// When was the email last updated
        /// </summary>
        /// <value>When was the email last updated</value>
        [JsonPropertyName("updatedAt")]
        public DateTime UpdatedAt { get; set; }

        /// <summary>
        /// Read flag. Has the email ever been viewed in the dashboard or fetched via the API with a hydrated body? If so the email is marked as read. Paginated results do not affect read status. Read status is different to email opened event as it depends on your own account accessing the email. Email opened is determined by tracking pixels sent to other uses if enable during sending. You can listened for both email read and email opened events using webhooks.
        /// </summary>
        /// <value>Read flag. Has the email ever been viewed in the dashboard or fetched via the API with a hydrated body? If so the email is marked as read. Paginated results do not affect read status. Read status is different to email opened event as it depends on your own account accessing the email. Email opened is determined by tracking pixels sent to other uses if enable during sending. You can listened for both email read and email opened events using webhooks.</value>
        [JsonPropertyName("read")]
        public bool Read { get; set; }

        /// <summary>
        /// Can the email be accessed by organization team members
        /// </summary>
        /// <value>Can the email be accessed by organization team members</value>
        [JsonPropertyName("teamAccess")]
        public bool TeamAccess { get; set; }

        /// <summary>
        /// Used to track the state of DomainId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Guid?> DomainIdOption { get; private set; }

        /// <summary>
        /// ID of the domain that received the email
        /// </summary>
        /// <value>ID of the domain that received the email</value>
        [JsonPropertyName("domainId")]
        public Guid? DomainId { get { return this.DomainIdOption; } set { this.DomainIdOption = new Option<Guid?>(value); } }

        /// <summary>
        /// Used to track the state of From
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> FromOption { get; private set; }

        /// <summary>
        /// Who the email was sent from. An email address - see fromName for the sender name.
        /// </summary>
        /// <value>Who the email was sent from. An email address - see fromName for the sender name.</value>
        [JsonPropertyName("from")]
        public string From { get { return this.FromOption; } set { this.FromOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of Sender
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Sender> SenderOption { get; private set; }

        /// <summary>
        /// Gets or Sets Sender
        /// </summary>
        [JsonPropertyName("sender")]
        public Sender Sender { get { return this.SenderOption; } set { this.SenderOption = new Option<Sender>(value); } }

        /// <summary>
        /// Used to track the state of Recipients
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<EmailRecipients> RecipientsOption { get; private set; }

        /// <summary>
        /// Gets or Sets Recipients
        /// </summary>
        [JsonPropertyName("recipients")]
        public EmailRecipients Recipients { get { return this.RecipientsOption; } set { this.RecipientsOption = new Option<EmailRecipients>(value); } }

        /// <summary>
        /// Used to track the state of ReplyTo
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> ReplyToOption { get; private set; }

        /// <summary>
        /// The &#x60;replyTo&#x60; field on the received email message
        /// </summary>
        /// <value>The &#x60;replyTo&#x60; field on the received email message</value>
        [JsonPropertyName("replyTo")]
        public string ReplyTo { get { return this.ReplyToOption; } set { this.ReplyToOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of Cc
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>> CcOption { get; private set; }

        /// <summary>
        /// List of &#x60;CC&#x60; recipients email addresses that the email was addressed to. See recipients object for names.
        /// </summary>
        /// <value>List of &#x60;CC&#x60; recipients email addresses that the email was addressed to. See recipients object for names.</value>
        [JsonPropertyName("cc")]
        public List<string> Cc { get { return this.CcOption; } set { this.CcOption = new Option<List<string>>(value); } }

        /// <summary>
        /// Used to track the state of Bcc
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>> BccOption { get; private set; }

        /// <summary>
        /// List of &#x60;BCC&#x60; recipients email addresses that the email was addressed to. See recipients object for names.
        /// </summary>
        /// <value>List of &#x60;BCC&#x60; recipients email addresses that the email was addressed to. See recipients object for names.</value>
        [JsonPropertyName("bcc")]
        public List<string> Bcc { get { return this.BccOption; } set { this.BccOption = new Option<List<string>>(value); } }

        /// <summary>
        /// Used to track the state of Headers
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, string>> HeadersOption { get; private set; }

        /// <summary>
        /// Collection of SMTP headers attached to email
        /// </summary>
        /// <value>Collection of SMTP headers attached to email</value>
        [JsonPropertyName("headers")]
        [Obsolete]
        public Dictionary<string, string> Headers { get { return this.HeadersOption; } set { this.HeadersOption = new Option<Dictionary<string, string>>(value); } }

        /// <summary>
        /// Used to track the state of HeadersMap
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, List<string>>> HeadersMapOption { get; private set; }

        /// <summary>
        /// Multi-value map of SMTP headers attached to email
        /// </summary>
        /// <value>Multi-value map of SMTP headers attached to email</value>
        [JsonPropertyName("headersMap")]
        public Dictionary<string, List<string>> HeadersMap { get { return this.HeadersMapOption; } set { this.HeadersMapOption = new Option<Dictionary<string, List<string>>>(value); } }

        /// <summary>
        /// Used to track the state of Attachments
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>> AttachmentsOption { get; private set; }

        /// <summary>
        /// List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension.
        /// </summary>
        /// <value>List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension.</value>
        [JsonPropertyName("attachments")]
        public List<string> Attachments { get { return this.AttachmentsOption; } set { this.AttachmentsOption = new Option<List<string>>(value); } }

        /// <summary>
        /// Used to track the state of Subject
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> SubjectOption { get; private set; }

        /// <summary>
        /// The subject line of the email message as specified by SMTP subject header
        /// </summary>
        /// <value>The subject line of the email message as specified by SMTP subject header</value>
        [JsonPropertyName("subject")]
        public string Subject { get { return this.SubjectOption; } set { this.SubjectOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of Body
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> BodyOption { get; private set; }

        /// <summary>
        /// The body of the email message as text parsed from the SMTP message body (does not include attachments). Fetch the raw content to access the SMTP message and use the attachments property to access attachments. The body is stored separately to the email entity so the body is not returned in paginated results only in full single email or wait requests.
        /// </summary>
        /// <value>The body of the email message as text parsed from the SMTP message body (does not include attachments). Fetch the raw content to access the SMTP message and use the attachments property to access attachments. The body is stored separately to the email entity so the body is not returned in paginated results only in full single email or wait requests.</value>
        [JsonPropertyName("body")]
        public string Body { get { return this.BodyOption; } set { this.BodyOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of BodyExcerpt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> BodyExcerptOption { get; private set; }

        /// <summary>
        /// An excerpt of the body of the email message for quick preview. Takes HTML content part if exists falls back to TEXT content part if not
        /// </summary>
        /// <value>An excerpt of the body of the email message for quick preview. Takes HTML content part if exists falls back to TEXT content part if not</value>
        [JsonPropertyName("bodyExcerpt")]
        public string BodyExcerpt { get { return this.BodyExcerptOption; } set { this.BodyExcerptOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of TextExcerpt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> TextExcerptOption { get; private set; }

        /// <summary>
        /// An excerpt of the body of the email message for quick preview. Takes TEXT content part if exists
        /// </summary>
        /// <value>An excerpt of the body of the email message for quick preview. Takes TEXT content part if exists</value>
        [JsonPropertyName("textExcerpt")]
        public string TextExcerpt { get { return this.TextExcerptOption; } set { this.TextExcerptOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of BodyMD5Hash
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> BodyMD5HashOption { get; private set; }

        /// <summary>
        /// A hash signature of the email message using MD5. Useful for comparing emails without fetching full body.
        /// </summary>
        /// <value>A hash signature of the email message using MD5. Useful for comparing emails without fetching full body.</value>
        [JsonPropertyName("bodyMD5Hash")]
        public string BodyMD5Hash { get { return this.BodyMD5HashOption; } set { this.BodyMD5HashOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of IsHTML
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsHTMLOption { get; private set; }

        /// <summary>
        /// Is the email body content type HTML?
        /// </summary>
        /// <value>Is the email body content type HTML?</value>
        [JsonPropertyName("isHTML")]
        public bool? IsHTML { get { return this.IsHTMLOption; } set { this.IsHTMLOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of Charset
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> CharsetOption { get; private set; }

        /// <summary>
        /// Detected character set of the email body such as UTF-8
        /// </summary>
        /// <value>Detected character set of the email body such as UTF-8</value>
        [JsonPropertyName("charset")]
        public string Charset { get { return this.CharsetOption; } set { this.CharsetOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of Analysis
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<EmailAnalysis> AnalysisOption { get; private set; }

        /// <summary>
        /// Gets or Sets Analysis
        /// </summary>
        [JsonPropertyName("analysis")]
        public EmailAnalysis Analysis { get { return this.AnalysisOption; } set { this.AnalysisOption = new Option<EmailAnalysis>(value); } }

        /// <summary>
        /// Used to track the state of IsXAmpHtml
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsXAmpHtmlOption { get; private set; }

        /// <summary>
        /// Is the email body content type x-amp-html Amp4Email?
        /// </summary>
        /// <value>Is the email body content type x-amp-html Amp4Email?</value>
        [JsonPropertyName("isXAmpHtml")]
        public bool? IsXAmpHtml { get { return this.IsXAmpHtmlOption; } set { this.IsXAmpHtmlOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of BodyPartContentTypes
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>> BodyPartContentTypesOption { get; private set; }

        /// <summary>
        /// A list of detected multipart mime message body part content types such as text/plain and text/html. Can be used with email bodyPart endpoints to fetch individual body parts.
        /// </summary>
        /// <value>A list of detected multipart mime message body part content types such as text/plain and text/html. Can be used with email bodyPart endpoints to fetch individual body parts.</value>
        [JsonPropertyName("bodyPartContentTypes")]
        public List<string> BodyPartContentTypes { get { return this.BodyPartContentTypesOption; } set { this.BodyPartContentTypesOption = new Option<List<string>>(value); } }

        /// <summary>
        /// Used to track the state of ExternalId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> ExternalIdOption { get; private set; }

        /// <summary>
        /// UID used by external IMAP server to identify email
        /// </summary>
        /// <value>UID used by external IMAP server to identify email</value>
        [JsonPropertyName("externalId")]
        public string ExternalId { get { return this.ExternalIdOption; } set { this.ExternalIdOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of MessageId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> MessageIdOption { get; private set; }

        /// <summary>
        /// RFC 5322 Message-ID header value without angle brackets.
        /// </summary>
        /// <value>RFC 5322 Message-ID header value without angle brackets.</value>
        [JsonPropertyName("messageId")]
        public string MessageId { get { return this.MessageIdOption; } set { this.MessageIdOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of ThreadId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Guid?> ThreadIdOption { get; private set; }

        /// <summary>
        /// MailSlurp thread ID for email chain that enables lookup for In-Reply-To and References fields.
        /// </summary>
        /// <value>MailSlurp thread ID for email chain that enables lookup for In-Reply-To and References fields.</value>
        [JsonPropertyName("threadId")]
        public Guid? ThreadId { get { return this.ThreadIdOption; } set { this.ThreadIdOption = new Option<Guid?>(value); } }

        /// <summary>
        /// Used to track the state of InReplyTo
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> InReplyToOption { get; private set; }

        /// <summary>
        /// Parsed value of In-Reply-To header. A Message-ID in a thread.
        /// </summary>
        /// <value>Parsed value of In-Reply-To header. A Message-ID in a thread.</value>
        [JsonPropertyName("inReplyTo")]
        public string InReplyTo { get { return this.InReplyToOption; } set { this.InReplyToOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of Favourite
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> FavouriteOption { get; private set; }

        /// <summary>
        /// Is email favourited
        /// </summary>
        /// <value>Is email favourited</value>
        [JsonPropertyName("favourite")]
        public bool? Favourite { get { return this.FavouriteOption; } set { this.FavouriteOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of SizeBytes
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> SizeBytesOption { get; private set; }

        /// <summary>
        /// Size of raw email message in bytes
        /// </summary>
        /// <value>Size of raw email message in bytes</value>
        [JsonPropertyName("sizeBytes")]
        public long? SizeBytes { get { return this.SizeBytesOption; } set { this.SizeBytesOption = new Option<long?>(value); } }

        /// <summary>
        /// Used to track the state of Html
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> HtmlOption { get; private set; }

        /// <summary>
        /// Gets or Sets Html
        /// </summary>
        [JsonPropertyName("html")]
        public bool? Html { get { return this.HtmlOption; } set { this.HtmlOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of XampHtml
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> XampHtmlOption { get; private set; }

        /// <summary>
        /// Gets or Sets XampHtml
        /// </summary>
        [JsonPropertyName("xampHtml")]
        public bool? XampHtml { get { return this.XampHtmlOption; } set { this.XampHtmlOption = new Option<bool?>(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Email {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  UserId: ").Append(UserId).Append("\n");
            sb.Append("  InboxId: ").Append(InboxId).Append("\n");
            sb.Append("  To: ").Append(To).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
            sb.Append("  Read: ").Append(Read).Append("\n");
            sb.Append("  TeamAccess: ").Append(TeamAccess).Append("\n");
            sb.Append("  DomainId: ").Append(DomainId).Append("\n");
            sb.Append("  From: ").Append(From).Append("\n");
            sb.Append("  Sender: ").Append(Sender).Append("\n");
            sb.Append("  Recipients: ").Append(Recipients).Append("\n");
            sb.Append("  ReplyTo: ").Append(ReplyTo).Append("\n");
            sb.Append("  Cc: ").Append(Cc).Append("\n");
            sb.Append("  Bcc: ").Append(Bcc).Append("\n");
            sb.Append("  Headers: ").Append(Headers).Append("\n");
            sb.Append("  HeadersMap: ").Append(HeadersMap).Append("\n");
            sb.Append("  Attachments: ").Append(Attachments).Append("\n");
            sb.Append("  Subject: ").Append(Subject).Append("\n");
            sb.Append("  Body: ").Append(Body).Append("\n");
            sb.Append("  BodyExcerpt: ").Append(BodyExcerpt).Append("\n");
            sb.Append("  TextExcerpt: ").Append(TextExcerpt).Append("\n");
            sb.Append("  BodyMD5Hash: ").Append(BodyMD5Hash).Append("\n");
            sb.Append("  IsHTML: ").Append(IsHTML).Append("\n");
            sb.Append("  Charset: ").Append(Charset).Append("\n");
            sb.Append("  Analysis: ").Append(Analysis).Append("\n");
            sb.Append("  IsXAmpHtml: ").Append(IsXAmpHtml).Append("\n");
            sb.Append("  BodyPartContentTypes: ").Append(BodyPartContentTypes).Append("\n");
            sb.Append("  ExternalId: ").Append(ExternalId).Append("\n");
            sb.Append("  MessageId: ").Append(MessageId).Append("\n");
            sb.Append("  ThreadId: ").Append(ThreadId).Append("\n");
            sb.Append("  InReplyTo: ").Append(InReplyTo).Append("\n");
            sb.Append("  Favourite: ").Append(Favourite).Append("\n");
            sb.Append("  SizeBytes: ").Append(SizeBytes).Append("\n");
            sb.Append("  Html: ").Append(Html).Append("\n");
            sb.Append("  XampHtml: ").Append(XampHtml).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="Email" />
    /// </summary>
    public class EmailJsonConverter : JsonConverter<Email>
    {
        /// <summary>
        /// The format to use to serialize CreatedAt
        /// </summary>
        public static string CreatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize UpdatedAt
        /// </summary>
        public static string UpdatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="Email" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override Email Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<Guid?> id = default;
            Option<Guid?> userId = default;
            Option<Guid?> inboxId = default;
            Option<List<string>> to = default;
            Option<DateTime?> createdAt = default;
            Option<DateTime?> updatedAt = default;
            Option<bool?> read = default;
            Option<bool?> teamAccess = default;
            Option<Guid?> domainId = default;
            Option<string> from = default;
            Option<Sender> sender = default;
            Option<EmailRecipients> recipients = default;
            Option<string> replyTo = default;
            Option<List<string>> cc = default;
            Option<List<string>> bcc = default;
            Option<Dictionary<string, string>> headers = default;
            Option<Dictionary<string, List<string>>> headersMap = default;
            Option<List<string>> attachments = default;
            Option<string> subject = default;
            Option<string> body = default;
            Option<string> bodyExcerpt = default;
            Option<string> textExcerpt = default;
            Option<string> bodyMD5Hash = default;
            Option<bool?> isHTML = default;
            Option<string> charset = default;
            Option<EmailAnalysis> analysis = default;
            Option<bool?> isXAmpHtml = default;
            Option<List<string>> bodyPartContentTypes = default;
            Option<string> externalId = default;
            Option<string> messageId = default;
            Option<Guid?> threadId = default;
            Option<string> inReplyTo = default;
            Option<bool?> favourite = default;
            Option<long?> sizeBytes = default;
            Option<bool?> html = default;
            Option<bool?> xampHtml = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "id":
                            id = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "userId":
                            userId = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "inboxId":
                            inboxId = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "to":
                            to = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "createdAt":
                            createdAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "updatedAt":
                            updatedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "read":
                            read = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "teamAccess":
                            teamAccess = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "domainId":
                            domainId = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "from":
                            from = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "sender":
                            sender = new Option<Sender>(JsonSerializer.Deserialize<Sender>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "recipients":
                            recipients = new Option<EmailRecipients>(JsonSerializer.Deserialize<EmailRecipients>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "replyTo":
                            replyTo = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "cc":
                            cc = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "bcc":
                            bcc = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "headers":
                            headers = new Option<Dictionary<string, string>>(JsonSerializer.Deserialize<Dictionary<string, string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "headersMap":
                            headersMap = new Option<Dictionary<string, List<string>>>(JsonSerializer.Deserialize<Dictionary<string, List<string>>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "attachments":
                            attachments = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "subject":
                            subject = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "body":
                            body = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "bodyExcerpt":
                            bodyExcerpt = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "textExcerpt":
                            textExcerpt = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "bodyMD5Hash":
                            bodyMD5Hash = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "isHTML":
                            isHTML = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "charset":
                            charset = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "analysis":
                            analysis = new Option<EmailAnalysis>(JsonSerializer.Deserialize<EmailAnalysis>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "isXAmpHtml":
                            isXAmpHtml = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "bodyPartContentTypes":
                            bodyPartContentTypes = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "externalId":
                            externalId = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "messageId":
                            messageId = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "threadId":
                            threadId = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "inReplyTo":
                            inReplyTo = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "favourite":
                            favourite = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "sizeBytes":
                            sizeBytes = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "html":
                            html = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "xampHtml":
                            xampHtml = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class Email.", nameof(id));

            if (!userId.IsSet)
                throw new ArgumentException("Property is required for class Email.", nameof(userId));

            if (!inboxId.IsSet)
                throw new ArgumentException("Property is required for class Email.", nameof(inboxId));

            if (!to.IsSet)
                throw new ArgumentException("Property is required for class Email.", nameof(to));

            if (!createdAt.IsSet)
                throw new ArgumentException("Property is required for class Email.", nameof(createdAt));

            if (!updatedAt.IsSet)
                throw new ArgumentException("Property is required for class Email.", nameof(updatedAt));

            if (!read.IsSet)
                throw new ArgumentException("Property is required for class Email.", nameof(read));

            if (!teamAccess.IsSet)
                throw new ArgumentException("Property is required for class Email.", nameof(teamAccess));

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class Email.");

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId), "Property is not nullable for class Email.");

            if (inboxId.IsSet && inboxId.Value == null)
                throw new ArgumentNullException(nameof(inboxId), "Property is not nullable for class Email.");

            if (to.IsSet && to.Value == null)
                throw new ArgumentNullException(nameof(to), "Property is not nullable for class Email.");

            if (createdAt.IsSet && createdAt.Value == null)
                throw new ArgumentNullException(nameof(createdAt), "Property is not nullable for class Email.");

            if (updatedAt.IsSet && updatedAt.Value == null)
                throw new ArgumentNullException(nameof(updatedAt), "Property is not nullable for class Email.");

            if (read.IsSet && read.Value == null)
                throw new ArgumentNullException(nameof(read), "Property is not nullable for class Email.");

            if (teamAccess.IsSet && teamAccess.Value == null)
                throw new ArgumentNullException(nameof(teamAccess), "Property is not nullable for class Email.");

            if (html.IsSet && html.Value == null)
                throw new ArgumentNullException(nameof(html), "Property is not nullable for class Email.");

            if (xampHtml.IsSet && xampHtml.Value == null)
                throw new ArgumentNullException(nameof(xampHtml), "Property is not nullable for class Email.");

            return new Email(id.Value.Value, userId.Value.Value, inboxId.Value.Value, to.Value, createdAt.Value.Value, updatedAt.Value.Value, read.Value.Value, teamAccess.Value.Value, domainId, from, sender, recipients, replyTo, cc, bcc, headers, headersMap, attachments, subject, body, bodyExcerpt, textExcerpt, bodyMD5Hash, isHTML, charset, analysis, isXAmpHtml, bodyPartContentTypes, externalId, messageId, threadId, inReplyTo, favourite, sizeBytes, html, xampHtml);
        }

        /// <summary>
        /// Serializes a <see cref="Email" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="email"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, Email email, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, email, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="Email" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="email"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, Email email, JsonSerializerOptions jsonSerializerOptions)
        {
            if (email.To == null)
                throw new ArgumentNullException(nameof(email.To), "Property is required for class Email.");

            writer.WriteString("id", email.Id);

            writer.WriteString("userId", email.UserId);

            writer.WriteString("inboxId", email.InboxId);

            writer.WritePropertyName("to");
            JsonSerializer.Serialize(writer, email.To, jsonSerializerOptions);
            writer.WriteString("createdAt", email.CreatedAt.ToString(CreatedAtFormat));

            writer.WriteString("updatedAt", email.UpdatedAt.ToString(UpdatedAtFormat));

            writer.WriteBoolean("read", email.Read);

            writer.WriteBoolean("teamAccess", email.TeamAccess);

            if (email.DomainIdOption.IsSet)
                if (email.DomainIdOption.Value != null)
                    writer.WriteString("domainId", email.DomainIdOption.Value.Value);
                else
                    writer.WriteNull("domainId");

            if (email.FromOption.IsSet)
                if (email.FromOption.Value != null)
                    writer.WriteString("from", email.From);
                else
                    writer.WriteNull("from");

            if (email.SenderOption.IsSet)
                if (email.SenderOption.Value != null)
                {
                    writer.WritePropertyName("sender");
                    JsonSerializer.Serialize(writer, email.Sender, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("sender");
            if (email.RecipientsOption.IsSet)
                if (email.RecipientsOption.Value != null)
                {
                    writer.WritePropertyName("recipients");
                    JsonSerializer.Serialize(writer, email.Recipients, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("recipients");
            if (email.ReplyToOption.IsSet)
                if (email.ReplyToOption.Value != null)
                    writer.WriteString("replyTo", email.ReplyTo);
                else
                    writer.WriteNull("replyTo");

            if (email.CcOption.IsSet)
                if (email.CcOption.Value != null)
                {
                    writer.WritePropertyName("cc");
                    JsonSerializer.Serialize(writer, email.Cc, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("cc");
            if (email.BccOption.IsSet)
                if (email.BccOption.Value != null)
                {
                    writer.WritePropertyName("bcc");
                    JsonSerializer.Serialize(writer, email.Bcc, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("bcc");
            if (email.HeadersOption.IsSet)
                if (email.HeadersOption.Value != null)
                {
                    writer.WritePropertyName("headers");
                    JsonSerializer.Serialize(writer, email.Headers, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("headers");
            if (email.HeadersMapOption.IsSet)
                if (email.HeadersMapOption.Value != null)
                {
                    writer.WritePropertyName("headersMap");
                    JsonSerializer.Serialize(writer, email.HeadersMap, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("headersMap");
            if (email.AttachmentsOption.IsSet)
                if (email.AttachmentsOption.Value != null)
                {
                    writer.WritePropertyName("attachments");
                    JsonSerializer.Serialize(writer, email.Attachments, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("attachments");
            if (email.SubjectOption.IsSet)
                if (email.SubjectOption.Value != null)
                    writer.WriteString("subject", email.Subject);
                else
                    writer.WriteNull("subject");

            if (email.BodyOption.IsSet)
                if (email.BodyOption.Value != null)
                    writer.WriteString("body", email.Body);
                else
                    writer.WriteNull("body");

            if (email.BodyExcerptOption.IsSet)
                if (email.BodyExcerptOption.Value != null)
                    writer.WriteString("bodyExcerpt", email.BodyExcerpt);
                else
                    writer.WriteNull("bodyExcerpt");

            if (email.TextExcerptOption.IsSet)
                if (email.TextExcerptOption.Value != null)
                    writer.WriteString("textExcerpt", email.TextExcerpt);
                else
                    writer.WriteNull("textExcerpt");

            if (email.BodyMD5HashOption.IsSet)
                if (email.BodyMD5HashOption.Value != null)
                    writer.WriteString("bodyMD5Hash", email.BodyMD5Hash);
                else
                    writer.WriteNull("bodyMD5Hash");

            if (email.IsHTMLOption.IsSet)
                if (email.IsHTMLOption.Value != null)
                    writer.WriteBoolean("isHTML", email.IsHTMLOption.Value.Value);
                else
                    writer.WriteNull("isHTML");

            if (email.CharsetOption.IsSet)
                if (email.CharsetOption.Value != null)
                    writer.WriteString("charset", email.Charset);
                else
                    writer.WriteNull("charset");

            if (email.AnalysisOption.IsSet)
                if (email.AnalysisOption.Value != null)
                {
                    writer.WritePropertyName("analysis");
                    JsonSerializer.Serialize(writer, email.Analysis, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("analysis");
            if (email.IsXAmpHtmlOption.IsSet)
                if (email.IsXAmpHtmlOption.Value != null)
                    writer.WriteBoolean("isXAmpHtml", email.IsXAmpHtmlOption.Value.Value);
                else
                    writer.WriteNull("isXAmpHtml");

            if (email.BodyPartContentTypesOption.IsSet)
                if (email.BodyPartContentTypesOption.Value != null)
                {
                    writer.WritePropertyName("bodyPartContentTypes");
                    JsonSerializer.Serialize(writer, email.BodyPartContentTypes, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("bodyPartContentTypes");
            if (email.ExternalIdOption.IsSet)
                if (email.ExternalIdOption.Value != null)
                    writer.WriteString("externalId", email.ExternalId);
                else
                    writer.WriteNull("externalId");

            if (email.MessageIdOption.IsSet)
                if (email.MessageIdOption.Value != null)
                    writer.WriteString("messageId", email.MessageId);
                else
                    writer.WriteNull("messageId");

            if (email.ThreadIdOption.IsSet)
                if (email.ThreadIdOption.Value != null)
                    writer.WriteString("threadId", email.ThreadIdOption.Value.Value);
                else
                    writer.WriteNull("threadId");

            if (email.InReplyToOption.IsSet)
                if (email.InReplyToOption.Value != null)
                    writer.WriteString("inReplyTo", email.InReplyTo);
                else
                    writer.WriteNull("inReplyTo");

            if (email.FavouriteOption.IsSet)
                if (email.FavouriteOption.Value != null)
                    writer.WriteBoolean("favourite", email.FavouriteOption.Value.Value);
                else
                    writer.WriteNull("favourite");

            if (email.SizeBytesOption.IsSet)
                if (email.SizeBytesOption.Value != null)
                    writer.WriteNumber("sizeBytes", email.SizeBytesOption.Value.Value);
                else
                    writer.WriteNull("sizeBytes");

            if (email.HtmlOption.IsSet)
                writer.WriteBoolean("html", email.HtmlOption.Value.Value);

            if (email.XampHtmlOption.IsSet)
                writer.WriteBoolean("xampHtml", email.XampHtmlOption.Value.Value);
        }
    }
}
