/* 
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository 
 *
 * The version of the OpenAPI document: b386ac8a37a5e2f7ec170c77416dbd971223d596
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = mailslurp.Client.OpenAPIDateConverter;

namespace mailslurp.Model
{
    /// <summary>
    /// Create email alias options. Email aliases can be used to mask real email addresses behind an ID. You can also attach an inbox to an alias so that any email received by the inbox email address if forwarded to the alias email address.
    /// </summary>
    [DataContract]
    public partial class CreateOwnedAliasOptions :  IEquatable<CreateOwnedAliasOptions>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CreateOwnedAliasOptions" /> class.
        /// </summary>
        /// <param name="emailAddress">Email address to be hidden behind alias.</param>
        /// <param name="inboxId">Optional inbox ID to attach to alias. Emails received by this inbox will be forwarded to the alias email address.</param>
        /// <param name="name">Optional name for alias.</param>
        /// <param name="proxied">Optional proxied flag. When proxied is true alias will forward the incoming emails to the aliased email address via a proxy inbox. A new proxy is created for every new email thread. By replying to the proxy you can correspond with using your email alias without revealing your real email address..</param>
        public CreateOwnedAliasOptions(string emailAddress = default(string), Guid inboxId = default(Guid), string name = default(string), bool proxied = default(bool))
        {
            this.EmailAddress = emailAddress;
            this.InboxId = inboxId;
            this.Name = name;
            this.Proxied = proxied;
        }
        
        /// <summary>
        /// Email address to be hidden behind alias
        /// </summary>
        /// <value>Email address to be hidden behind alias</value>
        [DataMember(Name="emailAddress", EmitDefaultValue=false)]
        public string EmailAddress { get; set; }

        /// <summary>
        /// Optional inbox ID to attach to alias. Emails received by this inbox will be forwarded to the alias email address
        /// </summary>
        /// <value>Optional inbox ID to attach to alias. Emails received by this inbox will be forwarded to the alias email address</value>
        [DataMember(Name="inboxId", EmitDefaultValue=false)]
        public Guid InboxId { get; set; }

        /// <summary>
        /// Optional name for alias
        /// </summary>
        /// <value>Optional name for alias</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// Optional proxied flag. When proxied is true alias will forward the incoming emails to the aliased email address via a proxy inbox. A new proxy is created for every new email thread. By replying to the proxy you can correspond with using your email alias without revealing your real email address.
        /// </summary>
        /// <value>Optional proxied flag. When proxied is true alias will forward the incoming emails to the aliased email address via a proxy inbox. A new proxy is created for every new email thread. By replying to the proxy you can correspond with using your email alias without revealing your real email address.</value>
        [DataMember(Name="proxied", EmitDefaultValue=false)]
        public bool Proxied { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class CreateOwnedAliasOptions {\n");
            sb.Append("  EmailAddress: ").Append(EmailAddress).Append("\n");
            sb.Append("  InboxId: ").Append(InboxId).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Proxied: ").Append(Proxied).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CreateOwnedAliasOptions);
        }

        /// <summary>
        /// Returns true if CreateOwnedAliasOptions instances are equal
        /// </summary>
        /// <param name="input">Instance of CreateOwnedAliasOptions to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CreateOwnedAliasOptions input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.EmailAddress == input.EmailAddress ||
                    (this.EmailAddress != null &&
                    this.EmailAddress.Equals(input.EmailAddress))
                ) && 
                (
                    this.InboxId == input.InboxId ||
                    (this.InboxId != null &&
                    this.InboxId.Equals(input.InboxId))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Proxied == input.Proxied ||
                    this.Proxied.Equals(input.Proxied)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.EmailAddress != null)
                    hashCode = hashCode * 59 + this.EmailAddress.GetHashCode();
                if (this.InboxId != null)
                    hashCode = hashCode * 59 + this.InboxId.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                hashCode = hashCode * 59 + this.Proxied.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
