// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using mailslurp.Client;

namespace mailslurp.Model
{
    /// <summary>
    /// Domain plus verification records and status
    /// </summary>
    public partial class DomainDto : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DomainDto" /> class.
        /// </summary>
        /// <param name="id">id</param>
        /// <param name="userId">userId</param>
        /// <param name="domain">Custom domain name</param>
        /// <param name="verificationToken">Verification tokens</param>
        /// <param name="dkimTokens">Unique token DKIM tokens</param>
        /// <param name="hasDuplicateRecords">Whether the domain has duplicated required records. If true then see the domain in the dashboard app.</param>
        /// <param name="hasMissingRecords">Whether the domain has missing required records. If true then see the domain in the dashboard app.</param>
        /// <param name="isVerified">Whether domain has been verified or not. If the domain is not verified after 72 hours there is most likely an issue with the domains DNS records.</param>
        /// <param name="domainNameRecords">List of DNS domain name records (C, MX, TXT) etc that you must add to the DNS server associated with your domain provider.</param>
        /// <param name="createdAt">createdAt</param>
        /// <param name="updatedAt">updatedAt</param>
        /// <param name="domainType">Type of domain. Dictates type of inbox that can be created with domain. HTTP means inboxes are processed using SES while SMTP inboxes use a custom SMTP mail server. SMTP does not support sending so use HTTP for sending emails.</param>
        /// <param name="duplicateRecordsMessage">If the domain is duplicate records.</param>
        /// <param name="missingRecordsMessage">If the domain is missing records then show which pairs are missing.</param>
        /// <param name="catchAllInboxId">The optional catch all inbox that will receive emails sent to the domain that cannot be matched.</param>
        [JsonConstructor]
        public DomainDto(Guid id, Guid userId, string domain, string verificationToken, List<string> dkimTokens, bool hasDuplicateRecords, bool hasMissingRecords, bool isVerified, List<DomainNameRecord> domainNameRecords, DateTime createdAt, DateTime updatedAt, DomainTypeEnum domainType, Option<string> duplicateRecordsMessage = default, Option<string> missingRecordsMessage = default, Option<Guid?> catchAllInboxId = default)
        {
            Id = id;
            UserId = userId;
            Domain = domain;
            VerificationToken = verificationToken;
            DkimTokens = dkimTokens;
            HasDuplicateRecords = hasDuplicateRecords;
            HasMissingRecords = hasMissingRecords;
            IsVerified = isVerified;
            DomainNameRecords = domainNameRecords;
            CreatedAt = createdAt;
            UpdatedAt = updatedAt;
            DomainType = domainType;
            DuplicateRecordsMessageOption = duplicateRecordsMessage;
            MissingRecordsMessageOption = missingRecordsMessage;
            CatchAllInboxIdOption = catchAllInboxId;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Type of domain. Dictates type of inbox that can be created with domain. HTTP means inboxes are processed using SES while SMTP inboxes use a custom SMTP mail server. SMTP does not support sending so use HTTP for sending emails.
        /// </summary>
        /// <value>Type of domain. Dictates type of inbox that can be created with domain. HTTP means inboxes are processed using SES while SMTP inboxes use a custom SMTP mail server. SMTP does not support sending so use HTTP for sending emails.</value>
        public enum DomainTypeEnum
        {
            /// <summary>
            /// Enum HTTPINBOX for value: HTTP_INBOX
            /// </summary>
            HTTPINBOX = 1,

            /// <summary>
            /// Enum SMTPDOMAIN for value: SMTP_DOMAIN
            /// </summary>
            SMTPDOMAIN = 2
        }

        /// <summary>
        /// Returns a <see cref="DomainTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static DomainTypeEnum DomainTypeEnumFromString(string value)
        {
            if (value.Equals("HTTP_INBOX"))
                return DomainTypeEnum.HTTPINBOX;

            if (value.Equals("SMTP_DOMAIN"))
                return DomainTypeEnum.SMTPDOMAIN;

            throw new NotImplementedException($"Could not convert value to type DomainTypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="DomainTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static DomainTypeEnum? DomainTypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("HTTP_INBOX"))
                return DomainTypeEnum.HTTPINBOX;

            if (value.Equals("SMTP_DOMAIN"))
                return DomainTypeEnum.SMTPDOMAIN;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="DomainTypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string DomainTypeEnumToJsonValue(DomainTypeEnum value)
        {
            if (value == DomainTypeEnum.HTTPINBOX)
                return "HTTP_INBOX";

            if (value == DomainTypeEnum.SMTPDOMAIN)
                return "SMTP_DOMAIN";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Type of domain. Dictates type of inbox that can be created with domain. HTTP means inboxes are processed using SES while SMTP inboxes use a custom SMTP mail server. SMTP does not support sending so use HTTP for sending emails.
        /// </summary>
        /// <value>Type of domain. Dictates type of inbox that can be created with domain. HTTP means inboxes are processed using SES while SMTP inboxes use a custom SMTP mail server. SMTP does not support sending so use HTTP for sending emails.</value>
        [JsonPropertyName("domainType")]
        public DomainTypeEnum DomainType { get; set; }

        /// <summary>
        /// Gets or Sets Id
        /// </summary>
        [JsonPropertyName("id")]
        public Guid Id { get; set; }

        /// <summary>
        /// Gets or Sets UserId
        /// </summary>
        [JsonPropertyName("userId")]
        public Guid UserId { get; set; }

        /// <summary>
        /// Custom domain name
        /// </summary>
        /// <value>Custom domain name</value>
        [JsonPropertyName("domain")]
        public string Domain { get; set; }

        /// <summary>
        /// Verification tokens
        /// </summary>
        /// <value>Verification tokens</value>
        [JsonPropertyName("verificationToken")]
        public string VerificationToken { get; set; }

        /// <summary>
        /// Unique token DKIM tokens
        /// </summary>
        /// <value>Unique token DKIM tokens</value>
        [JsonPropertyName("dkimTokens")]
        public List<string> DkimTokens { get; set; }

        /// <summary>
        /// Whether the domain has duplicated required records. If true then see the domain in the dashboard app.
        /// </summary>
        /// <value>Whether the domain has duplicated required records. If true then see the domain in the dashboard app.</value>
        [JsonPropertyName("hasDuplicateRecords")]
        public bool HasDuplicateRecords { get; set; }

        /// <summary>
        /// Whether the domain has missing required records. If true then see the domain in the dashboard app.
        /// </summary>
        /// <value>Whether the domain has missing required records. If true then see the domain in the dashboard app.</value>
        [JsonPropertyName("hasMissingRecords")]
        public bool HasMissingRecords { get; set; }

        /// <summary>
        /// Whether domain has been verified or not. If the domain is not verified after 72 hours there is most likely an issue with the domains DNS records.
        /// </summary>
        /// <value>Whether domain has been verified or not. If the domain is not verified after 72 hours there is most likely an issue with the domains DNS records.</value>
        [JsonPropertyName("isVerified")]
        public bool IsVerified { get; set; }

        /// <summary>
        /// List of DNS domain name records (C, MX, TXT) etc that you must add to the DNS server associated with your domain provider.
        /// </summary>
        /// <value>List of DNS domain name records (C, MX, TXT) etc that you must add to the DNS server associated with your domain provider.</value>
        [JsonPropertyName("domainNameRecords")]
        public List<DomainNameRecord> DomainNameRecords { get; set; }

        /// <summary>
        /// Gets or Sets CreatedAt
        /// </summary>
        [JsonPropertyName("createdAt")]
        public DateTime CreatedAt { get; set; }

        /// <summary>
        /// Gets or Sets UpdatedAt
        /// </summary>
        [JsonPropertyName("updatedAt")]
        public DateTime UpdatedAt { get; set; }

        /// <summary>
        /// Used to track the state of DuplicateRecordsMessage
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> DuplicateRecordsMessageOption { get; private set; }

        /// <summary>
        /// If the domain is duplicate records.
        /// </summary>
        /// <value>If the domain is duplicate records.</value>
        [JsonPropertyName("duplicateRecordsMessage")]
        public string DuplicateRecordsMessage { get { return this.DuplicateRecordsMessageOption; } set { this.DuplicateRecordsMessageOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of MissingRecordsMessage
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> MissingRecordsMessageOption { get; private set; }

        /// <summary>
        /// If the domain is missing records then show which pairs are missing.
        /// </summary>
        /// <value>If the domain is missing records then show which pairs are missing.</value>
        [JsonPropertyName("missingRecordsMessage")]
        public string MissingRecordsMessage { get { return this.MissingRecordsMessageOption; } set { this.MissingRecordsMessageOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of CatchAllInboxId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Guid?> CatchAllInboxIdOption { get; private set; }

        /// <summary>
        /// The optional catch all inbox that will receive emails sent to the domain that cannot be matched.
        /// </summary>
        /// <value>The optional catch all inbox that will receive emails sent to the domain that cannot be matched.</value>
        [JsonPropertyName("catchAllInboxId")]
        public Guid? CatchAllInboxId { get { return this.CatchAllInboxIdOption; } set { this.CatchAllInboxIdOption = new Option<Guid?>(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class DomainDto {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  UserId: ").Append(UserId).Append("\n");
            sb.Append("  Domain: ").Append(Domain).Append("\n");
            sb.Append("  VerificationToken: ").Append(VerificationToken).Append("\n");
            sb.Append("  DkimTokens: ").Append(DkimTokens).Append("\n");
            sb.Append("  HasDuplicateRecords: ").Append(HasDuplicateRecords).Append("\n");
            sb.Append("  HasMissingRecords: ").Append(HasMissingRecords).Append("\n");
            sb.Append("  IsVerified: ").Append(IsVerified).Append("\n");
            sb.Append("  DomainNameRecords: ").Append(DomainNameRecords).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
            sb.Append("  DomainType: ").Append(DomainType).Append("\n");
            sb.Append("  DuplicateRecordsMessage: ").Append(DuplicateRecordsMessage).Append("\n");
            sb.Append("  MissingRecordsMessage: ").Append(MissingRecordsMessage).Append("\n");
            sb.Append("  CatchAllInboxId: ").Append(CatchAllInboxId).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="DomainDto" />
    /// </summary>
    public class DomainDtoJsonConverter : JsonConverter<DomainDto>
    {
        /// <summary>
        /// The format to use to serialize CreatedAt
        /// </summary>
        public static string CreatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize UpdatedAt
        /// </summary>
        public static string UpdatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="DomainDto" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override DomainDto Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<Guid?> id = default;
            Option<Guid?> userId = default;
            Option<string> domain = default;
            Option<string> verificationToken = default;
            Option<List<string>> dkimTokens = default;
            Option<bool?> hasDuplicateRecords = default;
            Option<bool?> hasMissingRecords = default;
            Option<bool?> isVerified = default;
            Option<List<DomainNameRecord>> domainNameRecords = default;
            Option<DateTime?> createdAt = default;
            Option<DateTime?> updatedAt = default;
            Option<DomainDto.DomainTypeEnum?> domainType = default;
            Option<string> duplicateRecordsMessage = default;
            Option<string> missingRecordsMessage = default;
            Option<Guid?> catchAllInboxId = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "id":
                            id = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "userId":
                            userId = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "domain":
                            domain = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "verificationToken":
                            verificationToken = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "dkimTokens":
                            dkimTokens = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "hasDuplicateRecords":
                            hasDuplicateRecords = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "hasMissingRecords":
                            hasMissingRecords = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "isVerified":
                            isVerified = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "domainNameRecords":
                            domainNameRecords = new Option<List<DomainNameRecord>>(JsonSerializer.Deserialize<List<DomainNameRecord>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "createdAt":
                            createdAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "updatedAt":
                            updatedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "domainType":
                            string domainTypeRawValue = utf8JsonReader.GetString();
                            if (domainTypeRawValue != null)
                                domainType = new Option<DomainDto.DomainTypeEnum?>(DomainDto.DomainTypeEnumFromStringOrDefault(domainTypeRawValue));
                            break;
                        case "duplicateRecordsMessage":
                            duplicateRecordsMessage = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "missingRecordsMessage":
                            missingRecordsMessage = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "catchAllInboxId":
                            catchAllInboxId = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class DomainDto.", nameof(id));

            if (!userId.IsSet)
                throw new ArgumentException("Property is required for class DomainDto.", nameof(userId));

            if (!domain.IsSet)
                throw new ArgumentException("Property is required for class DomainDto.", nameof(domain));

            if (!verificationToken.IsSet)
                throw new ArgumentException("Property is required for class DomainDto.", nameof(verificationToken));

            if (!dkimTokens.IsSet)
                throw new ArgumentException("Property is required for class DomainDto.", nameof(dkimTokens));

            if (!hasDuplicateRecords.IsSet)
                throw new ArgumentException("Property is required for class DomainDto.", nameof(hasDuplicateRecords));

            if (!hasMissingRecords.IsSet)
                throw new ArgumentException("Property is required for class DomainDto.", nameof(hasMissingRecords));

            if (!isVerified.IsSet)
                throw new ArgumentException("Property is required for class DomainDto.", nameof(isVerified));

            if (!domainNameRecords.IsSet)
                throw new ArgumentException("Property is required for class DomainDto.", nameof(domainNameRecords));

            if (!createdAt.IsSet)
                throw new ArgumentException("Property is required for class DomainDto.", nameof(createdAt));

            if (!updatedAt.IsSet)
                throw new ArgumentException("Property is required for class DomainDto.", nameof(updatedAt));

            if (!domainType.IsSet)
                throw new ArgumentException("Property is required for class DomainDto.", nameof(domainType));

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class DomainDto.");

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId), "Property is not nullable for class DomainDto.");

            if (domain.IsSet && domain.Value == null)
                throw new ArgumentNullException(nameof(domain), "Property is not nullable for class DomainDto.");

            if (verificationToken.IsSet && verificationToken.Value == null)
                throw new ArgumentNullException(nameof(verificationToken), "Property is not nullable for class DomainDto.");

            if (dkimTokens.IsSet && dkimTokens.Value == null)
                throw new ArgumentNullException(nameof(dkimTokens), "Property is not nullable for class DomainDto.");

            if (hasDuplicateRecords.IsSet && hasDuplicateRecords.Value == null)
                throw new ArgumentNullException(nameof(hasDuplicateRecords), "Property is not nullable for class DomainDto.");

            if (hasMissingRecords.IsSet && hasMissingRecords.Value == null)
                throw new ArgumentNullException(nameof(hasMissingRecords), "Property is not nullable for class DomainDto.");

            if (isVerified.IsSet && isVerified.Value == null)
                throw new ArgumentNullException(nameof(isVerified), "Property is not nullable for class DomainDto.");

            if (domainNameRecords.IsSet && domainNameRecords.Value == null)
                throw new ArgumentNullException(nameof(domainNameRecords), "Property is not nullable for class DomainDto.");

            if (createdAt.IsSet && createdAt.Value == null)
                throw new ArgumentNullException(nameof(createdAt), "Property is not nullable for class DomainDto.");

            if (updatedAt.IsSet && updatedAt.Value == null)
                throw new ArgumentNullException(nameof(updatedAt), "Property is not nullable for class DomainDto.");

            if (domainType.IsSet && domainType.Value == null)
                throw new ArgumentNullException(nameof(domainType), "Property is not nullable for class DomainDto.");

            return new DomainDto(id.Value.Value, userId.Value.Value, domain.Value, verificationToken.Value, dkimTokens.Value, hasDuplicateRecords.Value.Value, hasMissingRecords.Value.Value, isVerified.Value.Value, domainNameRecords.Value, createdAt.Value.Value, updatedAt.Value.Value, domainType.Value.Value, duplicateRecordsMessage, missingRecordsMessage, catchAllInboxId);
        }

        /// <summary>
        /// Serializes a <see cref="DomainDto" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="domainDto"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, DomainDto domainDto, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, domainDto, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="DomainDto" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="domainDto"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, DomainDto domainDto, JsonSerializerOptions jsonSerializerOptions)
        {
            if (domainDto.Domain == null)
                throw new ArgumentNullException(nameof(domainDto.Domain), "Property is required for class DomainDto.");

            if (domainDto.VerificationToken == null)
                throw new ArgumentNullException(nameof(domainDto.VerificationToken), "Property is required for class DomainDto.");

            if (domainDto.DkimTokens == null)
                throw new ArgumentNullException(nameof(domainDto.DkimTokens), "Property is required for class DomainDto.");

            if (domainDto.DomainNameRecords == null)
                throw new ArgumentNullException(nameof(domainDto.DomainNameRecords), "Property is required for class DomainDto.");

            writer.WriteString("id", domainDto.Id);

            writer.WriteString("userId", domainDto.UserId);

            writer.WriteString("domain", domainDto.Domain);

            writer.WriteString("verificationToken", domainDto.VerificationToken);

            writer.WritePropertyName("dkimTokens");
            JsonSerializer.Serialize(writer, domainDto.DkimTokens, jsonSerializerOptions);
            writer.WriteBoolean("hasDuplicateRecords", domainDto.HasDuplicateRecords);

            writer.WriteBoolean("hasMissingRecords", domainDto.HasMissingRecords);

            writer.WriteBoolean("isVerified", domainDto.IsVerified);

            writer.WritePropertyName("domainNameRecords");
            JsonSerializer.Serialize(writer, domainDto.DomainNameRecords, jsonSerializerOptions);
            writer.WriteString("createdAt", domainDto.CreatedAt.ToString(CreatedAtFormat));

            writer.WriteString("updatedAt", domainDto.UpdatedAt.ToString(UpdatedAtFormat));

            var domainTypeRawValue = DomainDto.DomainTypeEnumToJsonValue(domainDto.DomainType);
            writer.WriteString("domainType", domainTypeRawValue);
            if (domainDto.DuplicateRecordsMessageOption.IsSet)
                if (domainDto.DuplicateRecordsMessageOption.Value != null)
                    writer.WriteString("duplicateRecordsMessage", domainDto.DuplicateRecordsMessage);
                else
                    writer.WriteNull("duplicateRecordsMessage");

            if (domainDto.MissingRecordsMessageOption.IsSet)
                if (domainDto.MissingRecordsMessageOption.Value != null)
                    writer.WriteString("missingRecordsMessage", domainDto.MissingRecordsMessage);
                else
                    writer.WriteNull("missingRecordsMessage");

            if (domainDto.CatchAllInboxIdOption.IsSet)
                if (domainDto.CatchAllInboxIdOption.Value != null)
                    writer.WriteString("catchAllInboxId", domainDto.CatchAllInboxIdOption.Value.Value);
                else
                    writer.WriteNull("catchAllInboxId");
        }
    }
}
