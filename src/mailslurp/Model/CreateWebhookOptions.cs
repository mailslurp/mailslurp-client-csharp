// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using mailslurp.Client;

namespace mailslurp.Model
{
    /// <summary>
    /// Options for creating a webhook. Webhooks can be attached to inboxes and MailSlurp will POST a webhook payload to the URL specified whenever the webhook&#39;s event is triggered. Webhooks are great for processing many inbound emails and responding to other events at scale. Customize the payload sent to your endpoint by setting the &#x60;requestBodyTemplate&#x60; property to a string with moustache style variables. Property names from the standard payload model for the given event are available as variables.
    /// </summary>
    public partial class CreateWebhookOptions : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CreateWebhookOptions" /> class.
        /// </summary>
        /// <param name="url">Public URL on your server that MailSlurp can post WebhookNotification payload to when an email is received or an event is trigger. The payload of the submitted JSON is dependent on the webhook event type. See docs.mailslurp.com/webhooks for event payload documentation.</param>
        /// <param name="basicAuth">basicAuth</param>
        /// <param name="name">Optional name for the webhook</param>
        /// <param name="eventName">Optional webhook event name. Default is &#x60;EMAIL_RECEIVED&#x60; and is triggered when an email is received by the inbox associated with the webhook. Payload differ according to the webhook event name.</param>
        /// <param name="includeHeaders">includeHeaders</param>
        /// <param name="requestBodyTemplate">Template for the JSON body of the webhook request that will be sent to your server. Use Moustache style &#x60;{{variableName}}&#x60; templating to use parts of the standard webhook payload for the given event.</param>
        /// <param name="useStaticIpRange">Use static IP range when calling webhook endpoint (default to false)</param>
        /// <param name="ignoreInsecureSslCertificates">Ignore insecure SSL certificates when sending request. Useful for self-signed certs.</param>
        /// <param name="tags">Optional list of tags</param>
        [JsonConstructor]
        public CreateWebhookOptions(string url, Option<BasicAuthOptions> basicAuth = default, Option<string> name = default, Option<EventNameEnum?> eventName = default, Option<WebhookHeaders> includeHeaders = default, Option<string> requestBodyTemplate = default, Option<bool?> useStaticIpRange = default, Option<bool?> ignoreInsecureSslCertificates = default, Option<List<string>> tags = default)
        {
            Url = url;
            BasicAuthOption = basicAuth;
            NameOption = name;
            EventNameOption = eventName;
            IncludeHeadersOption = includeHeaders;
            RequestBodyTemplateOption = requestBodyTemplate;
            UseStaticIpRangeOption = useStaticIpRange;
            IgnoreInsecureSslCertificatesOption = ignoreInsecureSslCertificates;
            TagsOption = tags;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Optional webhook event name. Default is &#x60;EMAIL_RECEIVED&#x60; and is triggered when an email is received by the inbox associated with the webhook. Payload differ according to the webhook event name.
        /// </summary>
        /// <value>Optional webhook event name. Default is &#x60;EMAIL_RECEIVED&#x60; and is triggered when an email is received by the inbox associated with the webhook. Payload differ according to the webhook event name.</value>
        public enum EventNameEnum
        {
            /// <summary>
            /// Enum EMAILRECEIVED for value: EMAIL_RECEIVED
            /// </summary>
            EMAILRECEIVED = 1,

            /// <summary>
            /// Enum NEWEMAIL for value: NEW_EMAIL
            /// </summary>
            NEWEMAIL = 2,

            /// <summary>
            /// Enum NEWCONTACT for value: NEW_CONTACT
            /// </summary>
            NEWCONTACT = 3,

            /// <summary>
            /// Enum NEWATTACHMENT for value: NEW_ATTACHMENT
            /// </summary>
            NEWATTACHMENT = 4,

            /// <summary>
            /// Enum EMAILOPENED for value: EMAIL_OPENED
            /// </summary>
            EMAILOPENED = 5,

            /// <summary>
            /// Enum EMAILREAD for value: EMAIL_READ
            /// </summary>
            EMAILREAD = 6,

            /// <summary>
            /// Enum DELIVERYSTATUS for value: DELIVERY_STATUS
            /// </summary>
            DELIVERYSTATUS = 7,

            /// <summary>
            /// Enum BOUNCE for value: BOUNCE
            /// </summary>
            BOUNCE = 8,

            /// <summary>
            /// Enum BOUNCERECIPIENT for value: BOUNCE_RECIPIENT
            /// </summary>
            BOUNCERECIPIENT = 9,

            /// <summary>
            /// Enum NEWSMS for value: NEW_SMS
            /// </summary>
            NEWSMS = 10,

            /// <summary>
            /// Enum NEWGUESTUSER for value: NEW_GUEST_USER
            /// </summary>
            NEWGUESTUSER = 11
        }

        /// <summary>
        /// Returns a <see cref="EventNameEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static EventNameEnum EventNameEnumFromString(string value)
        {
            if (value.Equals("EMAIL_RECEIVED"))
                return EventNameEnum.EMAILRECEIVED;

            if (value.Equals("NEW_EMAIL"))
                return EventNameEnum.NEWEMAIL;

            if (value.Equals("NEW_CONTACT"))
                return EventNameEnum.NEWCONTACT;

            if (value.Equals("NEW_ATTACHMENT"))
                return EventNameEnum.NEWATTACHMENT;

            if (value.Equals("EMAIL_OPENED"))
                return EventNameEnum.EMAILOPENED;

            if (value.Equals("EMAIL_READ"))
                return EventNameEnum.EMAILREAD;

            if (value.Equals("DELIVERY_STATUS"))
                return EventNameEnum.DELIVERYSTATUS;

            if (value.Equals("BOUNCE"))
                return EventNameEnum.BOUNCE;

            if (value.Equals("BOUNCE_RECIPIENT"))
                return EventNameEnum.BOUNCERECIPIENT;

            if (value.Equals("NEW_SMS"))
                return EventNameEnum.NEWSMS;

            if (value.Equals("NEW_GUEST_USER"))
                return EventNameEnum.NEWGUESTUSER;

            throw new NotImplementedException($"Could not convert value to type EventNameEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="EventNameEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static EventNameEnum? EventNameEnumFromStringOrDefault(string value)
        {
            if (value.Equals("EMAIL_RECEIVED"))
                return EventNameEnum.EMAILRECEIVED;

            if (value.Equals("NEW_EMAIL"))
                return EventNameEnum.NEWEMAIL;

            if (value.Equals("NEW_CONTACT"))
                return EventNameEnum.NEWCONTACT;

            if (value.Equals("NEW_ATTACHMENT"))
                return EventNameEnum.NEWATTACHMENT;

            if (value.Equals("EMAIL_OPENED"))
                return EventNameEnum.EMAILOPENED;

            if (value.Equals("EMAIL_READ"))
                return EventNameEnum.EMAILREAD;

            if (value.Equals("DELIVERY_STATUS"))
                return EventNameEnum.DELIVERYSTATUS;

            if (value.Equals("BOUNCE"))
                return EventNameEnum.BOUNCE;

            if (value.Equals("BOUNCE_RECIPIENT"))
                return EventNameEnum.BOUNCERECIPIENT;

            if (value.Equals("NEW_SMS"))
                return EventNameEnum.NEWSMS;

            if (value.Equals("NEW_GUEST_USER"))
                return EventNameEnum.NEWGUESTUSER;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="EventNameEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string EventNameEnumToJsonValue(EventNameEnum? value)
        {
            if (value == null)
                return null;

            if (value == EventNameEnum.EMAILRECEIVED)
                return "EMAIL_RECEIVED";

            if (value == EventNameEnum.NEWEMAIL)
                return "NEW_EMAIL";

            if (value == EventNameEnum.NEWCONTACT)
                return "NEW_CONTACT";

            if (value == EventNameEnum.NEWATTACHMENT)
                return "NEW_ATTACHMENT";

            if (value == EventNameEnum.EMAILOPENED)
                return "EMAIL_OPENED";

            if (value == EventNameEnum.EMAILREAD)
                return "EMAIL_READ";

            if (value == EventNameEnum.DELIVERYSTATUS)
                return "DELIVERY_STATUS";

            if (value == EventNameEnum.BOUNCE)
                return "BOUNCE";

            if (value == EventNameEnum.BOUNCERECIPIENT)
                return "BOUNCE_RECIPIENT";

            if (value == EventNameEnum.NEWSMS)
                return "NEW_SMS";

            if (value == EventNameEnum.NEWGUESTUSER)
                return "NEW_GUEST_USER";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of EventName
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<EventNameEnum?> EventNameOption { get; private set; }

        /// <summary>
        /// Optional webhook event name. Default is &#x60;EMAIL_RECEIVED&#x60; and is triggered when an email is received by the inbox associated with the webhook. Payload differ according to the webhook event name.
        /// </summary>
        /// <value>Optional webhook event name. Default is &#x60;EMAIL_RECEIVED&#x60; and is triggered when an email is received by the inbox associated with the webhook. Payload differ according to the webhook event name.</value>
        [JsonPropertyName("eventName")]
        public EventNameEnum? EventName { get { return this.EventNameOption; } set { this.EventNameOption = new Option<EventNameEnum?>(value); } }

        /// <summary>
        /// Public URL on your server that MailSlurp can post WebhookNotification payload to when an email is received or an event is trigger. The payload of the submitted JSON is dependent on the webhook event type. See docs.mailslurp.com/webhooks for event payload documentation.
        /// </summary>
        /// <value>Public URL on your server that MailSlurp can post WebhookNotification payload to when an email is received or an event is trigger. The payload of the submitted JSON is dependent on the webhook event type. See docs.mailslurp.com/webhooks for event payload documentation.</value>
        [JsonPropertyName("url")]
        public string Url { get; set; }

        /// <summary>
        /// Used to track the state of BasicAuth
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<BasicAuthOptions> BasicAuthOption { get; private set; }

        /// <summary>
        /// Gets or Sets BasicAuth
        /// </summary>
        [JsonPropertyName("basicAuth")]
        public BasicAuthOptions BasicAuth { get { return this.BasicAuthOption; } set { this.BasicAuthOption = new Option<BasicAuthOptions>(value); } }

        /// <summary>
        /// Used to track the state of Name
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> NameOption { get; private set; }

        /// <summary>
        /// Optional name for the webhook
        /// </summary>
        /// <value>Optional name for the webhook</value>
        [JsonPropertyName("name")]
        public string Name { get { return this.NameOption; } set { this.NameOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of IncludeHeaders
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<WebhookHeaders> IncludeHeadersOption { get; private set; }

        /// <summary>
        /// Gets or Sets IncludeHeaders
        /// </summary>
        [JsonPropertyName("includeHeaders")]
        public WebhookHeaders IncludeHeaders { get { return this.IncludeHeadersOption; } set { this.IncludeHeadersOption = new Option<WebhookHeaders>(value); } }

        /// <summary>
        /// Used to track the state of RequestBodyTemplate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> RequestBodyTemplateOption { get; private set; }

        /// <summary>
        /// Template for the JSON body of the webhook request that will be sent to your server. Use Moustache style &#x60;{{variableName}}&#x60; templating to use parts of the standard webhook payload for the given event.
        /// </summary>
        /// <value>Template for the JSON body of the webhook request that will be sent to your server. Use Moustache style &#x60;{{variableName}}&#x60; templating to use parts of the standard webhook payload for the given event.</value>
        [JsonPropertyName("requestBodyTemplate")]
        public string RequestBodyTemplate { get { return this.RequestBodyTemplateOption; } set { this.RequestBodyTemplateOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of UseStaticIpRange
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> UseStaticIpRangeOption { get; private set; }

        /// <summary>
        /// Use static IP range when calling webhook endpoint
        /// </summary>
        /// <value>Use static IP range when calling webhook endpoint</value>
        [JsonPropertyName("useStaticIpRange")]
        public bool? UseStaticIpRange { get { return this.UseStaticIpRangeOption; } set { this.UseStaticIpRangeOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of IgnoreInsecureSslCertificates
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IgnoreInsecureSslCertificatesOption { get; private set; }

        /// <summary>
        /// Ignore insecure SSL certificates when sending request. Useful for self-signed certs.
        /// </summary>
        /// <value>Ignore insecure SSL certificates when sending request. Useful for self-signed certs.</value>
        [JsonPropertyName("ignoreInsecureSslCertificates")]
        public bool? IgnoreInsecureSslCertificates { get { return this.IgnoreInsecureSslCertificatesOption; } set { this.IgnoreInsecureSslCertificatesOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of Tags
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>> TagsOption { get; private set; }

        /// <summary>
        /// Optional list of tags
        /// </summary>
        /// <value>Optional list of tags</value>
        [JsonPropertyName("tags")]
        public List<string> Tags { get { return this.TagsOption; } set { this.TagsOption = new Option<List<string>>(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CreateWebhookOptions {\n");
            sb.Append("  Url: ").Append(Url).Append("\n");
            sb.Append("  BasicAuth: ").Append(BasicAuth).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  EventName: ").Append(EventName).Append("\n");
            sb.Append("  IncludeHeaders: ").Append(IncludeHeaders).Append("\n");
            sb.Append("  RequestBodyTemplate: ").Append(RequestBodyTemplate).Append("\n");
            sb.Append("  UseStaticIpRange: ").Append(UseStaticIpRange).Append("\n");
            sb.Append("  IgnoreInsecureSslCertificates: ").Append(IgnoreInsecureSslCertificates).Append("\n");
            sb.Append("  Tags: ").Append(Tags).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="CreateWebhookOptions" />
    /// </summary>
    public class CreateWebhookOptionsJsonConverter : JsonConverter<CreateWebhookOptions>
    {
        /// <summary>
        /// Deserializes json to <see cref="CreateWebhookOptions" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override CreateWebhookOptions Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string> url = default;
            Option<BasicAuthOptions> basicAuth = default;
            Option<string> name = default;
            Option<CreateWebhookOptions.EventNameEnum?> eventName = default;
            Option<WebhookHeaders> includeHeaders = default;
            Option<string> requestBodyTemplate = default;
            Option<bool?> useStaticIpRange = default;
            Option<bool?> ignoreInsecureSslCertificates = default;
            Option<List<string>> tags = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "url":
                            url = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "basicAuth":
                            basicAuth = new Option<BasicAuthOptions>(JsonSerializer.Deserialize<BasicAuthOptions>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "name":
                            name = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "eventName":
                            string eventNameRawValue = utf8JsonReader.GetString();
                            if (eventNameRawValue != null)
                                eventName = new Option<CreateWebhookOptions.EventNameEnum?>(CreateWebhookOptions.EventNameEnumFromStringOrDefault(eventNameRawValue));
                            break;
                        case "includeHeaders":
                            includeHeaders = new Option<WebhookHeaders>(JsonSerializer.Deserialize<WebhookHeaders>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "requestBodyTemplate":
                            requestBodyTemplate = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "useStaticIpRange":
                            useStaticIpRange = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "ignoreInsecureSslCertificates":
                            ignoreInsecureSslCertificates = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "tags":
                            tags = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!url.IsSet)
                throw new ArgumentException("Property is required for class CreateWebhookOptions.", nameof(url));

            if (url.IsSet && url.Value == null)
                throw new ArgumentNullException(nameof(url), "Property is not nullable for class CreateWebhookOptions.");

            if (includeHeaders.IsSet && includeHeaders.Value == null)
                throw new ArgumentNullException(nameof(includeHeaders), "Property is not nullable for class CreateWebhookOptions.");

            return new CreateWebhookOptions(url.Value, basicAuth, name, eventName, includeHeaders, requestBodyTemplate, useStaticIpRange, ignoreInsecureSslCertificates, tags);
        }

        /// <summary>
        /// Serializes a <see cref="CreateWebhookOptions" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="createWebhookOptions"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, CreateWebhookOptions createWebhookOptions, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, createWebhookOptions, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="CreateWebhookOptions" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="createWebhookOptions"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, CreateWebhookOptions createWebhookOptions, JsonSerializerOptions jsonSerializerOptions)
        {
            if (createWebhookOptions.Url == null)
                throw new ArgumentNullException(nameof(createWebhookOptions.Url), "Property is required for class CreateWebhookOptions.");

            if (createWebhookOptions.IncludeHeadersOption.IsSet && createWebhookOptions.IncludeHeaders == null)
                throw new ArgumentNullException(nameof(createWebhookOptions.IncludeHeaders), "Property is required for class CreateWebhookOptions.");

            writer.WriteString("url", createWebhookOptions.Url);

            if (createWebhookOptions.BasicAuthOption.IsSet)
                if (createWebhookOptions.BasicAuthOption.Value != null)
                {
                    writer.WritePropertyName("basicAuth");
                    JsonSerializer.Serialize(writer, createWebhookOptions.BasicAuth, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("basicAuth");
            if (createWebhookOptions.NameOption.IsSet)
                if (createWebhookOptions.NameOption.Value != null)
                    writer.WriteString("name", createWebhookOptions.Name);
                else
                    writer.WriteNull("name");

            var eventNameRawValue = CreateWebhookOptions.EventNameEnumToJsonValue(createWebhookOptions.EventNameOption.Value.Value);
            if (eventNameRawValue != null)
                writer.WriteString("eventName", eventNameRawValue);
            else
                writer.WriteNull("eventName");

            if (createWebhookOptions.IncludeHeadersOption.IsSet)
            {
                writer.WritePropertyName("includeHeaders");
                JsonSerializer.Serialize(writer, createWebhookOptions.IncludeHeaders, jsonSerializerOptions);
            }
            if (createWebhookOptions.RequestBodyTemplateOption.IsSet)
                if (createWebhookOptions.RequestBodyTemplateOption.Value != null)
                    writer.WriteString("requestBodyTemplate", createWebhookOptions.RequestBodyTemplate);
                else
                    writer.WriteNull("requestBodyTemplate");

            if (createWebhookOptions.UseStaticIpRangeOption.IsSet)
                if (createWebhookOptions.UseStaticIpRangeOption.Value != null)
                    writer.WriteBoolean("useStaticIpRange", createWebhookOptions.UseStaticIpRangeOption.Value.Value);
                else
                    writer.WriteNull("useStaticIpRange");

            if (createWebhookOptions.IgnoreInsecureSslCertificatesOption.IsSet)
                if (createWebhookOptions.IgnoreInsecureSslCertificatesOption.Value != null)
                    writer.WriteBoolean("ignoreInsecureSslCertificates", createWebhookOptions.IgnoreInsecureSslCertificatesOption.Value.Value);
                else
                    writer.WriteNull("ignoreInsecureSslCertificates");

            if (createWebhookOptions.TagsOption.IsSet)
                if (createWebhookOptions.TagsOption.Value != null)
                {
                    writer.WritePropertyName("tags");
                    JsonSerializer.Serialize(writer, createWebhookOptions.Tags, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("tags");
        }
    }
}
