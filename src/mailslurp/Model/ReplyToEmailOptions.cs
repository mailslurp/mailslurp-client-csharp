// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using mailslurp.Client;

namespace mailslurp.Model
{
    /// <summary>
    /// Options for replying to email with API
    /// </summary>
    public partial class ReplyToEmailOptions : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ReplyToEmailOptions" /> class.
        /// </summary>
        /// <param name="body">Body of the reply email you want to send</param>
        /// <param name="isHTML">Is the reply HTML</param>
        /// <param name="from">The from header that should be used. Optional</param>
        /// <param name="replyTo">The replyTo header that should be used. Optional</param>
        /// <param name="customHeaders">Optional custom headers</param>
        /// <param name="charset">The charset that your message should be sent with. Optional. Default is UTF-8</param>
        /// <param name="attachments">List of uploaded attachments to send with the reply. Optional.</param>
        /// <param name="templateVariables">Template variables if using a template</param>
        /// <param name="template">Template ID to use instead of body. Will use template variable map to fill defined variable slots.</param>
        /// <param name="sendStrategy">How an email should be sent based on its recipients</param>
        /// <param name="useInboxName">Optionally use inbox name as display name for sender email address</param>
        /// <param name="html">html</param>
        [JsonConstructor]
        public ReplyToEmailOptions(string body, bool isHTML, Option<string> from = default, Option<string> replyTo = default, Option<Dictionary<string, string>> customHeaders = default, Option<string> charset = default, Option<List<string>> attachments = default, Option<Dictionary<string, Object>> templateVariables = default, Option<Guid?> template = default, Option<SendStrategyEnum?> sendStrategy = default, Option<bool?> useInboxName = default, Option<bool?> html = default)
        {
            Body = body;
            IsHTML = isHTML;
            FromOption = from;
            ReplyToOption = replyTo;
            CustomHeadersOption = customHeaders;
            CharsetOption = charset;
            AttachmentsOption = attachments;
            TemplateVariablesOption = templateVariables;
            TemplateOption = template;
            SendStrategyOption = sendStrategy;
            UseInboxNameOption = useInboxName;
            HtmlOption = html;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// How an email should be sent based on its recipients
        /// </summary>
        /// <value>How an email should be sent based on its recipients</value>
        public enum SendStrategyEnum
        {
            /// <summary>
            /// Enum SINGLEMESSAGE for value: SINGLE_MESSAGE
            /// </summary>
            SINGLEMESSAGE = 1
        }

        /// <summary>
        /// Returns a <see cref="SendStrategyEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static SendStrategyEnum SendStrategyEnumFromString(string value)
        {
            if (value.Equals("SINGLE_MESSAGE"))
                return SendStrategyEnum.SINGLEMESSAGE;

            throw new NotImplementedException($"Could not convert value to type SendStrategyEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="SendStrategyEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static SendStrategyEnum? SendStrategyEnumFromStringOrDefault(string value)
        {
            if (value.Equals("SINGLE_MESSAGE"))
                return SendStrategyEnum.SINGLEMESSAGE;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="SendStrategyEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string SendStrategyEnumToJsonValue(SendStrategyEnum? value)
        {
            if (value == null)
                return null;

            if (value == SendStrategyEnum.SINGLEMESSAGE)
                return "SINGLE_MESSAGE";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of SendStrategy
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<SendStrategyEnum?> SendStrategyOption { get; private set; }

        /// <summary>
        /// How an email should be sent based on its recipients
        /// </summary>
        /// <value>How an email should be sent based on its recipients</value>
        [JsonPropertyName("sendStrategy")]
        public SendStrategyEnum? SendStrategy { get { return this.SendStrategyOption; } set { this.SendStrategyOption = new Option<SendStrategyEnum?>(value); } }

        /// <summary>
        /// Body of the reply email you want to send
        /// </summary>
        /// <value>Body of the reply email you want to send</value>
        [JsonPropertyName("body")]
        public string Body { get; set; }

        /// <summary>
        /// Is the reply HTML
        /// </summary>
        /// <value>Is the reply HTML</value>
        [JsonPropertyName("isHTML")]
        public bool IsHTML { get; set; }

        /// <summary>
        /// Used to track the state of From
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> FromOption { get; private set; }

        /// <summary>
        /// The from header that should be used. Optional
        /// </summary>
        /// <value>The from header that should be used. Optional</value>
        [JsonPropertyName("from")]
        public string From { get { return this.FromOption; } set { this.FromOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of ReplyTo
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> ReplyToOption { get; private set; }

        /// <summary>
        /// The replyTo header that should be used. Optional
        /// </summary>
        /// <value>The replyTo header that should be used. Optional</value>
        [JsonPropertyName("replyTo")]
        public string ReplyTo { get { return this.ReplyToOption; } set { this.ReplyToOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of CustomHeaders
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, string>> CustomHeadersOption { get; private set; }

        /// <summary>
        /// Optional custom headers
        /// </summary>
        /// <value>Optional custom headers</value>
        [JsonPropertyName("customHeaders")]
        public Dictionary<string, string> CustomHeaders { get { return this.CustomHeadersOption; } set { this.CustomHeadersOption = new Option<Dictionary<string, string>>(value); } }

        /// <summary>
        /// Used to track the state of Charset
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> CharsetOption { get; private set; }

        /// <summary>
        /// The charset that your message should be sent with. Optional. Default is UTF-8
        /// </summary>
        /// <value>The charset that your message should be sent with. Optional. Default is UTF-8</value>
        [JsonPropertyName("charset")]
        public string Charset { get { return this.CharsetOption; } set { this.CharsetOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of Attachments
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>> AttachmentsOption { get; private set; }

        /// <summary>
        /// List of uploaded attachments to send with the reply. Optional.
        /// </summary>
        /// <value>List of uploaded attachments to send with the reply. Optional.</value>
        [JsonPropertyName("attachments")]
        public List<string> Attachments { get { return this.AttachmentsOption; } set { this.AttachmentsOption = new Option<List<string>>(value); } }

        /// <summary>
        /// Used to track the state of TemplateVariables
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, Object>> TemplateVariablesOption { get; private set; }

        /// <summary>
        /// Template variables if using a template
        /// </summary>
        /// <value>Template variables if using a template</value>
        [JsonPropertyName("templateVariables")]
        public Dictionary<string, Object> TemplateVariables { get { return this.TemplateVariablesOption; } set { this.TemplateVariablesOption = new Option<Dictionary<string, Object>>(value); } }

        /// <summary>
        /// Used to track the state of Template
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Guid?> TemplateOption { get; private set; }

        /// <summary>
        /// Template ID to use instead of body. Will use template variable map to fill defined variable slots.
        /// </summary>
        /// <value>Template ID to use instead of body. Will use template variable map to fill defined variable slots.</value>
        [JsonPropertyName("template")]
        public Guid? Template { get { return this.TemplateOption; } set { this.TemplateOption = new Option<Guid?>(value); } }

        /// <summary>
        /// Used to track the state of UseInboxName
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> UseInboxNameOption { get; private set; }

        /// <summary>
        /// Optionally use inbox name as display name for sender email address
        /// </summary>
        /// <value>Optionally use inbox name as display name for sender email address</value>
        [JsonPropertyName("useInboxName")]
        public bool? UseInboxName { get { return this.UseInboxNameOption; } set { this.UseInboxNameOption = new Option<bool?>(value); } }

        /// <summary>
        /// Used to track the state of Html
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> HtmlOption { get; private set; }

        /// <summary>
        /// Gets or Sets Html
        /// </summary>
        [JsonPropertyName("html")]
        public bool? Html { get { return this.HtmlOption; } set { this.HtmlOption = new Option<bool?>(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReplyToEmailOptions {\n");
            sb.Append("  Body: ").Append(Body).Append("\n");
            sb.Append("  IsHTML: ").Append(IsHTML).Append("\n");
            sb.Append("  From: ").Append(From).Append("\n");
            sb.Append("  ReplyTo: ").Append(ReplyTo).Append("\n");
            sb.Append("  CustomHeaders: ").Append(CustomHeaders).Append("\n");
            sb.Append("  Charset: ").Append(Charset).Append("\n");
            sb.Append("  Attachments: ").Append(Attachments).Append("\n");
            sb.Append("  TemplateVariables: ").Append(TemplateVariables).Append("\n");
            sb.Append("  Template: ").Append(Template).Append("\n");
            sb.Append("  SendStrategy: ").Append(SendStrategy).Append("\n");
            sb.Append("  UseInboxName: ").Append(UseInboxName).Append("\n");
            sb.Append("  Html: ").Append(Html).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="ReplyToEmailOptions" />
    /// </summary>
    public class ReplyToEmailOptionsJsonConverter : JsonConverter<ReplyToEmailOptions>
    {
        /// <summary>
        /// Deserializes json to <see cref="ReplyToEmailOptions" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override ReplyToEmailOptions Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string> body = default;
            Option<bool?> isHTML = default;
            Option<string> from = default;
            Option<string> replyTo = default;
            Option<Dictionary<string, string>> customHeaders = default;
            Option<string> charset = default;
            Option<List<string>> attachments = default;
            Option<Dictionary<string, Object>> templateVariables = default;
            Option<Guid?> template = default;
            Option<ReplyToEmailOptions.SendStrategyEnum?> sendStrategy = default;
            Option<bool?> useInboxName = default;
            Option<bool?> html = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "body":
                            body = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "isHTML":
                            isHTML = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "from":
                            from = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "replyTo":
                            replyTo = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "customHeaders":
                            customHeaders = new Option<Dictionary<string, string>>(JsonSerializer.Deserialize<Dictionary<string, string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "charset":
                            charset = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "attachments":
                            attachments = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "templateVariables":
                            templateVariables = new Option<Dictionary<string, Object>>(JsonSerializer.Deserialize<Dictionary<string, Object>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "template":
                            template = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "sendStrategy":
                            string sendStrategyRawValue = utf8JsonReader.GetString();
                            if (sendStrategyRawValue != null)
                                sendStrategy = new Option<ReplyToEmailOptions.SendStrategyEnum?>(ReplyToEmailOptions.SendStrategyEnumFromStringOrDefault(sendStrategyRawValue));
                            break;
                        case "useInboxName":
                            useInboxName = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "html":
                            html = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!body.IsSet)
                throw new ArgumentException("Property is required for class ReplyToEmailOptions.", nameof(body));

            if (!isHTML.IsSet)
                throw new ArgumentException("Property is required for class ReplyToEmailOptions.", nameof(isHTML));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body), "Property is not nullable for class ReplyToEmailOptions.");

            if (isHTML.IsSet && isHTML.Value == null)
                throw new ArgumentNullException(nameof(isHTML), "Property is not nullable for class ReplyToEmailOptions.");

            if (html.IsSet && html.Value == null)
                throw new ArgumentNullException(nameof(html), "Property is not nullable for class ReplyToEmailOptions.");

            return new ReplyToEmailOptions(body.Value, isHTML.Value.Value, from, replyTo, customHeaders, charset, attachments, templateVariables, template, sendStrategy, useInboxName, html);
        }

        /// <summary>
        /// Serializes a <see cref="ReplyToEmailOptions" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, ReplyToEmailOptions replyToEmailOptions, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, replyToEmailOptions, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="ReplyToEmailOptions" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="replyToEmailOptions"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, ReplyToEmailOptions replyToEmailOptions, JsonSerializerOptions jsonSerializerOptions)
        {
            if (replyToEmailOptions.Body == null)
                throw new ArgumentNullException(nameof(replyToEmailOptions.Body), "Property is required for class ReplyToEmailOptions.");

            writer.WriteString("body", replyToEmailOptions.Body);

            writer.WriteBoolean("isHTML", replyToEmailOptions.IsHTML);

            if (replyToEmailOptions.FromOption.IsSet)
                if (replyToEmailOptions.FromOption.Value != null)
                    writer.WriteString("from", replyToEmailOptions.From);
                else
                    writer.WriteNull("from");

            if (replyToEmailOptions.ReplyToOption.IsSet)
                if (replyToEmailOptions.ReplyToOption.Value != null)
                    writer.WriteString("replyTo", replyToEmailOptions.ReplyTo);
                else
                    writer.WriteNull("replyTo");

            if (replyToEmailOptions.CustomHeadersOption.IsSet)
                if (replyToEmailOptions.CustomHeadersOption.Value != null)
                {
                    writer.WritePropertyName("customHeaders");
                    JsonSerializer.Serialize(writer, replyToEmailOptions.CustomHeaders, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("customHeaders");
            if (replyToEmailOptions.CharsetOption.IsSet)
                if (replyToEmailOptions.CharsetOption.Value != null)
                    writer.WriteString("charset", replyToEmailOptions.Charset);
                else
                    writer.WriteNull("charset");

            if (replyToEmailOptions.AttachmentsOption.IsSet)
                if (replyToEmailOptions.AttachmentsOption.Value != null)
                {
                    writer.WritePropertyName("attachments");
                    JsonSerializer.Serialize(writer, replyToEmailOptions.Attachments, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("attachments");
            if (replyToEmailOptions.TemplateVariablesOption.IsSet)
                if (replyToEmailOptions.TemplateVariablesOption.Value != null)
                {
                    writer.WritePropertyName("templateVariables");
                    JsonSerializer.Serialize(writer, replyToEmailOptions.TemplateVariables, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("templateVariables");
            if (replyToEmailOptions.TemplateOption.IsSet)
                if (replyToEmailOptions.TemplateOption.Value != null)
                    writer.WriteString("template", replyToEmailOptions.TemplateOption.Value.Value);
                else
                    writer.WriteNull("template");

            var sendStrategyRawValue = ReplyToEmailOptions.SendStrategyEnumToJsonValue(replyToEmailOptions.SendStrategyOption.Value.Value);
            if (sendStrategyRawValue != null)
                writer.WriteString("sendStrategy", sendStrategyRawValue);
            else
                writer.WriteNull("sendStrategy");

            if (replyToEmailOptions.UseInboxNameOption.IsSet)
                if (replyToEmailOptions.UseInboxNameOption.Value != null)
                    writer.WriteBoolean("useInboxName", replyToEmailOptions.UseInboxNameOption.Value.Value);
                else
                    writer.WriteNull("useInboxName");

            if (replyToEmailOptions.HtmlOption.IsSet)
                writer.WriteBoolean("html", replyToEmailOptions.HtmlOption.Value.Value);
        }
    }
}
