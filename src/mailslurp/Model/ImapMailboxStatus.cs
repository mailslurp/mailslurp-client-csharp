/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = mailslurp.Client.OpenAPIDateConverter;

namespace mailslurp.Model
{
    /// <summary>
    /// ImapMailboxStatus
    /// </summary>
    [DataContract(Name = "ImapMailboxStatus")]
    public partial class ImapMailboxStatus : IEquatable<ImapMailboxStatus>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ImapMailboxStatus" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ImapMailboxStatus() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ImapMailboxStatus" /> class.
        /// </summary>
        /// <param name="name">The mailbox name. (required).</param>
        /// <param name="readOnly">True if the mailbox is open in read-only mode. (required).</param>
        /// <param name="items">Results map (required).</param>
        /// <param name="flags">The mailbox flags. (required).</param>
        /// <param name="permanentFlags">The mailbox permanent flags. (required).</param>
        /// <param name="unseenSeqNum">The sequence number of the first unseen message in the mailbox. (required).</param>
        /// <param name="messages">The number of messages in this mailbox. (required).</param>
        /// <param name="recent">The number of messages not seen since the last time the mailbox was opened. (required).</param>
        /// <param name="unseen">The number of unread messages. (required).</param>
        /// <param name="uidNext">The next UID. (required).</param>
        /// <param name="uidValidity">Together with a UID, it is a unique identifier for a message. Must be greater than or equal to 1. (required).</param>
        /// <param name="appendLimit">Per-mailbox limit of message size. Set only if server supports the APPENDLIMIT extension.</param>
        public ImapMailboxStatus(string name = default(string), bool readOnly = default(bool), Object items = default(Object), List<string> flags = default(List<string>), List<string> permanentFlags = default(List<string>), long unseenSeqNum = default(long), int messages = default(int), int recent = default(int), int unseen = default(int), long uidNext = default(long), int uidValidity = default(int), int? appendLimit = default(int?))
        {
            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new ArgumentNullException("name is a required property for ImapMailboxStatus and cannot be null");
            }
            this.Name = name;
            this.ReadOnly = readOnly;
            // to ensure "items" is required (not null)
            if (items == null)
            {
                throw new ArgumentNullException("items is a required property for ImapMailboxStatus and cannot be null");
            }
            this.Items = items;
            // to ensure "flags" is required (not null)
            if (flags == null)
            {
                throw new ArgumentNullException("flags is a required property for ImapMailboxStatus and cannot be null");
            }
            this.Flags = flags;
            // to ensure "permanentFlags" is required (not null)
            if (permanentFlags == null)
            {
                throw new ArgumentNullException("permanentFlags is a required property for ImapMailboxStatus and cannot be null");
            }
            this.PermanentFlags = permanentFlags;
            this.UnseenSeqNum = unseenSeqNum;
            this.Messages = messages;
            this.Recent = recent;
            this.Unseen = unseen;
            this.UidNext = uidNext;
            this.UidValidity = uidValidity;
            this.AppendLimit = appendLimit;
        }

        /// <summary>
        /// The mailbox name.
        /// </summary>
        /// <value>The mailbox name.</value>
        [DataMember(Name = "name", IsRequired = true, EmitDefaultValue = true)]
        public string Name { get; set; }

        /// <summary>
        /// True if the mailbox is open in read-only mode.
        /// </summary>
        /// <value>True if the mailbox is open in read-only mode.</value>
        [DataMember(Name = "readOnly", IsRequired = true, EmitDefaultValue = true)]
        public bool ReadOnly { get; set; }

        /// <summary>
        /// Results map
        /// </summary>
        /// <value>Results map</value>
        [DataMember(Name = "items", IsRequired = true, EmitDefaultValue = true)]
        public Object Items { get; set; }

        /// <summary>
        /// The mailbox flags.
        /// </summary>
        /// <value>The mailbox flags.</value>
        [DataMember(Name = "flags", IsRequired = true, EmitDefaultValue = true)]
        public List<string> Flags { get; set; }

        /// <summary>
        /// The mailbox permanent flags.
        /// </summary>
        /// <value>The mailbox permanent flags.</value>
        [DataMember(Name = "permanentFlags", IsRequired = true, EmitDefaultValue = true)]
        public List<string> PermanentFlags { get; set; }

        /// <summary>
        /// The sequence number of the first unseen message in the mailbox.
        /// </summary>
        /// <value>The sequence number of the first unseen message in the mailbox.</value>
        [DataMember(Name = "unseenSeqNum", IsRequired = true, EmitDefaultValue = true)]
        public long UnseenSeqNum { get; set; }

        /// <summary>
        /// The number of messages in this mailbox.
        /// </summary>
        /// <value>The number of messages in this mailbox.</value>
        [DataMember(Name = "messages", IsRequired = true, EmitDefaultValue = true)]
        public int Messages { get; set; }

        /// <summary>
        /// The number of messages not seen since the last time the mailbox was opened.
        /// </summary>
        /// <value>The number of messages not seen since the last time the mailbox was opened.</value>
        [DataMember(Name = "recent", IsRequired = true, EmitDefaultValue = true)]
        public int Recent { get; set; }

        /// <summary>
        /// The number of unread messages.
        /// </summary>
        /// <value>The number of unread messages.</value>
        [DataMember(Name = "unseen", IsRequired = true, EmitDefaultValue = true)]
        public int Unseen { get; set; }

        /// <summary>
        /// The next UID.
        /// </summary>
        /// <value>The next UID.</value>
        [DataMember(Name = "uidNext", IsRequired = true, EmitDefaultValue = true)]
        public long UidNext { get; set; }

        /// <summary>
        /// Together with a UID, it is a unique identifier for a message. Must be greater than or equal to 1.
        /// </summary>
        /// <value>Together with a UID, it is a unique identifier for a message. Must be greater than or equal to 1.</value>
        [DataMember(Name = "uidValidity", IsRequired = true, EmitDefaultValue = true)]
        public int UidValidity { get; set; }

        /// <summary>
        /// Per-mailbox limit of message size. Set only if server supports the APPENDLIMIT extension
        /// </summary>
        /// <value>Per-mailbox limit of message size. Set only if server supports the APPENDLIMIT extension</value>
        [DataMember(Name = "appendLimit", EmitDefaultValue = true)]
        public int? AppendLimit { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ImapMailboxStatus {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  ReadOnly: ").Append(ReadOnly).Append("\n");
            sb.Append("  Items: ").Append(Items).Append("\n");
            sb.Append("  Flags: ").Append(Flags).Append("\n");
            sb.Append("  PermanentFlags: ").Append(PermanentFlags).Append("\n");
            sb.Append("  UnseenSeqNum: ").Append(UnseenSeqNum).Append("\n");
            sb.Append("  Messages: ").Append(Messages).Append("\n");
            sb.Append("  Recent: ").Append(Recent).Append("\n");
            sb.Append("  Unseen: ").Append(Unseen).Append("\n");
            sb.Append("  UidNext: ").Append(UidNext).Append("\n");
            sb.Append("  UidValidity: ").Append(UidValidity).Append("\n");
            sb.Append("  AppendLimit: ").Append(AppendLimit).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ImapMailboxStatus);
        }

        /// <summary>
        /// Returns true if ImapMailboxStatus instances are equal
        /// </summary>
        /// <param name="input">Instance of ImapMailboxStatus to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ImapMailboxStatus input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.ReadOnly == input.ReadOnly ||
                    this.ReadOnly.Equals(input.ReadOnly)
                ) && 
                (
                    this.Items == input.Items ||
                    (this.Items != null &&
                    this.Items.Equals(input.Items))
                ) && 
                (
                    this.Flags == input.Flags ||
                    this.Flags != null &&
                    input.Flags != null &&
                    this.Flags.SequenceEqual(input.Flags)
                ) && 
                (
                    this.PermanentFlags == input.PermanentFlags ||
                    this.PermanentFlags != null &&
                    input.PermanentFlags != null &&
                    this.PermanentFlags.SequenceEqual(input.PermanentFlags)
                ) && 
                (
                    this.UnseenSeqNum == input.UnseenSeqNum ||
                    this.UnseenSeqNum.Equals(input.UnseenSeqNum)
                ) && 
                (
                    this.Messages == input.Messages ||
                    this.Messages.Equals(input.Messages)
                ) && 
                (
                    this.Recent == input.Recent ||
                    this.Recent.Equals(input.Recent)
                ) && 
                (
                    this.Unseen == input.Unseen ||
                    this.Unseen.Equals(input.Unseen)
                ) && 
                (
                    this.UidNext == input.UidNext ||
                    this.UidNext.Equals(input.UidNext)
                ) && 
                (
                    this.UidValidity == input.UidValidity ||
                    this.UidValidity.Equals(input.UidValidity)
                ) && 
                (
                    this.AppendLimit == input.AppendLimit ||
                    (this.AppendLimit != null &&
                    this.AppendLimit.Equals(input.AppendLimit))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.ReadOnly.GetHashCode();
                if (this.Items != null)
                {
                    hashCode = (hashCode * 59) + this.Items.GetHashCode();
                }
                if (this.Flags != null)
                {
                    hashCode = (hashCode * 59) + this.Flags.GetHashCode();
                }
                if (this.PermanentFlags != null)
                {
                    hashCode = (hashCode * 59) + this.PermanentFlags.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.UnseenSeqNum.GetHashCode();
                hashCode = (hashCode * 59) + this.Messages.GetHashCode();
                hashCode = (hashCode * 59) + this.Recent.GetHashCode();
                hashCode = (hashCode * 59) + this.Unseen.GetHashCode();
                hashCode = (hashCode * 59) + this.UidNext.GetHashCode();
                hashCode = (hashCode * 59) + this.UidValidity.GetHashCode();
                if (this.AppendLimit != null)
                {
                    hashCode = (hashCode * 59) + this.AppendLimit.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
