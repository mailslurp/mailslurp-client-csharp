/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = mailslurp.Client.OpenAPIDateConverter;

namespace mailslurp.Model
{
    /// <summary>
    /// SearchInboxesOptions
    /// </summary>
    [DataContract(Name = "SearchInboxesOptions")]
    public partial class SearchInboxesOptions : IEquatable<SearchInboxesOptions>, IValidatableObject
    {
        /// <summary>
        /// Optional createdAt sort direction ASC or DESC
        /// </summary>
        /// <value>Optional createdAt sort direction ASC or DESC</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum SortDirectionEnum
        {
            /// <summary>
            /// Enum ASC for value: ASC
            /// </summary>
            [EnumMember(Value = "ASC")]
            ASC = 1,

            /// <summary>
            /// Enum DESC for value: DESC
            /// </summary>
            [EnumMember(Value = "DESC")]
            DESC = 2

        }


        /// <summary>
        /// Optional createdAt sort direction ASC or DESC
        /// </summary>
        /// <value>Optional createdAt sort direction ASC or DESC</value>
        [DataMember(Name = "sortDirection", EmitDefaultValue = true)]
        public SortDirectionEnum? SortDirection { get; set; }
        /// <summary>
        /// Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).
        /// </summary>
        /// <value>Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum InboxTypeEnum
        {
            /// <summary>
            /// Enum HTTPINBOX for value: HTTP_INBOX
            /// </summary>
            [EnumMember(Value = "HTTP_INBOX")]
            HTTPINBOX = 1,

            /// <summary>
            /// Enum SMTPINBOX for value: SMTP_INBOX
            /// </summary>
            [EnumMember(Value = "SMTP_INBOX")]
            SMTPINBOX = 2

        }


        /// <summary>
        /// Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).
        /// </summary>
        /// <value>Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).</value>
        [DataMember(Name = "inboxType", EmitDefaultValue = true)]
        public InboxTypeEnum? InboxType { get; set; }
        /// <summary>
        /// Optional filter by inbox function
        /// </summary>
        /// <value>Optional filter by inbox function</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum InboxFunctionEnum
        {
            /// <summary>
            /// Enum ALIAS for value: ALIAS
            /// </summary>
            [EnumMember(Value = "ALIAS")]
            ALIAS = 1,

            /// <summary>
            /// Enum THREAD for value: THREAD
            /// </summary>
            [EnumMember(Value = "THREAD")]
            THREAD = 2,

            /// <summary>
            /// Enum CATCHALL for value: CATCH_ALL
            /// </summary>
            [EnumMember(Value = "CATCH_ALL")]
            CATCHALL = 3,

            /// <summary>
            /// Enum CONNECTOR for value: CONNECTOR
            /// </summary>
            [EnumMember(Value = "CONNECTOR")]
            CONNECTOR = 4

        }


        /// <summary>
        /// Optional filter by inbox function
        /// </summary>
        /// <value>Optional filter by inbox function</value>
        [DataMember(Name = "inboxFunction", EmitDefaultValue = true)]
        public InboxFunctionEnum? InboxFunction { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="SearchInboxesOptions" /> class.
        /// </summary>
        /// <param name="pageIndex">Optional page index in list pagination.</param>
        /// <param name="pageSize">Optional page size in list pagination.</param>
        /// <param name="sortDirection">Optional createdAt sort direction ASC or DESC.</param>
        /// <param name="favourite">Optionally filter results for favourites only.</param>
        /// <param name="search">Optionally filter by search words partial matching ID, tags, name, and email address.</param>
        /// <param name="tag">Optionally filter by tags. Will return inboxes that include given tags.</param>
        /// <param name="since">Optional filter by created after given date time.</param>
        /// <param name="before">Optional filter by created before given date time.</param>
        /// <param name="inboxType">Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send)..</param>
        /// <param name="inboxFunction">Optional filter by inbox function.</param>
        /// <param name="domainId">Optional domain ID filter.</param>
        public SearchInboxesOptions(int? pageIndex = default(int?), int? pageSize = default(int?), SortDirectionEnum? sortDirection = default(SortDirectionEnum?), bool? favourite = default(bool?), string search = default(string), string tag = default(string), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), InboxTypeEnum? inboxType = default(InboxTypeEnum?), InboxFunctionEnum? inboxFunction = default(InboxFunctionEnum?), Guid? domainId = default(Guid?))
        {
            this.PageIndex = pageIndex;
            this.PageSize = pageSize;
            this.SortDirection = sortDirection;
            this.Favourite = favourite;
            this.Search = search;
            this.Tag = tag;
            this.Since = since;
            this.Before = before;
            this.InboxType = inboxType;
            this.InboxFunction = inboxFunction;
            this.DomainId = domainId;
        }

        /// <summary>
        /// Optional page index in list pagination
        /// </summary>
        /// <value>Optional page index in list pagination</value>
        [DataMember(Name = "pageIndex", EmitDefaultValue = true)]
        public int? PageIndex { get; set; }

        /// <summary>
        /// Optional page size in list pagination
        /// </summary>
        /// <value>Optional page size in list pagination</value>
        [DataMember(Name = "pageSize", EmitDefaultValue = true)]
        public int? PageSize { get; set; }

        /// <summary>
        /// Optionally filter results for favourites only
        /// </summary>
        /// <value>Optionally filter results for favourites only</value>
        [DataMember(Name = "favourite", EmitDefaultValue = true)]
        public bool? Favourite { get; set; }

        /// <summary>
        /// Optionally filter by search words partial matching ID, tags, name, and email address
        /// </summary>
        /// <value>Optionally filter by search words partial matching ID, tags, name, and email address</value>
        [DataMember(Name = "search", EmitDefaultValue = true)]
        public string Search { get; set; }

        /// <summary>
        /// Optionally filter by tags. Will return inboxes that include given tags
        /// </summary>
        /// <value>Optionally filter by tags. Will return inboxes that include given tags</value>
        [DataMember(Name = "tag", EmitDefaultValue = true)]
        public string Tag { get; set; }

        /// <summary>
        /// Optional filter by created after given date time
        /// </summary>
        /// <value>Optional filter by created after given date time</value>
        [DataMember(Name = "since", EmitDefaultValue = true)]
        public DateTime? Since { get; set; }

        /// <summary>
        /// Optional filter by created before given date time
        /// </summary>
        /// <value>Optional filter by created before given date time</value>
        [DataMember(Name = "before", EmitDefaultValue = true)]
        public DateTime? Before { get; set; }

        /// <summary>
        /// Optional domain ID filter
        /// </summary>
        /// <value>Optional domain ID filter</value>
        [DataMember(Name = "domainId", EmitDefaultValue = true)]
        public Guid? DomainId { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class SearchInboxesOptions {\n");
            sb.Append("  PageIndex: ").Append(PageIndex).Append("\n");
            sb.Append("  PageSize: ").Append(PageSize).Append("\n");
            sb.Append("  SortDirection: ").Append(SortDirection).Append("\n");
            sb.Append("  Favourite: ").Append(Favourite).Append("\n");
            sb.Append("  Search: ").Append(Search).Append("\n");
            sb.Append("  Tag: ").Append(Tag).Append("\n");
            sb.Append("  Since: ").Append(Since).Append("\n");
            sb.Append("  Before: ").Append(Before).Append("\n");
            sb.Append("  InboxType: ").Append(InboxType).Append("\n");
            sb.Append("  InboxFunction: ").Append(InboxFunction).Append("\n");
            sb.Append("  DomainId: ").Append(DomainId).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as SearchInboxesOptions);
        }

        /// <summary>
        /// Returns true if SearchInboxesOptions instances are equal
        /// </summary>
        /// <param name="input">Instance of SearchInboxesOptions to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SearchInboxesOptions input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.PageIndex == input.PageIndex ||
                    (this.PageIndex != null &&
                    this.PageIndex.Equals(input.PageIndex))
                ) && 
                (
                    this.PageSize == input.PageSize ||
                    (this.PageSize != null &&
                    this.PageSize.Equals(input.PageSize))
                ) && 
                (
                    this.SortDirection == input.SortDirection ||
                    this.SortDirection.Equals(input.SortDirection)
                ) && 
                (
                    this.Favourite == input.Favourite ||
                    (this.Favourite != null &&
                    this.Favourite.Equals(input.Favourite))
                ) && 
                (
                    this.Search == input.Search ||
                    (this.Search != null &&
                    this.Search.Equals(input.Search))
                ) && 
                (
                    this.Tag == input.Tag ||
                    (this.Tag != null &&
                    this.Tag.Equals(input.Tag))
                ) && 
                (
                    this.Since == input.Since ||
                    (this.Since != null &&
                    this.Since.Equals(input.Since))
                ) && 
                (
                    this.Before == input.Before ||
                    (this.Before != null &&
                    this.Before.Equals(input.Before))
                ) && 
                (
                    this.InboxType == input.InboxType ||
                    this.InboxType.Equals(input.InboxType)
                ) && 
                (
                    this.InboxFunction == input.InboxFunction ||
                    this.InboxFunction.Equals(input.InboxFunction)
                ) && 
                (
                    this.DomainId == input.DomainId ||
                    (this.DomainId != null &&
                    this.DomainId.Equals(input.DomainId))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.PageIndex != null)
                {
                    hashCode = (hashCode * 59) + this.PageIndex.GetHashCode();
                }
                if (this.PageSize != null)
                {
                    hashCode = (hashCode * 59) + this.PageSize.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.SortDirection.GetHashCode();
                if (this.Favourite != null)
                {
                    hashCode = (hashCode * 59) + this.Favourite.GetHashCode();
                }
                if (this.Search != null)
                {
                    hashCode = (hashCode * 59) + this.Search.GetHashCode();
                }
                if (this.Tag != null)
                {
                    hashCode = (hashCode * 59) + this.Tag.GetHashCode();
                }
                if (this.Since != null)
                {
                    hashCode = (hashCode * 59) + this.Since.GetHashCode();
                }
                if (this.Before != null)
                {
                    hashCode = (hashCode * 59) + this.Before.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.InboxType.GetHashCode();
                hashCode = (hashCode * 59) + this.InboxFunction.GetHashCode();
                if (this.DomainId != null)
                {
                    hashCode = (hashCode * 59) + this.DomainId.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
