// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using mailslurp.Client;

namespace mailslurp.Model
{
    /// <summary>
    /// Options for matching emails in an inbox. Each match option object contains a &#x60;field&#x60;, &#x60;should&#x60; and &#x60;value&#x60; property. Together they form logical conditions such as &#x60;SUBJECT&#x60; should &#x60;CONTAIN&#x60; value.
    /// </summary>
    public partial class MatchOption : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MatchOption" /> class.
        /// </summary>
        /// <param name="field">Fields of an email object that can be used to filter results</param>
        /// <param name="should">How the value of the email field specified should be compared to the value given in the match options.</param>
        /// <param name="value">The value you wish to compare with the value of the field specified using the &#x60;should&#x60; value passed. For example &#x60;BODY&#x60; should &#x60;CONTAIN&#x60; a value passed.</param>
        [JsonConstructor]
        public MatchOption(FieldEnum field, ShouldEnum should, string value)
        {
            Field = field;
            Should = should;
            Value = value;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Fields of an email object that can be used to filter results
        /// </summary>
        /// <value>Fields of an email object that can be used to filter results</value>
        public enum FieldEnum
        {
            /// <summary>
            /// Enum SUBJECT for value: SUBJECT
            /// </summary>
            SUBJECT = 1,

            /// <summary>
            /// Enum TO for value: TO
            /// </summary>
            TO = 2,

            /// <summary>
            /// Enum BCC for value: BCC
            /// </summary>
            BCC = 3,

            /// <summary>
            /// Enum CC for value: CC
            /// </summary>
            CC = 4,

            /// <summary>
            /// Enum FROM for value: FROM
            /// </summary>
            FROM = 5,

            /// <summary>
            /// Enum HEADERS for value: HEADERS
            /// </summary>
            HEADERS = 6
        }

        /// <summary>
        /// Returns a <see cref="FieldEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static FieldEnum FieldEnumFromString(string value)
        {
            if (value.Equals("SUBJECT"))
                return FieldEnum.SUBJECT;

            if (value.Equals("TO"))
                return FieldEnum.TO;

            if (value.Equals("BCC"))
                return FieldEnum.BCC;

            if (value.Equals("CC"))
                return FieldEnum.CC;

            if (value.Equals("FROM"))
                return FieldEnum.FROM;

            if (value.Equals("HEADERS"))
                return FieldEnum.HEADERS;

            throw new NotImplementedException($"Could not convert value to type FieldEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="FieldEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static FieldEnum? FieldEnumFromStringOrDefault(string value)
        {
            if (value.Equals("SUBJECT"))
                return FieldEnum.SUBJECT;

            if (value.Equals("TO"))
                return FieldEnum.TO;

            if (value.Equals("BCC"))
                return FieldEnum.BCC;

            if (value.Equals("CC"))
                return FieldEnum.CC;

            if (value.Equals("FROM"))
                return FieldEnum.FROM;

            if (value.Equals("HEADERS"))
                return FieldEnum.HEADERS;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="FieldEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string FieldEnumToJsonValue(FieldEnum value)
        {
            if (value == FieldEnum.SUBJECT)
                return "SUBJECT";

            if (value == FieldEnum.TO)
                return "TO";

            if (value == FieldEnum.BCC)
                return "BCC";

            if (value == FieldEnum.CC)
                return "CC";

            if (value == FieldEnum.FROM)
                return "FROM";

            if (value == FieldEnum.HEADERS)
                return "HEADERS";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Fields of an email object that can be used to filter results
        /// </summary>
        /// <value>Fields of an email object that can be used to filter results</value>
        [JsonPropertyName("field")]
        public FieldEnum Field { get; set; }

        /// <summary>
        /// How the value of the email field specified should be compared to the value given in the match options.
        /// </summary>
        /// <value>How the value of the email field specified should be compared to the value given in the match options.</value>
        public enum ShouldEnum
        {
            /// <summary>
            /// Enum MATCH for value: MATCH
            /// </summary>
            MATCH = 1,

            /// <summary>
            /// Enum CONTAIN for value: CONTAIN
            /// </summary>
            CONTAIN = 2,

            /// <summary>
            /// Enum EQUAL for value: EQUAL
            /// </summary>
            EQUAL = 3
        }

        /// <summary>
        /// Returns a <see cref="ShouldEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static ShouldEnum ShouldEnumFromString(string value)
        {
            if (value.Equals("MATCH"))
                return ShouldEnum.MATCH;

            if (value.Equals("CONTAIN"))
                return ShouldEnum.CONTAIN;

            if (value.Equals("EQUAL"))
                return ShouldEnum.EQUAL;

            throw new NotImplementedException($"Could not convert value to type ShouldEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="ShouldEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static ShouldEnum? ShouldEnumFromStringOrDefault(string value)
        {
            if (value.Equals("MATCH"))
                return ShouldEnum.MATCH;

            if (value.Equals("CONTAIN"))
                return ShouldEnum.CONTAIN;

            if (value.Equals("EQUAL"))
                return ShouldEnum.EQUAL;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="ShouldEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string ShouldEnumToJsonValue(ShouldEnum value)
        {
            if (value == ShouldEnum.MATCH)
                return "MATCH";

            if (value == ShouldEnum.CONTAIN)
                return "CONTAIN";

            if (value == ShouldEnum.EQUAL)
                return "EQUAL";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// How the value of the email field specified should be compared to the value given in the match options.
        /// </summary>
        /// <value>How the value of the email field specified should be compared to the value given in the match options.</value>
        [JsonPropertyName("should")]
        public ShouldEnum Should { get; set; }

        /// <summary>
        /// The value you wish to compare with the value of the field specified using the &#x60;should&#x60; value passed. For example &#x60;BODY&#x60; should &#x60;CONTAIN&#x60; a value passed.
        /// </summary>
        /// <value>The value you wish to compare with the value of the field specified using the &#x60;should&#x60; value passed. For example &#x60;BODY&#x60; should &#x60;CONTAIN&#x60; a value passed.</value>
        [JsonPropertyName("value")]
        public string Value { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class MatchOption {\n");
            sb.Append("  Field: ").Append(Field).Append("\n");
            sb.Append("  Should: ").Append(Should).Append("\n");
            sb.Append("  Value: ").Append(Value).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="MatchOption" />
    /// </summary>
    public class MatchOptionJsonConverter : JsonConverter<MatchOption>
    {
        /// <summary>
        /// Deserializes json to <see cref="MatchOption" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override MatchOption Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<MatchOption.FieldEnum?> field = default;
            Option<MatchOption.ShouldEnum?> should = default;
            Option<string> value = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "field":
                            string fieldRawValue = utf8JsonReader.GetString();
                            if (fieldRawValue != null)
                                field = new Option<MatchOption.FieldEnum?>(MatchOption.FieldEnumFromStringOrDefault(fieldRawValue));
                            break;
                        case "should":
                            string shouldRawValue = utf8JsonReader.GetString();
                            if (shouldRawValue != null)
                                should = new Option<MatchOption.ShouldEnum?>(MatchOption.ShouldEnumFromStringOrDefault(shouldRawValue));
                            break;
                        case "value":
                            value = new Option<string>(utf8JsonReader.GetString());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!field.IsSet)
                throw new ArgumentException("Property is required for class MatchOption.", nameof(field));

            if (!should.IsSet)
                throw new ArgumentException("Property is required for class MatchOption.", nameof(should));

            if (!value.IsSet)
                throw new ArgumentException("Property is required for class MatchOption.", nameof(value));

            if (field.IsSet && field.Value == null)
                throw new ArgumentNullException(nameof(field), "Property is not nullable for class MatchOption.");

            if (should.IsSet && should.Value == null)
                throw new ArgumentNullException(nameof(should), "Property is not nullable for class MatchOption.");

            if (value.IsSet && value.Value == null)
                throw new ArgumentNullException(nameof(value), "Property is not nullable for class MatchOption.");

            return new MatchOption(field.Value.Value, should.Value.Value, value.Value);
        }

        /// <summary>
        /// Serializes a <see cref="MatchOption" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="matchOption"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, MatchOption matchOption, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, matchOption, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="MatchOption" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="matchOption"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, MatchOption matchOption, JsonSerializerOptions jsonSerializerOptions)
        {
            if (matchOption.Value == null)
                throw new ArgumentNullException(nameof(matchOption.Value), "Property is required for class MatchOption.");

            var fieldRawValue = MatchOption.FieldEnumToJsonValue(matchOption.Field);
            writer.WriteString("field", fieldRawValue);
            var shouldRawValue = MatchOption.ShouldEnumToJsonValue(matchOption.Should);
            writer.WriteString("should", shouldRawValue);
            writer.WriteString("value", matchOption.Value);
        }
    }
}
