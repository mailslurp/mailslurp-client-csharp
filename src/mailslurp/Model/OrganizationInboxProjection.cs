// <auto-generated>
/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using mailslurp.Client;

namespace mailslurp.Model
{
    /// <summary>
    /// Organization team inbox
    /// </summary>
    public partial class OrganizationInboxProjection : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OrganizationInboxProjection" /> class.
        /// </summary>
        /// <param name="id">ID of the inbox. The ID is a UUID-V4 format string. Use the inboxId for calls to Inbox and Email Controller endpoints. See the emailAddress property for the email address or the inbox. To get emails in an inbox use the WaitFor and Inbox Controller methods &#x60;waitForLatestEmail&#x60; and &#x60;getEmails&#x60; methods respectively. Inboxes can be used with aliases to forward emails automatically.</param>
        /// <param name="createdAt">When the inbox was created. Time stamps are in ISO DateTime Format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX&#x60; e.g. &#x60;2000-10-31T01:30:00.000-05:00&#x60;.</param>
        /// <param name="favourite">Is the inbox a favorite inbox. Make an inbox a favorite is typically done in the dashboard for quick access or filtering</param>
        /// <param name="teamAccess">Does inbox permit team access for organization team members. If so team users can use inbox and emails associated with it. See the team access guide at https://www.mailslurp.com/guides/team-email-account-sharing/</param>
        /// <param name="readOnly">Is the inbox readOnly for the caller. Read only means can not be deleted or modified. This flag is present when using team accounts and shared inboxes.</param>
        /// <param name="virtualInbox">Virtual inbox can receive email but will not send emails to real recipients. Will save sent email record but never send an actual email. Perfect for testing mail server actions.</param>
        /// <param name="userId">ID of user that inbox belongs to</param>
        /// <param name="domainId">ID of custom domain used by the inbox if any</param>
        /// <param name="name">Name of the inbox and used as the sender name when sending emails .Displayed in the dashboard for easier search</param>
        /// <param name="emailAddress">The inbox&#39;s email address. Inbox projections and previews may not include the email address. To view the email address fetch the inbox entity directly. Send an email to this address and the inbox will receive and store it for you. Note the email address in MailSlurp match characters exactly and are case sensitive so &#x60;+123&#x60; additions are considered different addresses. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.</param>
        /// <param name="tags">Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.</param>
        /// <param name="inboxType">Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).</param>
        /// <param name="functionsAs">Inbox function if used as a primitive for another system.</param>
        /// <param name="description">Description of an inbox for labelling and searching purposes</param>
        /// <param name="expiresAt">Inbox expiration time. When, if ever, the inbox should expire and be deleted. If null then this inbox is permanent and the emails in it won&#39;t be deleted. This is the default behavior unless expiration date is set. If an expiration date is set and the time is reached MailSlurp will expire the inbox and move it to an expired inbox entity. You can still access the emails belonging to it but it can no longer send or receive email.</param>
        /// <param name="accountRegion">Region of the inbox</param>
        [JsonConstructor]
        public OrganizationInboxProjection(Guid id, DateTime createdAt, bool favourite, bool teamAccess, bool readOnly, bool virtualInbox, Guid userId, Option<Guid?> domainId = default, Option<string> name = default, string emailAddress = default, Option<List<string>> tags = default, Option<InboxTypeEnum?> inboxType = default, Option<FunctionsAsEnum?> functionsAs = default, Option<string> description = default, Option<DateTime?> expiresAt = default, Option<AccountRegionEnum?> accountRegion = default)
        {
            Id = id;
            CreatedAt = createdAt;
            Favourite = favourite;
            TeamAccess = teamAccess;
            ReadOnly = readOnly;
            VirtualInbox = virtualInbox;
            UserId = userId;
            DomainIdOption = domainId;
            NameOption = name;
            EmailAddress = emailAddress;
            TagsOption = tags;
            InboxTypeOption = inboxType;
            FunctionsAsOption = functionsAs;
            DescriptionOption = description;
            ExpiresAtOption = expiresAt;
            AccountRegionOption = accountRegion;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).
        /// </summary>
        /// <value>Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).</value>
        public enum InboxTypeEnum
        {
            /// <summary>
            /// Enum HTTPINBOX for value: HTTP_INBOX
            /// </summary>
            HTTPINBOX = 1,

            /// <summary>
            /// Enum SMTPINBOX for value: SMTP_INBOX
            /// </summary>
            SMTPINBOX = 2
        }

        /// <summary>
        /// Returns a <see cref="InboxTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static InboxTypeEnum InboxTypeEnumFromString(string value)
        {
            if (value.Equals("HTTP_INBOX"))
                return InboxTypeEnum.HTTPINBOX;

            if (value.Equals("SMTP_INBOX"))
                return InboxTypeEnum.SMTPINBOX;

            throw new NotImplementedException($"Could not convert value to type InboxTypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="InboxTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static InboxTypeEnum? InboxTypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("HTTP_INBOX"))
                return InboxTypeEnum.HTTPINBOX;

            if (value.Equals("SMTP_INBOX"))
                return InboxTypeEnum.SMTPINBOX;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="InboxTypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string InboxTypeEnumToJsonValue(InboxTypeEnum? value)
        {
            if (value == null)
                return null;

            if (value == InboxTypeEnum.HTTPINBOX)
                return "HTTP_INBOX";

            if (value == InboxTypeEnum.SMTPINBOX)
                return "SMTP_INBOX";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of InboxType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<InboxTypeEnum?> InboxTypeOption { get; private set; }

        /// <summary>
        /// Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).
        /// </summary>
        /// <value>Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).</value>
        [JsonPropertyName("inboxType")]
        public InboxTypeEnum? InboxType { get { return this.InboxTypeOption; } set { this.InboxTypeOption = new Option<InboxTypeEnum?>(value); } }

        /// <summary>
        /// Inbox function if used as a primitive for another system.
        /// </summary>
        /// <value>Inbox function if used as a primitive for another system.</value>
        public enum FunctionsAsEnum
        {
            /// <summary>
            /// Enum ALIAS for value: ALIAS
            /// </summary>
            ALIAS = 1,

            /// <summary>
            /// Enum THREAD for value: THREAD
            /// </summary>
            THREAD = 2,

            /// <summary>
            /// Enum CATCHALL for value: CATCH_ALL
            /// </summary>
            CATCHALL = 3,

            /// <summary>
            /// Enum CONNECTOR for value: CONNECTOR
            /// </summary>
            CONNECTOR = 4,

            /// <summary>
            /// Enum ACCOUNT for value: ACCOUNT
            /// </summary>
            ACCOUNT = 5,

            /// <summary>
            /// Enum GUEST for value: GUEST
            /// </summary>
            GUEST = 6,

            /// <summary>
            /// Enum OAUTHCONNECTIONGMAIL for value: OAUTH_CONNECTION_GMAIL
            /// </summary>
            OAUTHCONNECTIONGMAIL = 7
        }

        /// <summary>
        /// Returns a <see cref="FunctionsAsEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static FunctionsAsEnum FunctionsAsEnumFromString(string value)
        {
            if (value.Equals("ALIAS"))
                return FunctionsAsEnum.ALIAS;

            if (value.Equals("THREAD"))
                return FunctionsAsEnum.THREAD;

            if (value.Equals("CATCH_ALL"))
                return FunctionsAsEnum.CATCHALL;

            if (value.Equals("CONNECTOR"))
                return FunctionsAsEnum.CONNECTOR;

            if (value.Equals("ACCOUNT"))
                return FunctionsAsEnum.ACCOUNT;

            if (value.Equals("GUEST"))
                return FunctionsAsEnum.GUEST;

            if (value.Equals("OAUTH_CONNECTION_GMAIL"))
                return FunctionsAsEnum.OAUTHCONNECTIONGMAIL;

            throw new NotImplementedException($"Could not convert value to type FunctionsAsEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="FunctionsAsEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static FunctionsAsEnum? FunctionsAsEnumFromStringOrDefault(string value)
        {
            if (value.Equals("ALIAS"))
                return FunctionsAsEnum.ALIAS;

            if (value.Equals("THREAD"))
                return FunctionsAsEnum.THREAD;

            if (value.Equals("CATCH_ALL"))
                return FunctionsAsEnum.CATCHALL;

            if (value.Equals("CONNECTOR"))
                return FunctionsAsEnum.CONNECTOR;

            if (value.Equals("ACCOUNT"))
                return FunctionsAsEnum.ACCOUNT;

            if (value.Equals("GUEST"))
                return FunctionsAsEnum.GUEST;

            if (value.Equals("OAUTH_CONNECTION_GMAIL"))
                return FunctionsAsEnum.OAUTHCONNECTIONGMAIL;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="FunctionsAsEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string FunctionsAsEnumToJsonValue(FunctionsAsEnum? value)
        {
            if (value == null)
                return null;

            if (value == FunctionsAsEnum.ALIAS)
                return "ALIAS";

            if (value == FunctionsAsEnum.THREAD)
                return "THREAD";

            if (value == FunctionsAsEnum.CATCHALL)
                return "CATCH_ALL";

            if (value == FunctionsAsEnum.CONNECTOR)
                return "CONNECTOR";

            if (value == FunctionsAsEnum.ACCOUNT)
                return "ACCOUNT";

            if (value == FunctionsAsEnum.GUEST)
                return "GUEST";

            if (value == FunctionsAsEnum.OAUTHCONNECTIONGMAIL)
                return "OAUTH_CONNECTION_GMAIL";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of FunctionsAs
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<FunctionsAsEnum?> FunctionsAsOption { get; private set; }

        /// <summary>
        /// Inbox function if used as a primitive for another system.
        /// </summary>
        /// <value>Inbox function if used as a primitive for another system.</value>
        [JsonPropertyName("functionsAs")]
        public FunctionsAsEnum? FunctionsAs { get { return this.FunctionsAsOption; } set { this.FunctionsAsOption = new Option<FunctionsAsEnum?>(value); } }

        /// <summary>
        /// Region of the inbox
        /// </summary>
        /// <value>Region of the inbox</value>
        public enum AccountRegionEnum
        {
            /// <summary>
            /// Enum USWEST2 for value: US_WEST_2
            /// </summary>
            USWEST2 = 1
        }

        /// <summary>
        /// Returns a <see cref="AccountRegionEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static AccountRegionEnum AccountRegionEnumFromString(string value)
        {
            if (value.Equals("US_WEST_2"))
                return AccountRegionEnum.USWEST2;

            throw new NotImplementedException($"Could not convert value to type AccountRegionEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="AccountRegionEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static AccountRegionEnum? AccountRegionEnumFromStringOrDefault(string value)
        {
            if (value.Equals("US_WEST_2"))
                return AccountRegionEnum.USWEST2;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="AccountRegionEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string AccountRegionEnumToJsonValue(AccountRegionEnum? value)
        {
            if (value == null)
                return null;

            if (value == AccountRegionEnum.USWEST2)
                return "US_WEST_2";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of AccountRegion
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AccountRegionEnum?> AccountRegionOption { get; private set; }

        /// <summary>
        /// Region of the inbox
        /// </summary>
        /// <value>Region of the inbox</value>
        [JsonPropertyName("accountRegion")]
        public AccountRegionEnum? AccountRegion { get { return this.AccountRegionOption; } set { this.AccountRegionOption = new Option<AccountRegionEnum?>(value); } }

        /// <summary>
        /// ID of the inbox. The ID is a UUID-V4 format string. Use the inboxId for calls to Inbox and Email Controller endpoints. See the emailAddress property for the email address or the inbox. To get emails in an inbox use the WaitFor and Inbox Controller methods &#x60;waitForLatestEmail&#x60; and &#x60;getEmails&#x60; methods respectively. Inboxes can be used with aliases to forward emails automatically.
        /// </summary>
        /// <value>ID of the inbox. The ID is a UUID-V4 format string. Use the inboxId for calls to Inbox and Email Controller endpoints. See the emailAddress property for the email address or the inbox. To get emails in an inbox use the WaitFor and Inbox Controller methods &#x60;waitForLatestEmail&#x60; and &#x60;getEmails&#x60; methods respectively. Inboxes can be used with aliases to forward emails automatically.</value>
        [JsonPropertyName("id")]
        public Guid Id { get; set; }

        /// <summary>
        /// When the inbox was created. Time stamps are in ISO DateTime Format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX&#x60; e.g. &#x60;2000-10-31T01:30:00.000-05:00&#x60;.
        /// </summary>
        /// <value>When the inbox was created. Time stamps are in ISO DateTime Format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX&#x60; e.g. &#x60;2000-10-31T01:30:00.000-05:00&#x60;.</value>
        [JsonPropertyName("createdAt")]
        public DateTime CreatedAt { get; set; }

        /// <summary>
        /// Is the inbox a favorite inbox. Make an inbox a favorite is typically done in the dashboard for quick access or filtering
        /// </summary>
        /// <value>Is the inbox a favorite inbox. Make an inbox a favorite is typically done in the dashboard for quick access or filtering</value>
        [JsonPropertyName("favourite")]
        public bool Favourite { get; set; }

        /// <summary>
        /// Does inbox permit team access for organization team members. If so team users can use inbox and emails associated with it. See the team access guide at https://www.mailslurp.com/guides/team-email-account-sharing/
        /// </summary>
        /// <value>Does inbox permit team access for organization team members. If so team users can use inbox and emails associated with it. See the team access guide at https://www.mailslurp.com/guides/team-email-account-sharing/</value>
        [JsonPropertyName("teamAccess")]
        public bool TeamAccess { get; set; }

        /// <summary>
        /// Is the inbox readOnly for the caller. Read only means can not be deleted or modified. This flag is present when using team accounts and shared inboxes.
        /// </summary>
        /// <value>Is the inbox readOnly for the caller. Read only means can not be deleted or modified. This flag is present when using team accounts and shared inboxes.</value>
        [JsonPropertyName("readOnly")]
        public bool ReadOnly { get; set; }

        /// <summary>
        /// Virtual inbox can receive email but will not send emails to real recipients. Will save sent email record but never send an actual email. Perfect for testing mail server actions.
        /// </summary>
        /// <value>Virtual inbox can receive email but will not send emails to real recipients. Will save sent email record but never send an actual email. Perfect for testing mail server actions.</value>
        [JsonPropertyName("virtualInbox")]
        public bool VirtualInbox { get; set; }

        /// <summary>
        /// ID of user that inbox belongs to
        /// </summary>
        /// <value>ID of user that inbox belongs to</value>
        [JsonPropertyName("userId")]
        public Guid UserId { get; set; }

        /// <summary>
        /// Used to track the state of DomainId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Guid?> DomainIdOption { get; private set; }

        /// <summary>
        /// ID of custom domain used by the inbox if any
        /// </summary>
        /// <value>ID of custom domain used by the inbox if any</value>
        [JsonPropertyName("domainId")]
        public Guid? DomainId { get { return this.DomainIdOption; } set { this.DomainIdOption = new Option<Guid?>(value); } }

        /// <summary>
        /// Used to track the state of Name
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> NameOption { get; private set; }

        /// <summary>
        /// Name of the inbox and used as the sender name when sending emails .Displayed in the dashboard for easier search
        /// </summary>
        /// <value>Name of the inbox and used as the sender name when sending emails .Displayed in the dashboard for easier search</value>
        [JsonPropertyName("name")]
        public string Name { get { return this.NameOption; } set { this.NameOption = new Option<string>(value); } }

        /// <summary>
        /// The inbox&#39;s email address. Inbox projections and previews may not include the email address. To view the email address fetch the inbox entity directly. Send an email to this address and the inbox will receive and store it for you. Note the email address in MailSlurp match characters exactly and are case sensitive so &#x60;+123&#x60; additions are considered different addresses. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.
        /// </summary>
        /// <value>The inbox&#39;s email address. Inbox projections and previews may not include the email address. To view the email address fetch the inbox entity directly. Send an email to this address and the inbox will receive and store it for you. Note the email address in MailSlurp match characters exactly and are case sensitive so &#x60;+123&#x60; additions are considered different addresses. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.</value>
        [JsonPropertyName("emailAddress")]
        public string EmailAddress { get; set; }

        /// <summary>
        /// Used to track the state of Tags
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>> TagsOption { get; private set; }

        /// <summary>
        /// Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
        /// </summary>
        /// <value>Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.</value>
        [JsonPropertyName("tags")]
        public List<string> Tags { get { return this.TagsOption; } set { this.TagsOption = new Option<List<string>>(value); } }

        /// <summary>
        /// Used to track the state of Description
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> DescriptionOption { get; private set; }

        /// <summary>
        /// Description of an inbox for labelling and searching purposes
        /// </summary>
        /// <value>Description of an inbox for labelling and searching purposes</value>
        [JsonPropertyName("description")]
        public string Description { get { return this.DescriptionOption; } set { this.DescriptionOption = new Option<string>(value); } }

        /// <summary>
        /// Used to track the state of ExpiresAt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> ExpiresAtOption { get; private set; }

        /// <summary>
        /// Inbox expiration time. When, if ever, the inbox should expire and be deleted. If null then this inbox is permanent and the emails in it won&#39;t be deleted. This is the default behavior unless expiration date is set. If an expiration date is set and the time is reached MailSlurp will expire the inbox and move it to an expired inbox entity. You can still access the emails belonging to it but it can no longer send or receive email.
        /// </summary>
        /// <value>Inbox expiration time. When, if ever, the inbox should expire and be deleted. If null then this inbox is permanent and the emails in it won&#39;t be deleted. This is the default behavior unless expiration date is set. If an expiration date is set and the time is reached MailSlurp will expire the inbox and move it to an expired inbox entity. You can still access the emails belonging to it but it can no longer send or receive email.</value>
        [JsonPropertyName("expiresAt")]
        public DateTime? ExpiresAt { get { return this.ExpiresAtOption; } set { this.ExpiresAtOption = new Option<DateTime?>(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class OrganizationInboxProjection {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  Favourite: ").Append(Favourite).Append("\n");
            sb.Append("  TeamAccess: ").Append(TeamAccess).Append("\n");
            sb.Append("  ReadOnly: ").Append(ReadOnly).Append("\n");
            sb.Append("  VirtualInbox: ").Append(VirtualInbox).Append("\n");
            sb.Append("  UserId: ").Append(UserId).Append("\n");
            sb.Append("  DomainId: ").Append(DomainId).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  EmailAddress: ").Append(EmailAddress).Append("\n");
            sb.Append("  Tags: ").Append(Tags).Append("\n");
            sb.Append("  InboxType: ").Append(InboxType).Append("\n");
            sb.Append("  FunctionsAs: ").Append(FunctionsAs).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  ExpiresAt: ").Append(ExpiresAt).Append("\n");
            sb.Append("  AccountRegion: ").Append(AccountRegion).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="OrganizationInboxProjection" />
    /// </summary>
    public class OrganizationInboxProjectionJsonConverter : JsonConverter<OrganizationInboxProjection>
    {
        /// <summary>
        /// The format to use to serialize CreatedAt
        /// </summary>
        public static string CreatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize ExpiresAt
        /// </summary>
        public static string ExpiresAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="OrganizationInboxProjection" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override OrganizationInboxProjection Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<Guid?> id = default;
            Option<DateTime?> createdAt = default;
            Option<bool?> favourite = default;
            Option<bool?> teamAccess = default;
            Option<bool?> readOnly = default;
            Option<bool?> virtualInbox = default;
            Option<Guid?> userId = default;
            Option<Guid?> domainId = default;
            Option<string> name = default;
            Option<string> emailAddress = default;
            Option<List<string>> tags = default;
            Option<OrganizationInboxProjection.InboxTypeEnum?> inboxType = default;
            Option<OrganizationInboxProjection.FunctionsAsEnum?> functionsAs = default;
            Option<string> description = default;
            Option<DateTime?> expiresAt = default;
            Option<OrganizationInboxProjection.AccountRegionEnum?> accountRegion = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "id":
                            id = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "createdAt":
                            createdAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "favourite":
                            favourite = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "teamAccess":
                            teamAccess = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "readOnly":
                            readOnly = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "virtualInbox":
                            virtualInbox = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "userId":
                            userId = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "domainId":
                            domainId = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "name":
                            name = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "emailAddress":
                            emailAddress = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "tags":
                            tags = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "inboxType":
                            string inboxTypeRawValue = utf8JsonReader.GetString();
                            if (inboxTypeRawValue != null)
                                inboxType = new Option<OrganizationInboxProjection.InboxTypeEnum?>(OrganizationInboxProjection.InboxTypeEnumFromStringOrDefault(inboxTypeRawValue));
                            break;
                        case "functionsAs":
                            string functionsAsRawValue = utf8JsonReader.GetString();
                            if (functionsAsRawValue != null)
                                functionsAs = new Option<OrganizationInboxProjection.FunctionsAsEnum?>(OrganizationInboxProjection.FunctionsAsEnumFromStringOrDefault(functionsAsRawValue));
                            break;
                        case "description":
                            description = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "expiresAt":
                            expiresAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime?>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "accountRegion":
                            string accountRegionRawValue = utf8JsonReader.GetString();
                            if (accountRegionRawValue != null)
                                accountRegion = new Option<OrganizationInboxProjection.AccountRegionEnum?>(OrganizationInboxProjection.AccountRegionEnumFromStringOrDefault(accountRegionRawValue));
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class OrganizationInboxProjection.", nameof(id));

            if (!createdAt.IsSet)
                throw new ArgumentException("Property is required for class OrganizationInboxProjection.", nameof(createdAt));

            if (!favourite.IsSet)
                throw new ArgumentException("Property is required for class OrganizationInboxProjection.", nameof(favourite));

            if (!teamAccess.IsSet)
                throw new ArgumentException("Property is required for class OrganizationInboxProjection.", nameof(teamAccess));

            if (!readOnly.IsSet)
                throw new ArgumentException("Property is required for class OrganizationInboxProjection.", nameof(readOnly));

            if (!virtualInbox.IsSet)
                throw new ArgumentException("Property is required for class OrganizationInboxProjection.", nameof(virtualInbox));

            if (!userId.IsSet)
                throw new ArgumentException("Property is required for class OrganizationInboxProjection.", nameof(userId));

            if (!emailAddress.IsSet)
                throw new ArgumentException("Property is required for class OrganizationInboxProjection.", nameof(emailAddress));

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class OrganizationInboxProjection.");

            if (createdAt.IsSet && createdAt.Value == null)
                throw new ArgumentNullException(nameof(createdAt), "Property is not nullable for class OrganizationInboxProjection.");

            if (favourite.IsSet && favourite.Value == null)
                throw new ArgumentNullException(nameof(favourite), "Property is not nullable for class OrganizationInboxProjection.");

            if (teamAccess.IsSet && teamAccess.Value == null)
                throw new ArgumentNullException(nameof(teamAccess), "Property is not nullable for class OrganizationInboxProjection.");

            if (readOnly.IsSet && readOnly.Value == null)
                throw new ArgumentNullException(nameof(readOnly), "Property is not nullable for class OrganizationInboxProjection.");

            if (virtualInbox.IsSet && virtualInbox.Value == null)
                throw new ArgumentNullException(nameof(virtualInbox), "Property is not nullable for class OrganizationInboxProjection.");

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId), "Property is not nullable for class OrganizationInboxProjection.");

            return new OrganizationInboxProjection(id.Value.Value, createdAt.Value.Value, favourite.Value.Value, teamAccess.Value.Value, readOnly.Value.Value, virtualInbox.Value.Value, userId.Value.Value, domainId, name, emailAddress.Value, tags, inboxType, functionsAs, description, expiresAt, accountRegion);
        }

        /// <summary>
        /// Serializes a <see cref="OrganizationInboxProjection" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="organizationInboxProjection"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, OrganizationInboxProjection organizationInboxProjection, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, organizationInboxProjection, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="OrganizationInboxProjection" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="organizationInboxProjection"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, OrganizationInboxProjection organizationInboxProjection, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteString("id", organizationInboxProjection.Id);

            writer.WriteString("createdAt", organizationInboxProjection.CreatedAt.ToString(CreatedAtFormat));

            writer.WriteBoolean("favourite", organizationInboxProjection.Favourite);

            writer.WriteBoolean("teamAccess", organizationInboxProjection.TeamAccess);

            writer.WriteBoolean("readOnly", organizationInboxProjection.ReadOnly);

            writer.WriteBoolean("virtualInbox", organizationInboxProjection.VirtualInbox);

            writer.WriteString("userId", organizationInboxProjection.UserId);

            if (organizationInboxProjection.DomainIdOption.IsSet)
                if (organizationInboxProjection.DomainIdOption.Value != null)
                    writer.WriteString("domainId", organizationInboxProjection.DomainIdOption.Value.Value);
                else
                    writer.WriteNull("domainId");

            if (organizationInboxProjection.NameOption.IsSet)
                if (organizationInboxProjection.NameOption.Value != null)
                    writer.WriteString("name", organizationInboxProjection.Name);
                else
                    writer.WriteNull("name");

            if (organizationInboxProjection.EmailAddress != null)
                writer.WriteString("emailAddress", organizationInboxProjection.EmailAddress);
            else
                writer.WriteNull("emailAddress");

            if (organizationInboxProjection.TagsOption.IsSet)
                if (organizationInboxProjection.TagsOption.Value != null)
                {
                    writer.WritePropertyName("tags");
                    JsonSerializer.Serialize(writer, organizationInboxProjection.Tags, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("tags");
            var inboxTypeRawValue = OrganizationInboxProjection.InboxTypeEnumToJsonValue(organizationInboxProjection.InboxTypeOption.Value.Value);
            if (inboxTypeRawValue != null)
                writer.WriteString("inboxType", inboxTypeRawValue);
            else
                writer.WriteNull("inboxType");

            var functionsAsRawValue = OrganizationInboxProjection.FunctionsAsEnumToJsonValue(organizationInboxProjection.FunctionsAsOption.Value.Value);
            if (functionsAsRawValue != null)
                writer.WriteString("functionsAs", functionsAsRawValue);
            else
                writer.WriteNull("functionsAs");

            if (organizationInboxProjection.DescriptionOption.IsSet)
                if (organizationInboxProjection.DescriptionOption.Value != null)
                    writer.WriteString("description", organizationInboxProjection.Description);
                else
                    writer.WriteNull("description");

            if (organizationInboxProjection.ExpiresAtOption.IsSet)
                if (organizationInboxProjection.ExpiresAtOption.Value != null)
                    writer.WriteString("expiresAt", organizationInboxProjection.ExpiresAtOption.Value.Value.ToString(ExpiresAtFormat));
                else
                    writer.WriteNull("expiresAt");

            var accountRegionRawValue = OrganizationInboxProjection.AccountRegionEnumToJsonValue(organizationInboxProjection.AccountRegionOption.Value.Value);
            if (accountRegionRawValue != null)
                writer.WriteString("accountRegion", accountRegionRawValue);
            else
                writer.WriteNull("accountRegion");
        }
    }
}
